<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>DoubleHappy or Jepson</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  
  <meta property="og:type" content="website">
<meta property="og:title" content="DoubleHappy or Jepson">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;page&#x2F;5&#x2F;index.html">
<meta property="og:site_name" content="DoubleHappy or Jepson">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="DoubleHappy or Jepson" type="application/atom+xml">
  
  
    <link rel="icon" href="/images/default-avatar.jpg">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/css/highlight.css">
</head>

<body>
  <div id="fullpage" class="mobile-nav-right">
    
      <div id="wrapper" title="图片来自网络">
    
    
      <header id="header">
  <div id="nav-toggle" class="nav-toggle"></div>
  <div class="head-box global-width">
    <nav class="nav-box nav-right">
      
        <a class="nav-item" href="/archives" title
        
        >首页</a>
      
        <a class="nav-item" href="/archives" title
        
        >归档</a>
      
    </nav>
  </div>
</header>
      <div id="middlecontent" title class="global-width sidebar-right">
        <section id="main">
  
    <article id="post-Scala语法细节03-double-happy" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/04/Scala%E8%AF%AD%E6%B3%95%E7%BB%86%E8%8A%8203-double-happy/">Scala语法细节03--double_happy</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2017/12/04/Scala%E8%AF%AD%E6%B3%95%E7%BB%86%E8%8A%8203-double-happy/" class="article-date">
  <time datetime="2017-12-04T11:45:31.000Z" itemprop="datePublished">2017-12-04</time>
</a>
    
    
  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <h2 id="续集细节03"><a href="#续集细节03" class="headerlink" title="续集细节03"></a>续集细节03</h2><p>（8）抽象类</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**  </span><br><span class="line">  * 抽象类:</span><br><span class="line">  * 1） 类中有一个或者多个方法/属性的定义，没有实现</span><br><span class="line">  * 2） 抽象类是不能直接new</span><br><span class="line">  * 3） 使用时要有完全实现了抽象方法/属性的子类才行</span><br><span class="line">  * 4） 子类重写父类方法或者属性时一定需要override吗  (不需要 可以加上 抽象类很神奇）</span><br><span class="line">  */</span><br><span class="line">object AbstractClassApp &#123;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val student = new Student2</span><br><span class="line">    student.speak</span><br><span class="line">    println(student.name)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abstract class Person2 &#123;</span><br><span class="line">  def speak</span><br><span class="line">  val name:String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student2 extends Person2 &#123;</span><br><span class="line">  def speak: Unit = &#123;</span><br><span class="line">    println(&quot;speak...&quot;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  val name: String = &quot;若泽&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>（9）数据结构<br>1.数组： 长度可变、长度不可变</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">长度不可变： new 的方式创建</span><br><span class="line">	1.String 类型的默认值是 null</span><br><span class="line">	2.如果不指定是 Nothing</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/2019090712590080.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTU1NzUxMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">不用new的方式 ：</span><br><span class="line">	集合里面不使用new 是调用 object的apply方法</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20190907130546599.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTU1NzUxMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190907130707681.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTU1NzUxMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190907130737578.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTU1NzUxMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">底层调用的是 object的 apply方法：</span><br><span class="line"></span><br><span class="line">/** Creates an array with given elements.</span><br><span class="line">   *</span><br><span class="line">   *  @param xs the elements to put in the array</span><br><span class="line">   *  @return an array containing all elements from xs.</span><br><span class="line">   */</span><br><span class="line">  // Subject to a compiler optimization in Cleanup.</span><br><span class="line">  // Array(e0, ..., en) is translated to &#123; val a = new Array(3); a(i) = ei; a &#125;</span><br><span class="line">  def apply[T: ClassTag](xs: T*): Array[T] = &#123;</span><br><span class="line">    val array = new Array[T](xs.length)</span><br><span class="line">    var i = 0</span><br><span class="line">    for (x &lt;- xs.iterator) &#123; array(i) = x; i += 1 &#125;</span><br><span class="line">    array</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">遍历：这里列出三种</span><br><span class="line"></span><br><span class="line">val a = Array(&quot;double_happy&quot;,&quot;sxwang&quot;,&quot;xxx&quot;)</span><br><span class="line"></span><br><span class="line">    for (el &lt;- a ) &#123;</span><br><span class="line">      println(el)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(&quot;----------------&quot;)</span><br><span class="line"></span><br><span class="line">    a.foreach(println(_))</span><br><span class="line"></span><br><span class="line">    println(&quot;-----------------&quot;)</span><br><span class="line"></span><br><span class="line">    for(el &lt;- 0 until a.size ) &#123;</span><br><span class="line">      println(a(el))</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20190907131328564.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTU1NzUxMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">其他知识点补充：</span><br><span class="line">	元素反转 </span><br><span class="line">	   使用reverse</span><br><span class="line">	   不使用reverse</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20190907131541816.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTU1NzUxMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">不适用reverse：</span><br><span class="line"> val a = Array(&quot;double_happy&quot;,&quot;sxwang&quot;,&quot;xxx&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //反转</span><br><span class="line">    for(i &lt;- a.size -1 to 0 by -1 ) &#123;</span><br><span class="line">      println(a(i))</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<p><img src="https://img-blog.csdnimg.cn/20190907131827710.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTU1NzUxMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">两个Array 相加：</span><br></pre></td></tr></table></figure></div>

<p><img src="https://img-blog.csdnimg.cn/20190907132018660.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTU1NzUxMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190907132148997.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTU1NzUxMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkString使用：查看数组内容</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20190907132701716.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTU1NzUxMg==,size_16,color_FFFFFF,t_70" alt="!\[在这里插入图片描述\](https://img-blog.csdnimg.cn/20190907132515616.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTU1NzUxMg==,si"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def mkString(start: String, sep: String, end: String): String =</span><br><span class="line">    addString(new StringBuilder(), start, sep, end).toString</span><br><span class="line"></span><br><span class="line">  def mkString(sep: String): String = mkString(&quot;&quot;, sep, &quot;&quot;)</span><br><span class="line"></span><br><span class="line">  def mkString: String = mkString(&quot;&quot;)</span><br></pre></td></tr></table></figure></div>
<p>能不能用toString呢？<br>不能哈 toString 默认是 打印 包名类名hashcode<br><img src="https://img-blog.csdnimg.cn/20190907132830284.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTU1NzUxMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>变长数组：ArrayBuffer</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">++  代表加的是类似的数据结构的</span><br></pre></td></tr></table></figure></div>

<p><img src="https://img-blog.csdnimg.cn/20190907133423329.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTU1NzUxMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190907133700874.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTU1NzUxMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/** Inserts new elements at a given index into this buffer.</span><br><span class="line"> *</span><br><span class="line"> *  @param n      the index where new elements are inserted.</span><br><span class="line"> *  @param elems  the traversable collection containing the elements to insert.</span><br><span class="line"> *  @throws   IndexOutOfBoundsException if the index `n` is not in the valid range</span><br><span class="line"> *            `0 &lt;= n &lt;= length`.</span><br><span class="line"> */</span><br><span class="line">def insert(n: Int, elems: A*) &#123; insertAll(n, elems) &#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/** Removes the element on a given index position. It takes time linear in</span><br><span class="line">  *  the buffer size.</span><br><span class="line">  *</span><br><span class="line">  *  @param n       the index which refers to the first element to delete.</span><br><span class="line">  *  @param count   the number of elements to delete</span><br><span class="line">  *  @throws IndexOutOfBoundsException if `n` is out of bounds.</span><br><span class="line">  */</span><br><span class="line"> override def remove(n: Int, count: Int) &#123;</span><br><span class="line">   require(count &gt;= 0, &quot;removing negative number of elements&quot;)</span><br><span class="line">   if (n &lt; 0 || n &gt; size0 - count) throw new IndexOutOfBoundsException(n.toString)</span><br><span class="line">   copy(n + count, n, size0 - (n + count))</span><br><span class="line">   reduceToSize(size0 - count)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/2019090713395130.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTU1NzUxMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/** Removes the last &apos;&apos;n&apos;&apos; elements of this buffer.</span><br><span class="line"> *</span><br><span class="line"> *  @param n  the number of elements to remove from the end</span><br><span class="line"> *            of this buffer.</span><br><span class="line"> */</span><br><span class="line">def trimEnd(n: Int) &#123; remove(length - n max 0, n) &#125;</span><br></pre></td></tr></table></figure></div>

<p><img src="https://img-blog.csdnimg.cn/20190907134106821.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTU1NzUxMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>（10）高阶函数</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">map：映射 一一映射</span><br><span class="line"></span><br><span class="line">    val a: Array[Int] = Array(1,2,4,5,6,7,8)</span><br><span class="line">    /**</span><br><span class="line">      * map : 一一映射</span><br><span class="line">      * f: A =&gt; B    ==&gt;  类似  y = f(x)   里面传的就是 匿名函数 </span><br><span class="line">      */</span><br><span class="line">    a.map((x : Int) =&gt; x * 2)</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20190907135107497.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTU1NzUxMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190907135947500.png" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filter：过滤掉不需要的东西 （true留下 false不留）</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/2019090714023648.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTU1NzUxMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">reduce：入参是两个</span><br><span class="line">def reduce[A1 &gt;: A](op: (A1, A1) =&gt; A1): A1 = reduceLeft(op)</span><br><span class="line"></span><br><span class="line">eg：  可以测试这个东西是个什么鬼</span><br><span class="line">    a.reduce(_+_)</span><br><span class="line">    a.reduceLeft(_-_)</span><br><span class="line">    a.reduceRight((a,b) =&gt;&#123;</span><br><span class="line">      println(a,b)</span><br><span class="line">      a - b</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20190907140836410.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTU1NzUxMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip ：  相同位置的放在一块  只有同等位置有的才有 没有就是没有</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20190907141336549.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTU1NzUxMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">flatten：把所有元素抽出来 放到一个Array里面</span><br><span class="line"></span><br><span class="line"> /** Flattens a two-dimensional array by concatenating all its rows</span><br><span class="line">   *  into a single array.</span><br><span class="line">   *</span><br><span class="line">   *  @tparam U        Type of row elements.</span><br><span class="line">   *  @param asTrav    A function that converts elements of this array to rows - arrays of type `U`.</span><br><span class="line">   *  @return          An array obtained by concatenating rows of this array.</span><br><span class="line">   */</span><br><span class="line">  def flatten[U](implicit asTrav: T =&gt; scala.collection.Traversable[U], m: ClassTag[U]): Array[U] = &#123;</span><br><span class="line">    val b = Array.newBuilder[U]</span><br><span class="line">    b.sizeHint(map&#123;case is: scala.collection.IndexedSeq[_] =&gt; is.size case _ =&gt; 0&#125;.sum)</span><br><span class="line">    for (xs &lt;- this)</span><br><span class="line">      b ++= asTrav(xs)</span><br><span class="line">    b.result()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">flatmap： 注意 flatten 和 flatmap的区别</span><br><span class="line">  def flatMap[B, That](f: A =&gt; GenTraversableOnce[B])(implicit bf: CanBuildFrom[Repr, B, That]): That = &#123;</span><br><span class="line">    def builder = bf(repr) // extracted to keep method size under 35 bytes, so that it can be JIT-inlined</span><br><span class="line">    val b = builder</span><br><span class="line">    for (x &lt;- this) b ++= f(x).seq</span><br><span class="line">    b.result</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20190907142118357.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTU1NzUxMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>flatmap的入参 是 Array[Int]  哟 </p>
<p><img src="https://img-blog.csdnimg.cn/20190907142427141.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTU1NzUxMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>map和flatmap的区别<br> map并没有做压扁操作 </p>
<p><img src="https://img-blog.csdnimg.cn/20190907142925268.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTU1NzUxMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">find ： 最多查找出满足条件的第一个元素</span><br><span class="line">  override /*IterableLike*/</span><br><span class="line">  def find(p: A =&gt; Boolean): Option[A] = &#123;</span><br><span class="line">    val i = prefixLength(!p(_))</span><br><span class="line">    if (i &lt; length) Some(this(i)) else None</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20190907143319998.png" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mapValues:  也是一一映射  map是作用在 value上面的  必须是 kv类型的</span><br></pre></td></tr></table></figure></div>


<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">groupBy ： 自定义分组  </span><br><span class="line">   def groupBy[K](f: A =&gt; K): immutable.Map[K, Repr] = &#123;</span><br><span class="line">    val m = mutable.Map.empty[K, Builder[A, Repr]]</span><br><span class="line">    for (elem &lt;- this) &#123;</span><br><span class="line">      val key = f(elem)</span><br><span class="line">      val bldr = m.getOrElseUpdate(key, newBuilder)</span><br><span class="line">      bldr += elem</span><br><span class="line">    &#125;</span><br><span class="line">    val b = immutable.Map.newBuilder[K, Repr]</span><br><span class="line">    for ((k, v) &lt;- m)</span><br><span class="line">      b += ((k, v.result))</span><br><span class="line"></span><br><span class="line">    b.result</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20190907144051113.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTU1NzUxMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">sortBy : 自定义排序     最好利用 List使用</span><br><span class="line">  /** Sorts this $Coll according to the Ordering which results from transforming</span><br><span class="line">   *  an implicitly given Ordering with a transformation function.</span><br><span class="line">   *  @see [[scala.math.Ordering]]</span><br><span class="line">   *  $willNotTerminateInf</span><br><span class="line">   *  @param   f the transformation function mapping elements</span><br><span class="line">   *           to some other domain `B`.</span><br><span class="line">   *  @param   ord the ordering assumed on domain `B`.</span><br><span class="line">   *  @tparam  B the target type of the transformation `f`, and the type where</span><br><span class="line">   *           the ordering `ord` is defined.</span><br><span class="line">   *  @return  a $coll consisting of the elements of this $coll</span><br><span class="line">   *           sorted according to the ordering where `x &lt; y` if</span><br><span class="line">   *           `ord.lt(f(x), f(y))`.</span><br><span class="line">   *</span><br><span class="line">   *  @example &#123;&#123;&#123;</span><br><span class="line">   *    val words = &quot;The quick brown fox jumped over the lazy dog&quot;.split(&apos; &apos;)</span><br><span class="line">   *    // this works because scala.Ordering will implicitly provide an Ordering[Tuple2[Int, Char]]</span><br><span class="line">   *    words.sortBy(x =&gt; (x.length, x.head))</span><br><span class="line">   *    res0: Array[String] = Array(The, dog, fox, the, lazy, over, brown, quick, jumped)</span><br><span class="line">   *  &#125;&#125;&#125;</span><br><span class="line">   */</span><br><span class="line">  def sortBy[B](f: A =&gt; B)(implicit ord: Ordering[B]): Repr = sorted(ord on f)</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20190907144622600.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTU1NzUxMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>（11）scala编写wordcount   先压扁再做操作</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">代码：好好理解   这块最好结合  mapreduce的wc ： map输出之后 相同的key  把不同的value值放到一个集合里 这个思想是重点</span><br><span class="line">    val wc = Array(&quot;spark,flink,hadoop&quot;,&quot;spark,hive,flink&quot;,&quot;kafka,flume,kafka&quot;)</span><br><span class="line">    </span><br><span class="line">    //1.拆分打平   打平用 flatMap</span><br><span class="line">    val words: Array[String] = wc.flatMap(_.split(&quot;,&quot;))</span><br><span class="line">    //2.转换kv</span><br><span class="line">    val word2one: Array[(String, Int)] = words.map((_,1))</span><br><span class="line">    //3.自定义分组</span><br><span class="line">    val groupByData: Map[String, Array[(String, Int)]] = word2one.groupBy(_._1)</span><br><span class="line">    //4.按key 求value的sum  </span><br><span class="line">    val result: Map[String, Int] = groupByData.mapValues(x=&gt; x.map(_._2).sum)</span><br><span class="line">    //5.将结果按 value的降序排</span><br><span class="line">    result.toList.sortBy(-_._2)</span><br></pre></td></tr></table></figure></div>

<p><img src="https://img-blog.csdnimg.cn/20190907150522765.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTU1NzUxMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">正常应该这样写：</span><br><span class="line">    val wc = Array(&quot;spark,flink,hadoop&quot;,&quot;spark,hive,flink&quot;,&quot;kafka,flume,kafka&quot;)</span><br><span class="line">    val resultWithSortDesc: List[(String, Int)] = wc.flatMap(_.split(&quot;,&quot;)).map((_,1)).groupBy(_._1).mapValues(_.map(_._2).sum).toList.sortBy(-_._2)</span><br><span class="line">    resultWithSortDesc.foreach(println(_))</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20190907150932908.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTU1NzUxMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>

      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-Scala语法细节02-double-happy" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/04/Scala%E8%AF%AD%E6%B3%95%E7%BB%86%E8%8A%8202-double-happy/">Scala语法细节02--double_happy</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2017/12/04/Scala%E8%AF%AD%E6%B3%95%E7%BB%86%E8%8A%8202-double-happy/" class="article-date">
  <time datetime="2017-12-04T11:44:49.000Z" itemprop="datePublished">2017-12-04</time>
</a>
    
    
  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <h2 id="续集-细节2"><a href="#续集-细节2" class="headerlink" title="续集-细节2"></a>续集-细节2</h2><p>（5）简单类的定义与使用</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">object SimpleClassApp &#123;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val people = new People   // 实例化一个Class对象</span><br><span class="line">    people.name = &quot;周琦&quot;  // 为对象赋值</span><br><span class="line">    people.age = 30</span><br><span class="line"></span><br><span class="line">//    people.gender</span><br><span class="line"></span><br><span class="line">    println(people.name + &quot; : &quot; + people.age )</span><br><span class="line"></span><br><span class="line">    people.playBasketball(&quot;China&quot;)</span><br><span class="line">    println(people.drink())  //白斩鸡</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">  * Scala中定义类：class 类名</span><br><span class="line">  * 类中有属性 有方法</span><br><span class="line">  */</span><br><span class="line">class People &#123;</span><br><span class="line"></span><br><span class="line">  // 属性的定义： val/var 名称:类型 =  值</span><br><span class="line">  var name:String = _  // _ 占位符  前提是一定要明确是什么数据类型</span><br><span class="line">  var age:Int = 3</span><br><span class="line"></span><br><span class="line">  // 私有</span><br><span class="line">  private var gender = &quot;M&quot;       //也是就外部不能访问  （也就是这个属性是见不得人的 只能在本类内使用）</span><br><span class="line"></span><br><span class="line">  // 定义方法</span><br><span class="line">  def playBasketball(team:String) = &#123;</span><br><span class="line">    println(name + &quot; is playing basketball of &quot; + team)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  def drink() = &#123;</span><br><span class="line">    name + &quot; is drinking...&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>（6）伴生类与伴生对象（非常有用 注意apply() 方法的使用 往往里面是new 一个伴生类 **）</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">object ApplyApp &#123;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line"></span><br><span class="line">//    ApplyTest.static</span><br><span class="line"></span><br><span class="line">//    val applyTest = new ApplyTest</span><br><span class="line">//    println(applyTest)</span><br><span class="line"></span><br><span class="line">//    val test = ApplyTest() // 类名() ==&gt; object apply</span><br><span class="line">//    println(test)</span><br><span class="line"></span><br><span class="line">    val applyTest = new ApplyTest</span><br><span class="line">    applyTest() // 对象() ==&gt; Class apply</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">      * 类名() ==&gt; 调用的是  Object apply   *****</span><br><span class="line">      * new出来的对象() ==&gt;  调用的是  Class apply *</span><br><span class="line">      */</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">  * class是object伴生类</span><br><span class="line">  * object是class的伴生对象</span><br><span class="line">  *</span><br><span class="line">  * object里面的方法直接通过  object.方法名   调用，不需要new</span><br><span class="line">  */</span><br><span class="line">class ApplyTest &#123;</span><br><span class="line"></span><br><span class="line">  def apply(): Unit =&#123;</span><br><span class="line">    println(&quot;class apply....&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">object ApplyTest &#123;</span><br><span class="line">  println(&quot;进入ApplyTest object&quot;)</span><br><span class="line"></span><br><span class="line">  def static: Unit = &#123;</span><br><span class="line">    println(&quot;我是static方法&quot;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 一般情况下object的apply方法的作用是完成new class</span><br><span class="line">  def apply() =&#123;</span><br><span class="line">    println(&quot;object apply....&quot;)</span><br><span class="line">    new ApplyTest</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  println(&quot;执行完ApplyTest object&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>（7）主构造器和附属构造器（非常重要 五星级别  spark源码里使用超多）</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">object ConstructorApp &#123;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">//    val person = new Person(&quot;穆里尼奥&quot;, 50)</span><br><span class="line">//    println(person.name + &quot; : &quot; + person.age + &quot; : &quot; + person.job)</span><br><span class="line">//</span><br><span class="line">//    val person2 = new Person(&quot;穆里尼奥&quot;, 50, &quot;皇家马德里&quot;)</span><br><span class="line">//    println(person2.name + &quot; : &quot; + person2.age + &quot; : &quot; + person2.job + &quot; : &quot; + person2.team)</span><br><span class="line">//    val sc = new SparkContext(&quot;&quot;,&quot;&quot;,null)</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">      * 子类构造方法/构造器执行之前一定要先执行父类的构造器</span><br><span class="line">      * 对于父类中没有的字段，要使用var/val修饰，否则访问不到</span><br><span class="line">      */</span><br><span class="line">    val student = new Student(&quot;穆里尼奥&quot;,50,&quot;翻译&quot;)</span><br><span class="line">//    println(student.job)</span><br><span class="line">    println(student)</span><br><span class="line">  &#125;&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">  * 类名(......)   主构造器 构造器里面的 也是属性呦</span><br><span class="line">  */</span><br><span class="line">class Person(val name:String, val age:Int) &#123;</span><br><span class="line"></span><br><span class="line">  println(&quot;进入Person构造器...&quot;)</span><br><span class="line">  val job = &quot;解说员&quot;</span><br><span class="line">  var team = &quot;&quot;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">    * 附属构造器的名称 this</span><br><span class="line">    * 每个附属构造器的第一行必须调用主构造器或者其他的附属构造器</span><br><span class="line">    */</span><br><span class="line">  def this(name:String, age:Int, team:String) &#123;</span><br><span class="line">    this(name, age)</span><br><span class="line">    this.team = team</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  println(&quot;执行完Person构造器...&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student(name:String,age:Int,val major:String) extends Person(name, age) &#123;</span><br><span class="line">  println(&quot;进入Student构造器...&quot;)</span><br><span class="line"></span><br><span class="line">  // 子类重写父类中的属性或者方法的修饰符</span><br><span class="line">  override val job: String = &quot;钟馗&quot;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">    * 如果 你想重写父类中的属性或者方法，需要使用override关键字来修饰</span><br><span class="line">    */</span><br><span class="line">  override def toString = name + &quot;    &quot; + job</span><br><span class="line"></span><br><span class="line">  println(&quot;执行完Student构造器...&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-Scala语法细节01-double-happy" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/03/Scala%E8%AF%AD%E6%B3%95%E7%BB%86%E8%8A%8201-double-happy/">Scala语法细节01--double_happy</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2017/12/03/Scala%E8%AF%AD%E6%B3%95%E7%BB%86%E8%8A%8201-double-happy/" class="article-date">
  <time datetime="2017-12-03T11:44:00.000Z" itemprop="datePublished">2017-12-03</time>
</a>
    
    
  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <h1 id="1-注意细节"><a href="#1-注意细节" class="headerlink" title="1.注意细节"></a>1.注意细节</h1><p>为了便于scala语言的理解下面总结常用的语法、数据结构、方法与函数、数据结构、主构造器与附属构造器、高阶函数</p>
<p>（1）基本语法</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1. 值与变量</span><br><span class="line">    值： val</span><br><span class="line">        val 名称:数据类型 = 值</span><br><span class="line">    变量：var</span><br><span class="line">        var 名称:数据类型 = 值</span><br><span class="line">2.数据类型</span><br><span class="line">	a.常用数据类型：</span><br><span class="line">	    String</span><br><span class="line">	    Int/Long/Float/Double</span><br><span class="line">	    Boolean</span><br><span class="line">	 b.数据类型转换与判断</span><br><span class="line">	     asInstanceOf[T]  数据类型转换</span><br><span class="line">	     isInstanceOf[T]  判断是否是某种数据类型</span><br><span class="line">3.顶层接口：Any</span><br><span class="line">    AnyVal： 值类型 （下面列出的需要注意）</span><br><span class="line">        数值</span><br><span class="line">        Boolean</span><br><span class="line">        Unit</span><br><span class="line">    AnyRef：引用类型</span><br></pre></td></tr></table></figure></div>
<p>（2）方法与函数</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">最简单的理解是：</span><br><span class="line">	def   ----&gt;  方法</span><br><span class="line">	val f1 = (a:Int,b:Int) =&gt; a+b   ----&gt; 函数(h=高阶函数里 传入的参数 几乎全是 匿名函数)</span><br><span class="line">  </span><br><span class="line">    方法的本质上就是一种特殊的函数</span><br><span class="line">    </span><br><span class="line">    方法用def定义，函数的标识=&gt;</span><br><span class="line">    </span><br><span class="line">	因为函数 官方定义的格式有很多  真的很多 这里最好的区别 方法与函数 就是 看 def 还是 val </span><br><span class="line"></span><br><span class="line">eg：定义function（这里应该确切说 是方法）</span><br><span class="line">def sum(x:Int, y:Int):Int = &#123;</span><br><span class="line">    // function体</span><br><span class="line">&#125;</span><br><span class="line">def: 定义的关键字</span><br><span class="line">sum：function的名字</span><br><span class="line">x:Int,y:Int  : function的入参</span><br><span class="line">Int :  返回值类型</span><br></pre></td></tr></table></figure></div>
<p>（3）循环</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    to []</span><br><span class="line">    until [)</span><br><span class="line">    Range [)</span><br><span class="line">   </span><br><span class="line">  eg: 常用的遍历</span><br><span class="line">  val arr = Array(1,2,3,4,5)</span><br><span class="line">  for( elm &lt;- arr)&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  for(index &lt;- 1 unitl arr.size)&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">注意： 1 unil 10  by 1    是可以指定步长的呦</span><br></pre></td></tr></table></figure></div>
<p>（4）变长参数与默认参数</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">eg：</span><br><span class="line">def  sum( number : Int*)&#123; //变长参数  （相当于一个数组 ）</span><br><span class="line">     </span><br><span class="line">&#125;</span><br><span class="line">def sum ( number : Int =3)&#123;  //默认参数</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">那么调用带有变长参数的方法 如何传参呢？</span><br><span class="line">val  numbers = Array(1,2,3,4,5)</span><br><span class="line">sum(numbers :_*)</span><br></pre></td></tr></table></figure></div>

      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-mapreduce原理02" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/02/mapreduce%E5%8E%9F%E7%90%8602/">mapreduce原理02</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2017/12/02/mapreduce%E5%8E%9F%E7%90%8602/" class="article-date">
  <time datetime="2017-12-02T11:43:10.000Z" itemprop="datePublished">2017-12-02</time>
</a>
    
    
  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <h1 id="1-combiner"><a href="#1-combiner" class="headerlink" title="1.combiner"></a>1.combiner</h1><p>map<br>partition<br>reduce<br>combiner</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">combiner :</span><br><span class="line">前提：</span><br><span class="line">正常模式下：</span><br><span class="line">InputSplit:</span><br><span class="line">   map:</span><br><span class="line">    (ruoze,1)</span><br><span class="line">    (ruoze,1)</span><br><span class="line">    (ruoze,1)</span><br><span class="line">    (jepson,1)</span><br><span class="line">    (jepson,1)</span><br><span class="line">    (xingxing,1)</span><br><span class="line"></span><br><span class="line">   reduce:</span><br><span class="line">    (ruoze,&lt;1,1,1&gt;)</span><br><span class="line">    </span><br><span class="line">combiner ：目的是解决map结束后本地预聚合（实际上是运行在map task 里的）</span><br><span class="line">Combiner: 就是一个本地化的Reduce，局部的聚合  Ruducer是全局的聚合</span><br><span class="line">    运行在MapTask</span><br><span class="line">    (ruoze,3)</span><br><span class="line">    (jepson,2)</span><br><span class="line">    (xingxing,1)</span><br><span class="line"></span><br><span class="line">好处是 shuffle时候map输出 到reduce  传输的数据量 会减少很多 减少io</span><br><span class="line"></span><br><span class="line">前提是  使用场景 不影响业务本身！！！</span><br></pre></td></tr></table></figure></div>
<h1 id="2-TopN（全局）"><a href="#2-TopN（全局）" class="headerlink" title="2.TopN（全局）"></a>2.TopN（全局）</h1><p>两个思路：假设有100个map，那么在map输出的时候</p>
<ol>
<li>是要输出map里所有的（利用reduce input时候 key排序 来设计 map端输出到reduce   在reduce端进行topn）</li>
<li>map输出的时候只需要输出map里的topn就可以呢（在map 方法里写 topn   最后使用clean up 输出 reduecer 那边和mapper类似）</li>
</ol>
<p>最好是现在map里处理好再输出。</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1，2 都有这个问题 ： 会把重复的key覆盖掉，注意不是treemap的问题 treemap是用来排序的 是key的类型的问题 key的类型的comparable方法的问题，所以这里你要自定义一个key的数据类型</span><br><span class="line"></span><br><span class="line">1方法. 不使用treemap mapper里全部输出 在reducer里做topn</span><br><span class="line"></span><br><span class="line">2方法.map里使用treemap   （会把重复的key覆盖掉，注意不是treemap的问题 treemap是用来排序的 是key的类型的问题 key的类型的comparable方法的问题，所以这里你要自定义一个key的数据类型 ）这个不用写reducer</span><br><span class="line"></span><br><span class="line">总结 ： 那么分区的topn 应该也会了吧</span><br></pre></td></tr></table></figure></div>
<h1 id="3-ArrayList"><a href="#3-ArrayList" class="headerlink" title="3.ArrayList"></a>3.ArrayList</h1><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">1.底层是一个object类型的数组</span><br><span class="line">2.线程不安全的   多线程情况下使用 Collections.synchronizedList(传一个list)</span><br><span class="line">    主要的属性</span><br><span class="line">        DEFAULT_CAPACITY = 10;</span><br><span class="line">        Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">        Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">        Object[] elementData;</span><br><span class="line">        int size;</span><br><span class="line">注意：</span><br><span class="line">1.问 new ArrayList() 它的数组size是多少 ？ 很多人认为是10   ，不是的 是空  </span><br><span class="line"></span><br><span class="line">方法</span><br><span class="line">        构造函数</span><br><span class="line">        add</span><br><span class="line">            是否扩容</span><br><span class="line">            添加</span><br><span class="line">            扩容：</span><br><span class="line">                原来是elementdata.length</span><br><span class="line">                原来的1.5倍   &gt;&gt; 1</span><br><span class="line">                Integer.MAX_VALUE</span><br><span class="line">        remove</span><br><span class="line"></span><br><span class="line">        特点：适合快速查找  inde</span><br><span class="line">        缺点：删除 指定index插入  性能很低 因为涉及到数组后续元素的移动</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">List&lt;String&gt; list = new ArrayList&lt;.();</span><br><span class="line"> list.add(&quot;ruoze&quot;);</span><br><span class="line"> list.add(&quot;double_hadppy&quot;);</span><br><span class="line"> list.add(&quot;double_hadppy&quot;);</span><br><span class="line"> list.add(&quot;double_hadppy&quot;);</span><br><span class="line"> list.add(&quot;kairis&quot;);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">*ruoze    double_hadppy  double_hadppy  double_hadppy   kairis</span><br><span class="line">*ruoze    do`在这里插入代码片`uble_hadppy  double_hadppy    kairis</span><br><span class="line">* ruoze    double_hadppy   kairis</span><br><span class="line">*/</span><br><span class="line">//删除</span><br><span class="line">for(int i = 0 ; i&lt; list.size(); i++)&#123;</span><br><span class="line">	if(list.get(i).equals(&quot;double_happy&quot;))&#123;</span><br><span class="line">	 	list.remove(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(list.size());</span><br><span class="line">//这个结果是什么呢？  ruoze    double_hadppy   kairis</span><br><span class="line">这个题很经典</span><br><span class="line">那么如何把 double_hadppy 全删掉呢？</span><br></pre></td></tr></table></figure></div>
<h1 id="4-outputformat"><a href="#4-outputformat" class="headerlink" title="4.outputformat"></a>4.outputformat</h1><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.自定义outputformat</span><br><span class="line">    a.实先Fileoutputformat</span><br><span class="line">    b.实现里面的recordwriter 方法</span><br><span class="line">    c.定义recordwriter类  带有构造方法（job）   通过输出流把数据写出去</span><br></pre></td></tr></table></figure></div>
<h1 id="5-把不同数据分类写入不同的文件（两种方法）"><a href="#5-把不同数据分类写入不同的文件（两种方法）" class="headerlink" title="5.把不同数据分类写入不同的文件（两种方法）"></a>5.把不同数据分类写入不同的文件（两种方法）</h1><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.自定义分区</span><br><span class="line">2.自定义outputformat</span><br></pre></td></tr></table></figure></div>

<h1 id="6-join"><a href="#6-join" class="headerlink" title="6.join"></a>6.join</h1><p>reducer join<br>map join</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">流程：</span><br><span class="line">emp</span><br><span class="line">    &lt;deptno, emp_value&gt;</span><br><span class="line">dept</span><br><span class="line">    &lt;deptno, dept_value&gt;</span><br><span class="line"></span><br><span class="line">==&gt; shuffle</span><br><span class="line">    &lt;deptno, &lt;emp_value,dept_value&gt;&gt;</span><br><span class="line"></span><br><span class="line">reduce join的原理：区分出来哪个数据来自于哪里 flag</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">reducer join：</span><br><span class="line">	1.自定义类型</span><br><span class="line">	2.mapper里 setup方法 context获取分片强转成FileSplit  获取文件名  在map方法里把不同表数据（这块写数据 可以使用 set方法 / 构造器 / 反射 ）写出去（设置flag）</span><br><span class="line">	3.reducer里   数据拆分</span><br></pre></td></tr></table></figure></div>
      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-MapReduce原理01" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/02/MapReduce%E5%8E%9F%E7%90%8601/">MapReduce原理01</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2017/12/02/MapReduce%E5%8E%9F%E7%90%8601/" class="article-date">
  <time datetime="2017-12-02T11:40:12.000Z" itemprop="datePublished">2017-12-02</time>
</a>
    
    
  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <h1 id="1-注意的小知识点"><a href="#1-注意的小知识点" class="headerlink" title="1.注意的小知识点"></a>1.注意的小知识点</h1><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.一个map task 处理一个InputSplit 数据（分片）</span><br><span class="line">2.reducer 的入参是 ：一个key 对应 一个value的集合</span><br><span class="line">3.文本的是可以分片的（不考虑压缩）</span><br></pre></td></tr></table></figure></div>

<h1 id="2-InputFormat-（输入数据的指定）-接口"><a href="#2-InputFormat-（输入数据的指定）-接口" class="headerlink" title="2.InputFormat （输入数据的指定） 接口"></a>2.InputFormat （输入数据的指定） 接口</h1><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.getSplits方法（拿到分片）</span><br><span class="line"></span><br><span class="line">2.RecordReader(上面拿到分片 ，这个分片就是提供RecordReader 读进来的)</span><br><span class="line"></span><br><span class="line">他的实现类有很多：</span><br><span class="line">1.isSplitable 方法 （是否可以分片 ，有压缩 就不一定可以分片的哦）</span><br></pre></td></tr></table></figure></div>



<h1 id="3-job-waitForCompletion流程"><a href="#3-job-waitForCompletion流程" class="headerlink" title="3.job.waitForCompletion流程"></a>3.job.waitForCompletion流程</h1><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">waitForCompletion&#123;</span><br><span class="line">    submit()&#123;</span><br><span class="line">        connect(); // 其实就是为了拿到一个cluster（Local YARN）</span><br><span class="line">        submitJobInternal()&#123;</span><br><span class="line">            checkSpecs(job);  // 为了检查输出目录是否存在</span><br><span class="line">            // 创建一个staging目录</span><br><span class="line">            Path jobStagingArea = JobSubmissionFiles.getStagingDir(cluster, conf);</span><br><span class="line">            // 获取该Job的id</span><br><span class="line">            JobID jobId = submitClient.getNewJobID();</span><br><span class="line">            job.setJobID(jobId);</span><br><span class="line">            // 本Job对应的目录: staging + jobid</span><br><span class="line">            Path submitJobDir = new Path(jobStagingArea, jobId.toString());</span><br><span class="line">            // 本Job的信息</span><br><span class="line">            copyAndConfigureFiles(job, submitJobDir);</span><br><span class="line">            // 获取该Job对应的map数量</span><br><span class="line">            int maps = writeSplits(job, submitJobDir);</span><br><span class="line">            // 本Job的信息写入到指定的文件中去</span><br><span class="line">            writeConf(conf, submitJobFile);</span><br><span class="line">            // 删除该Job对应的文件目录中的信息</span><br><span class="line">            jtFs.delete(submitJobDir, true);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="4-writeSplits-job-submitJobDir-讲解"><a href="#4-writeSplits-job-submitJobDir-讲解" class="headerlink" title="4.writeSplits(job, submitJobDir) 讲解"></a>4.writeSplits(job, submitJobDir) 讲解</h1><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">最重要的是求多少个分片 （map task的个数）</span><br><span class="line">1.默认splitSize 取得是 blocksize 128m</span><br><span class="line"></span><br><span class="line">问：一个129M的文件占用几个Block？几个InputSplit？</span><br><span class="line">答：2个Block 1个InputSplit</span><br><span class="line"></span><br><span class="line">一个文件如果没有超过块大小 它就是一个 分片</span><br><span class="line">如果一个文件大小超过splitsize的10% 就是两个分片</span><br><span class="line"></span><br><span class="line">为什么呢？</span><br><span class="line">2.源码有一个判断 当文件大小大于块大小的时候</span><br><span class="line">一个文件如果没有超过块大小 它就是一个 分片</span><br><span class="line">如果一个文件大小剩余部分超过splitsize的10% 就是两个分片</span><br><span class="line">剩余部分=文件大小减去块大小</span><br><span class="line"></span><br><span class="line">注意：与小文件合并的区别</span><br></pre></td></tr></table></figure></div>

<h1 id="5-小文件合并-讲解"><a href="#5-小文件合并-讲解" class="headerlink" title="5.小文件合并 讲解"></a>5.小文件合并 讲解</h1><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">如果有四个小文件 没有设置小文件合并  ，（一个文件如果没有超过块大小 它就是一个 分片）</span><br><span class="line">那么会开启四个map task 进程，这个是完全没有必要的，如何解决呢？</span><br><span class="line"></span><br><span class="line">解决：合并小文件</span><br><span class="line">CombineTextInputFormat   job设置inputformat 为CombineTextInputFormat.class  默认走的是TextInputFormat</span><br><span class="line">如果四个文件大小是 1m ,2m,4m,5m</span><br><span class="line">那么结果就是 使用一个map task  默认splitsize是128m</span><br><span class="line"></span><br><span class="line">继续：测试</span><br><span class="line">如果设置CombineTextInputFormat.setMaxInputSplitSize(job,4194304)  4m</span><br><span class="line">那么这次是几个分片呢？</span><br></pre></td></tr></table></figure></div>

<p>第一阶段：相当于是虚拟的</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1m      &lt;4m    即一个块  1m</span><br><span class="line"> 2m     &lt;4m      1个块  2m</span><br><span class="line"> 4m    &gt;4m    &lt; 2* 4  那么就拆成两块  2   2 </span><br><span class="line"> 5m   &gt;4m    &lt;2*4    那么就拆成两块  2.5   2.5</span><br></pre></td></tr></table></figure></div>
<p>第二阶段： 不足4 先补满4 即下满面2 会被拆成 1+1</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4&lt;1+2+1 = 4&lt;4*1.1   即第一个分片 </span><br><span class="line">4&lt;1 + 2+1 = 4 &lt;4*1.1  即第二个分片</span><br><span class="line">4&lt;1.5 + 2.5 = 4 &lt; 4 * 1.1 即第三个分片</span><br></pre></td></tr></table></figure></div>

<h1 id="6-NLInputformat-n行为一个split-按照行数进行分片"><a href="#6-NLInputformat-n行为一个split-按照行数进行分片" class="headerlink" title="6.NLInputformat (n行为一个split) 按照行数进行分片"></a>6.NLInputformat (n行为一个split) 按照行数进行分片</h1><p>eg:使用场景 ：</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.    100 列 * 100 行     5G</span><br><span class="line">2.  2 列  *    xxx 行       5G   </span><br><span class="line"> 那么 2 就要使用 按行数进行分片</span><br></pre></td></tr></table></figure></div>
<h1 id="7-分区"><a href="#7-分区" class="headerlink" title="7.分区"></a>7.分区</h1><p>分区是默认根据key来定义的，也就是map输出来做分区</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.Hashpartitioner</span><br><span class="line">(key.hashCode() &amp; Integer.MAX_VALUE) % numReduceTasks</span><br><span class="line"></span><br><span class="line">&amp; Integer.MAX_VALUE ?????? 这个东西是做什么用的呢？</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">2.自定义分区</span><br><span class="line">注意 ：job里设置 自定义分区的类.class </span><br><span class="line">2.分区数 就是 reduce task  的 个数 （可以这么理解 分区器里面 设计分区的个数 ，一般reduce task的个数是和分区数相等的）</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">1.有几个reduce 就有几个输出 ， spark里面有几个task就有几个输出</span><br><span class="line">2.reducer的个数越多你的分区数越多 ，分区数越多生成的文件越多 出现的小文件越多</span><br><span class="line">3.总结：</span><br><span class="line">    reducer task 个数 &gt; partitions    ，会有空文件产生</span><br><span class="line">     1  &lt; reducer task 个数 &lt; partitions   ,会报错</span><br><span class="line">     1= reduce task 个数  ,就是一个文件输出</span><br><span class="line"></span><br><span class="line">reduce 的个数增加 并行度增加了 同时 输出的文件也多了 小文件会多</span><br><span class="line">最好的选择是  ： 你能忍受输出的文件是多大  ，</span><br><span class="line">1 . 输出的文件大 那么reduce task 就设置小一些  （程序会跑的慢一些）</span><br><span class="line">2. 让程序跑块一些 ，就设置 reducer task 大一些  输出的文件会增加 文件的大小会小</span><br></pre></td></tr></table></figure></div>

<h1 id="8-排序"><a href="#8-排序" class="headerlink" title="8.排序"></a>8.排序</h1><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">排序 是按照 key  进行排序的</span><br><span class="line">按照recuer 的 输入的key 进行排序 （reducer 的输入 就是 mapper 的输出）</span><br><span class="line"></span><br><span class="line">bean类要实现writablecomparable 接口</span><br><span class="line"></span><br><span class="line">1.全局排序（生产生用的很少）只有 一个reduce 性能低</span><br><span class="line">2.分区排序</span><br></pre></td></tr></table></figure></div>
      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-HDFS高级命令使用-故障案例" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/01/HDFS%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8-%E6%95%85%E9%9A%9C%E6%A1%88%E4%BE%8B/">HDFS高级命令使用&amp;故障案例</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2017/12/01/HDFS%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8-%E6%95%85%E9%9A%9C%E6%A1%88%E4%BE%8B/" class="article-date">
  <time datetime="2017-12-01T11:39:04.000Z" itemprop="datePublished">2017-12-01</time>
</a>
    
    
  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <h1 id="1-高级命令"><a href="#1-高级命令" class="headerlink" title="1.高级命令"></a>1.高级命令</h1><h1 id="常用命令总结："><a href="#常用命令总结：" class="headerlink" title="常用命令总结："></a>常用命令总结：</h1><h1 id="一：HA命令"><a href="#一：HA命令" class="headerlink" title="一：HA命令"></a>一：HA命令</h1><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">操作HA 就用 hdfs haadmin</span><br><span class="line">[hadoop@ruozedata003 ~]$ hdfs haadmin</span><br><span class="line">Usage: DFSHAAdmin [-ns &lt;nameserviceId&gt;]</span><br><span class="line">    [-transitionToActive &lt;serviceId&gt; [--forceactive]]</span><br><span class="line">    [-transitionToStandby &lt;serviceId&gt;]</span><br><span class="line">    [-failover [--forcefence] [--forceactive] &lt;serviceId&gt; &lt;serviceId&gt;]</span><br><span class="line">    [-getServiceState &lt;serviceId&gt;]</span><br><span class="line">    [-checkHealth &lt;serviceId&gt;]</span><br><span class="line">    [-help &lt;command&gt;]</span><br></pre></td></tr></table></figure></div>
<pre><code>1.hdfs  haadmin  -getServiceState    nn1/nn2       查看serviceId的状态</code></pre><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">eg：</span><br><span class="line">[hadoop@ruozedata003 ~]$ hdfs haadmin -getServiceState nn1</span><br><span class="line">active</span><br><span class="line">[hadoop@ruozedata003 ~]$ hdfs haadmin -getServiceState nn2</span><br><span class="line">standby</span><br><span class="line">[hadoop@ruozedata003 ~]$</span><br></pre></td></tr></table></figure></div>
<p>小案例模拟：假设active 的 nn 被kill 掉了 ，standby 的 nn 能不能变成active？</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">（1）把 nn1的namenode kill掉</span><br><span class="line">			[hadoop@ruozedata001 ~]$ kill -9 4584</span><br><span class="line">			[hadoop@ruozedata001 ~]$ jps</span><br><span class="line">			5184 ResourceManager</span><br><span class="line">			4690 DataNode</span><br><span class="line">			4338 QuorumPeerMain</span><br><span class="line">			4883 JournalNode</span><br><span class="line">			5291 NodeManager</span><br><span class="line">			5836 Jps</span><br><span class="line">			5070 DFSZKFailoverController</span><br><span class="line">			[hadoop@ruozedata001 ~]$ </span><br><span class="line">（2）查看nn2的状态 </span><br><span class="line">			[hadoop@ruozedata003 ~]$ hdfs haadmin  -getServiceState nn1</span><br><span class="line">			19/08/24 17:49:08 INFO ipc.Client: Retrying connect to server: ruozedata001/172.17.76.204:8020. Already tried 0 time(s); retry policy is RetryUpToMaximumCountWithFixedSleep(maxRetries=1, sleepTime=1000 MILLISECONDS)</span><br><span class="line">			Operation failed: Call From ruozedata003/172.17.76.205 to ruozedata001:8020 failed on connection exception: java.net.ConnectException: Connection refused; For more details see:  http://wiki.apache.org/hadoop/ConnectionRefused</span><br><span class="line">			[hadoop@ruozedata003 ~]$ hdfs haadmin  -getServiceState nn2</span><br><span class="line">			active</span><br><span class="line">说明standby nn 切换成active</span><br><span class="line">（3）手动启动 nn1 单点的namenode</span><br><span class="line">			[hadoop@ruozedata001 ~]$ hadoop-daemon.sh start namenode</span><br><span class="line">			starting namenode, logging to /home/hadoop/app/hadoop-2.6.0-cdh5.15.1/logs/hadoop-hadoop-namenode-ruozedata001.out</span><br><span class="line">			[hadoop@ruozedata001 ~]$ jps</span><br><span class="line">			5184 ResourceManager</span><br><span class="line">			4690 DataNode</span><br><span class="line">			4338 QuorumPeerMain</span><br><span class="line">			4883 JournalNode</span><br><span class="line">			5989 Jps</span><br><span class="line">			5909 NameNode</span><br><span class="line">			5291 NodeManager</span><br><span class="line">			5070 DFSZKFailoverController</span><br><span class="line">			[hadoop@ruozedata001 ~]$ </span><br><span class="line">（4）查看各个serviceId的状态</span><br><span class="line">			[hadoop@ruozedata001 ~]$ hdfs haadmin  -getServiceState nn1</span><br><span class="line">			standby</span><br><span class="line">			[hadoop@ruozedata001 ~]$ hdfs haadmin  -getServiceState nn2</span><br><span class="line">			active</span><br><span class="line">			[hadoop@ruozedata001 ~]$</span><br></pre></td></tr></table></figure></div>
<p>2.把standby 切换为active的    失效转移<br>hdfs haadmin -failover  <serviceId> <serviceId>     第一个参数是active的nn   serviceId1的active转向serviceId2的active</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@ruozedata001 ~]$ hdfs haadmin -getServiceState nn1</span><br><span class="line">active</span><br><span class="line">[hadoop@ruozedata001 ~]$ hdfs haadmin -getServiceState nn2</span><br><span class="line">standby</span><br><span class="line">[hadoop@ruozedata001 ~]$ hdfs haadmin -failover nn2 nn1   </span><br><span class="line">Failover to NameNode at ruozedata001/172.17.76.204:8020 successful</span><br><span class="line">[hadoop@ruozedata001 ~]$ hdfs haadmin -getServiceState nn1</span><br><span class="line">active</span><br><span class="line">[hadoop@ruozedata001 ~]$ hdfs haadmin -getServiceState nn2</span><br><span class="line">standby</span><br><span class="line">[hadoop@ruozedata001 ~]$ hdfs haadmin -failover nn1 nn2</span><br><span class="line">Failover to NameNode at ruozedata002/172.17.76.206:8020 successful</span><br><span class="line">[hadoop@ruozedata001 ~]$ hdfs haadmin -getServiceState nn1</span><br><span class="line">standby</span><br><span class="line">[hadoop@ruozedata001 ~]$ hdfs haadmin -getServiceState nn2</span><br><span class="line">active</span><br><span class="line">[hadoop@ruozedata001 ~]$</span><br></pre></td></tr></table></figure></div>
<h1 id="二：HDFS集群的健康检查命令"><a href="#二：HDFS集群的健康检查命令" class="headerlink" title="二：HDFS集群的健康检查命令"></a>二：HDFS集群的健康检查命令</h1><p>当有文件损坏的时候 损坏的块/丢失的副本  </p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">做hdfs集群健康检查hdfs fsck</span><br><span class="line">[hadoop@ruozedata001 ~]$ hdfs fsck</span><br><span class="line">Usage: DFSck &lt;path&gt; [-list-corruptfileblocks | [-move | -delete | -openforwrite] [-files [-blocks [-locations | -racks]]]] [-maintenance]</span><br><span class="line">        &lt;path&gt;  start checking from this path</span><br><span class="line">        -move   move corrupted files to /lost+found</span><br><span class="line">        -delete delete corrupted files</span><br><span class="line">        -files  print out files being checked</span><br><span class="line">        -openforwrite   print out files opened for write</span><br><span class="line">        -includeSnapshots       include snapshot data if the given path indicates a snapshottable directory or there are snapshottable directories under it</span><br><span class="line">        -list-corruptfileblocks    print out list of missing blocks and files they belong to</span><br><span class="line">        -blocks print out block report</span><br><span class="line">        -locations      print out locations for every block</span><br><span class="line">        -racks  print out network topology for data-node locations</span><br><span class="line"></span><br><span class="line">        -maintenance    print out maintenance state node details</span><br><span class="line">        -blockId        print out which file this blockId belongs to, locations (nodes, racks) of this block, and other diagnostics info (under replicated, corrupted or not, etc)</span><br></pre></td></tr></table></figure></div>
<p>1.查看有没有损坏的块和丢失的副本</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@ruozedata001 ~]$ hdfs fsck /</span><br><span class="line">Connecting to namenode via http://ruozedata002:50070/fsck?ugi=hadoop&amp;path=%2F</span><br><span class="line">FSCK started by hadoop (auth:SIMPLE) from /172.17.76.204 for path / at Sat Aug 24 18:14:07 CST 2019</span><br><span class="line">Status: HEALTHY</span><br><span class="line"> Total size:    0 B</span><br><span class="line"> Total dirs:    7</span><br><span class="line"> Total files:   0</span><br><span class="line"> Total symlinks:                0</span><br><span class="line"> Total blocks (validated):      0</span><br><span class="line"> Minimally replicated blocks:   0</span><br><span class="line"> Over-replicated blocks:        0</span><br><span class="line"> Under-replicated blocks:       0</span><br><span class="line"> Mis-replicated blocks:         0</span><br><span class="line"> Default replication factor:    3</span><br><span class="line"> Average block replication:     0.0</span><br><span class="line"> Corrupt blocks:                0</span><br><span class="line"> Missing replicas:              0</span><br><span class="line"> Number of data-nodes:          3</span><br><span class="line"> Number of racks:               1</span><br><span class="line">FSCK ended at Sat Aug 24 18:14:07 CST 2019 in 2 milliseconds</span><br><span class="line">The filesystem under path &apos;/&apos; is HEALTHY</span><br><span class="line">[hadoop@ruozedata001 ~]$</span><br></pre></td></tr></table></figure></div>
<p>2.如果有损坏的块和丢失的副本  不想恢复他们想一了百了    只删除损坏的文件</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@ruozedata001 ~]$ hdfs fsck / -delete</span><br><span class="line">Connecting to namenode via http://ruozedata002:50070/fsck?ugi=hadoop&amp;delete=1&amp;path=%2F</span><br><span class="line">FSCK started by hadoop (auth:SIMPLE) from /172.17.76.204 for path / at Sat Aug 24 18:16:17 CST 2019</span><br><span class="line">Status: HEALTHY</span><br><span class="line"> Total size:    0 B</span><br><span class="line"> Total dirs:    7</span><br><span class="line"> Total files:   0</span><br><span class="line"> Total symlinks:                0</span><br><span class="line"> Total blocks (validated):      0</span><br><span class="line"> Minimally replicated blocks:   0</span><br><span class="line"> Over-replicated blocks:        0</span><br><span class="line"> Under-replicated blocks:       0</span><br><span class="line"> Mis-replicated blocks:         0</span><br><span class="line"> Default replication factor:    3</span><br><span class="line"> Average block replication:     0.0</span><br><span class="line"> Corrupt blocks:                0</span><br><span class="line"> Missing replicas:              0</span><br><span class="line"> Number of data-nodes:          3</span><br><span class="line"> Number of racks:               1</span><br><span class="line">FSCK ended at Sat Aug 24 18:16:17 CST 2019 in 0 milliseconds</span><br><span class="line">The filesystem under path &apos;/&apos; is HEALTHY</span><br></pre></td></tr></table></figure></div>
<p>注意：如果不想删除损坏的文件怎么办呢？（作业）<br>3.损坏的文件 在哪些块上面（因为也不知道文件的这些块分布在那台机器上面） -list-corruptfileblocks  会打印损坏的文件的哪些块损坏了或丢失了</p>
<h1 id="三：HDFS集群案例"><a href="#三：HDFS集群案例" class="headerlink" title="三：HDFS集群案例"></a>三：HDFS集群案例</h1><p>1.现象是：<br>断电 导致HDFS服务不正常或者显示块损坏</p>
<p>2.检查HDFS系统文件健康状态<br>hdfs fsck /  或者在50070的页面查看(这个命令只会显示哪个文件损坏了)</p>
<p>3.检查 损坏的文件的哪些块损坏 (加上-list-corruptfileblocks 参数)</p>
<p>hdfs fsck / -list-corruptfileblocks   会打印出损坏的块<br>这块会打印出哪个文件的哪些块损坏</p>
<p>4.解决<br> 1.第一种解决办法：不建议 耗时<br>    把损坏的数据 重新刷一份到HDFS平台即可（前提你明确知道  重刷的哪个数据（就是你删除哪个损坏文件 对应的源头数据在哪））<br> 2.第二种解决办法：下面的实验</p>
<p>5.想要知道文件的哪些块分布在哪些机器上面？<br>  如果我知道哪个文件的哪些块在哪台机器上面 我就可以手工的把那个块删掉了（使用linux命令） 就不用使用 hdfs fsck / -delete </p>
<p> 因为 hdfs fsck / -delete  他是删除损坏的文件 （直接把损坏的文件干掉了 而不是删除损坏的块）</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">但是 有一个问题 如果这个损坏的块被删除 你的数据该如何完整的恢复？ 你怎么知道删除的那个块 数据丢了多少？ 根本不知道</span><br></pre></td></tr></table></figure></div>



<p>实验：上传一个文件到hdfs上 （三个副本），在某台机器上找到对应的副本文件 删掉一个副本文件<br>最终使用hdfs debug 来利用其余两个好的副本恢复损坏的文件</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">重要的命令：hdfs debug</span><br><span class="line">[hadoop@ruozedata001 ~]$ hdfs debug</span><br><span class="line">Usage: hdfs debug &lt;command&gt; [arguments]</span><br><span class="line">These commands are for advanced users only.</span><br><span class="line">Incorrect usages may result in data loss. Use at your own risk.</span><br><span class="line">verifyMeta -meta &lt;metadata-file&gt; [-block &lt;block-file&gt;]</span><br><span class="line">computeMeta -block &lt;block-file&gt; -out &lt;output-metadata-file&gt;</span><br><span class="line">recoverLease -path &lt;path&gt; [-retries &lt;num-retries&gt;]</span><br><span class="line">[hadoop@ruozedata001 ~]$</span><br></pre></td></tr></table></figure></div>
      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-HDFS-Yarn-HA-部署-第二次" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/18/HDFS-Yarn-HA-%E9%83%A8%E7%BD%B2-%E7%AC%AC%E4%BA%8C%E6%AC%A1/">HDFS&amp;Yarn HA 部署 第二次</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2017/11/18/HDFS-Yarn-HA-%E9%83%A8%E7%BD%B2-%E7%AC%AC%E4%BA%8C%E6%AC%A1/" class="article-date">
  <time datetime="2017-11-18T11:37:53.000Z" itemprop="datePublished">2017-11-18</time>
</a>
    
    
  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <h1 id="1-部署前提注意"><a href="#1-部署前提注意" class="headerlink" title="1.部署前提注意"></a>1.部署前提注意</h1><p>1.部署cdh的时候 命名空间要注意 默认是nameservice1<br>2.三台机器创建hadoop用户 没有密码的<br>3.创建常用的文件夹 上传jar包<br>4.配置三台机器的hostname（内网的ip） + ssh等<br>5.部署的时候是hadoop用户 没有密码的 如何配置三台机器的ssh呢？<br>ssh-keygen<br>去hadoop官网找 配公钥<br>第一台为主节点 先做第一台 注意known_hosts (如果你的1号机器.ssh变动了 这个文件里会存历史记录 当2号机访问1号机就会出问题 ，删掉这个文件就可以解决)</p>
<h1 id="2-ssh三台机器互通"><a href="#2-ssh三台机器互通" class="headerlink" title="2.ssh三台机器互通"></a>2.ssh三台机器互通</h1><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.ssh-keygen</span><br><span class="line">2.参考hadoop.apache.org官网ssh配置  (这个是参考 主要是注意 authorized_keys 和权限)</span><br><span class="line">http://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-common/SingleCluster.html</span><br><span class="line">  $ ssh-keygen -t rsa -P &apos;&apos; -f ~/.ssh/id_rsa    这里我们不用</span><br><span class="line">  $ cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</span><br><span class="line">  $ chmod 0600 ~/.ssh/authorized_keys</span><br><span class="line"> 3.以第一台为主节点配置authorized_keys 然后再分发给各个节点，由于没有密码个机器的台数比较少</span><br><span class="line"> 我们这里不能用scp ，所以我们采用把 各个节点的公钥id_rsa.pub下载到本地eg：id_rsa.pub001 ，id_rsa.pub002 来标识 最后都上传到主节点</span><br><span class="line"> 上追加到authorized_keys，再把authorized_keys下载上传给各个节点。</span><br></pre></td></tr></table></figure></div>
<p>authorized_keys 配置图片：<br><img src="https://img-blog.csdnimg.cn/20190819231514890.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTU1NzUxMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4.</span><br><span class="line">ssh ruozedata001 date</span><br><span class="line">ssh ruozedata002  date </span><br><span class="line">ssh ruozedata003 date</span><br><span class="line">每台机器都要执行一遍 （每一个命令第一遍要输入yes，如果提示输入密码代表 你的authorized_keys 权限没有变成600）</span><br></pre></td></tr></table></figure></div>
<h1 id="3-HDFS-amp-Yarn-HA-部署"><a href="#3-HDFS-amp-Yarn-HA-部署" class="headerlink" title="3.HDFS&amp;Yarn HA 部署"></a>3.HDFS&amp;Yarn HA 部署</h1><p>配置文件获取：<a href="https://pan.baidu.com/s/1PGbLbqMOQfc_iF_n7m5a8A" target="_blank" rel="noopener">https://pan.baidu.com/s/1PGbLbqMOQfc_iF_n7m5a8A</a>     提取码：jdec</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.上传jar包到主节点，scp到从节点（上面配置完互信了）</span><br><span class="line">2.配置jave是注意 路径必须是 /usr/java （cdh决定的）</span><br><span class="line">部署jdk本文就不讲了 注意用户和用户组 这点很重要 chown -R root:root /usr/java/*</span><br></pre></td></tr></table></figure></div>
<p>(1)zk部署</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.解压</span><br><span class="line">2.软连接 （好处是 软件版本升级的时候 个人配置文件的home的路径不用变动 方便版本管理）ls -s zookeep   zookeeper4</span><br><span class="line">3.安装</span><br><span class="line">[hadoop@ruozedata001 conf]$ ll</span><br><span class="line">total 16</span><br><span class="line">-rw-rw-r-- 1 hadoop hadoop  535 Feb 20  2014 configuration.xsl</span><br><span class="line">-rw-rw-r-- 1 hadoop hadoop 2161 Feb 20  2014 log4j.properties</span><br><span class="line">-rw-rw-r-- 1 hadoop hadoop 1032 Aug 20 00:11 zoo.cfg</span><br><span class="line">-rw-rw-r-- 1 hadoop hadoop  922 Feb 20  2014 zoo_sample.cfg</span><br><span class="line">[hadoop@ruozedata001 conf]$ cp zoo_sample.cfg zoo.cfg</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"># The number of milliseconds of each tick</span><br><span class="line">tickTime=2000</span><br><span class="line"># The number of ticks that the initial </span><br><span class="line"># synchronization phase can take</span><br><span class="line">initLimit=10</span><br><span class="line"># The number of ticks that can pass between </span><br><span class="line"># sending a request and getting an acknowledgement</span><br><span class="line">syncLimit=5</span><br><span class="line"># the directory where the snapshot is stored.</span><br><span class="line"># do not use /tmp for storage, /tmp here is just </span><br><span class="line"># example sakes.</span><br><span class="line">dataDir=/home/hadoop/data/zookeeper           ****这块要改一下 统一放到 data下</span><br><span class="line"></span><br><span class="line">server.1=ruozedata001:2888:3888               *****zookeeper内部通讯端口要配置一下</span><br><span class="line">server.2=ruozedata002:2888:3888</span><br><span class="line">server.3=ruozedata003:2888:3888</span><br><span class="line"># the port at which the clients will connect</span><br><span class="line">clientPort=2181</span><br><span class="line"># the maximum number of client connections.</span><br><span class="line"># increase this if you need to handle more clients</span><br><span class="line">#maxClientCnxns=60</span><br><span class="line">#</span><br><span class="line"># Be sure to read the maintenance section of the </span><br><span class="line"># administrator guide before turning on autopurge.</span><br><span class="line">#</span><br><span class="line"># http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance</span><br><span class="line">#</span><br><span class="line"># The number of snapshots to retain in dataDir</span><br><span class="line">#autopurge.snapRetainCount=3</span><br><span class="line"># Purge task interval in hours</span><br><span class="line"># Set to &quot;0&quot; to disable auto purge feature</span><br><span class="line">#autopurge.purgeInterval=1</span><br></pre></td></tr></table></figure></div>
<p>mkdir /home/hadoop/data/zookeeper 目录 接着去这个目录下 配置myid (zk集群的机器号)</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@ruozedata001 zookeeper]$ echo 1 &gt; ~/data/zookeeper/myid</span><br><span class="line">[hadoop@ruozedata002 zookeeper]$ echo 2 &gt; ~/data/zookeeper/myid</span><br><span class="line">[hadoop@ruozedata003 zookeeper]$ echo 3 &gt; ~/data/zookeeper/myid</span><br><span class="line">注意： &gt; 前后是有空格的 不然机器号写不进去myid的</span><br><span class="line"></span><br><span class="line">接着在把zookeeper添加到个人环境变量中(三台机器一起操作)</span><br><span class="line">[hadoop@ruozedata001 zookeeper]$ vim ~/.bash_profile</span><br><span class="line"></span><br><span class="line"># .bash_profile</span><br><span class="line"></span><br><span class="line"># Get the aliases and functions</span><br><span class="line">if [ -f ~/.bashrc ]; then</span><br><span class="line">        . ~/.bashrc</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># User specific environment and startup programs</span><br><span class="line"></span><br><span class="line">export ZOOKEEPER_HOME=/home/hadoop/app/zookeeper</span><br><span class="line">export PATH=$ZOOKEEPER_HOME/bin:$PATH</span><br><span class="line"></span><br><span class="line">最后检查是否安装成功</span><br><span class="line">[hadoop@ruozedata001 zookeeper]$ which zkServer.sh</span><br><span class="line">~/app/zookeeper/bin/zkServer.sh</span><br></pre></td></tr></table></figure></div>
<p>启动zk<br>zkServer.sh start<br>zkServer.sh status<br>（2）HDFS部署</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.vim hadoop-env.sh</span><br><span class="line"></span><br><span class="line"># The java implementation to use.</span><br><span class="line">export JAVA_HOME=/usr/java/jdk1.8.0_45               ***************这个路径要改java的不要用 $&#123;JAVA_HOME&#125; </span><br><span class="line"></span><br><span class="line"># The jsvc implementation to use. Jsvc is required to run secure datanodes</span><br><span class="line"># that bind to privileged ports to provide authentication of data transfer</span><br><span class="line"># protocol.  Jsvc is not required if SASL is configured for authentication of</span><br><span class="line"># data transfer protocol using non-privileged ports.</span><br><span class="line">#export JSVC_HOME=$&#123;JSVC_HOME&#125;</span><br><span class="line"></span><br><span class="line">export HADOOP_CONF_DIR=$&#123;HADOOP_CONF_DIR:-&quot;/etc/hadoop&quot;&#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">2.删掉core-site.xml yarn-site.xml slaves hdfs-site.xml    用自己提供的.xml</span><br><span class="line">rm -f slaves yarn-site.xml hdfs-site.xml core-site.xml</span><br><span class="line">三台机器上传提供好的配置文件</span><br><span class="line">core-site.xml 需要注意：</span><br><span class="line">   a.创建临时文件夹（与core-site.xml里的要一样）</span><br><span class="line">        mkdir -p  /home/hadoop/tmp/hadoop</span><br><span class="line">       chmod -R 777 /home/hadoop/tmp/hadoop</span><br><span class="line"> b.hosts 与 groups  这是运行那些机器和那些用户组可以访问 注意</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3.hdfs-site.xml  注意：</span><br><span class="line">块大小 和 副本数    按自己公司配置  官网上可以查看默认的配置</span><br><span class="line">http://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-hdfs/hdfs-default.xml</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20190820233915106.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTU1NzUxMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3.hdfs-site.xml 注意：</span><br><span class="line">HA</span><br><span class="line">命名空间</span><br><span class="line">journalNode</span><br><span class="line">私钥的路径</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">4.mapreduce-site.xml注意：</span><br><span class="line">配置map端输出的压缩</span><br><span class="line">为什么使用snappy呢？压缩快解压快</span><br><span class="line">https://ruozedata.github.io/2018/04/18/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9%EF%BC%8C%E4%BD%A0%E4%BB%AC%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F/</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">5.yarn-site.xml 注意：</span><br><span class="line"> Ha</span><br><span class="line"> 日志aggregation（分布式 把日志聚合起来）</span><br><span class="line"> nodemanager的内存 + 最小调度内存 + 最大分配内存  cpu-vcores (几比几的意思 2 =》就是 1 比 2 的意思)</span><br><span class="line"> 这看基础班的视频在 b站 这块很重要 日后调优很重要</span><br></pre></td></tr></table></figure></div>
<p>配置hadoop的环境变量</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># .bash_profile</span><br><span class="line"></span><br><span class="line"># Get the aliases and functions</span><br><span class="line">if [ -f ~/.bashrc ]; then</span><br><span class="line">        . ~/.bashrc</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># User specific environment and startup programs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export ZOOKEEPER_HOME=/home/hadoop/app/zookeeper</span><br><span class="line">export PATH=$ZOOKEEPER_HOME/bin:$PATH</span><br><span class="line">export HADOOP_HOME=/home/hadoop/app/hadoop</span><br><span class="line">export PATH=$HADOOP_HOME/bin:$HADOOP_HOME/sbin:$PATH</span><br></pre></td></tr></table></figure></div>

<p>（3）启动集群</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">1.启动journalnode   三台一块做</span><br><span class="line">hadoop-daemon.sh start journalnode</span><br><span class="line">2.格式化namenode （这就不用三台一块做 选取第一台即可）</span><br><span class="line"> hadoop namenode -format</span><br><span class="line"> 3.第一台namenode ok了 要同步第一台元数据到第二台</span><br><span class="line"> scp -r  /home/hadoop/data/dfs/name/     hadoop@ruozedata002:/home/hadoop/data/dfs/</span><br><span class="line"> 这两个nn元数据要保持一样</span><br><span class="line"> 4.初始化zkfc (一台机器就可以了  zk是个集群 无需别的机器还去做)</span><br><span class="line"> hdfs zkfc -formatZK</span><br><span class="line"> 5.启动hdfs （一台）</span><br><span class="line"> start-dfs.sh </span><br><span class="line"> 这块有个坑：</span><br><span class="line">				 [hadoop@ruozedata001 dfs]$  start-dfs.sh </span><br><span class="line">				Starting namenodes on [ruozedata001 ruozedata002]</span><br><span class="line">				ruozedata001: starting namenode, logging to /home/hadoop/app/hadoop-2.6.0-cdh5.15.1/logs/hadoop-hadoop-namenode-ruozedata001.out</span><br><span class="line">				ruozedata002: starting namenode, logging to /home/hadoop/app/hadoop-2.6.0-cdh5.15.1/logs/hadoop-hadoop-namenode-ruozedata002.out</span><br><span class="line">				: Name or service not knownstname ruozedata001</span><br><span class="line">				: Name or service not knownstname ruozedata002</span><br><span class="line">				ruozedata003: starting datanode, logging to /home/hadoop/app/hadoop-2.6.0-cdh5.15.1/logs/hadoop-hadoop-datanode-ruozedata003.out</span><br><span class="line">				Starting journal nodes [ruozedata001 ruozedata002 ruozedata003]</span><br><span class="line">				ruozedata002: journalnode running as process 2392. Stop it first.</span><br><span class="line">				ruozedata003: journalnode running as process 2372. Stop it first.</span><br><span class="line">				ruozedata001: journalnode running as process 2468. Stop it first.</span><br><span class="line">				Starting ZK Failover Controllers on NN hosts [ruozedata001 ruozedata002]</span><br><span class="line">				ruozedata001: starting zkfc, logging to /home/hadoop/app/hadoop-2.6.0-cdh5.15.1/logs/hadoop-hadoop-zkfc-ruozedata001.out</span><br><span class="line">				ruozedata002: starting zkfc, logging to /home/hadoop/app/hadoop-2.6.0-cdh5.15.1/logs/hadoop-hadoop-zkfc-ruozedata002.out</span><br><span class="line"> </span><br><span class="line">这个日志倒着看  zk启动 jn启动 dn001 和dn002 启动报错  为什么？</span><br><span class="line"></span><br><span class="line">        dn是slaves 文件控制的 检查这个文件</span><br><span class="line"></span><br><span class="line">扩展小知识点：</span><br><span class="line">    linux文件的类型分为两种 window的格式/ linux本身的格式</span><br><span class="line">    这两种格式再Linux下都可以cat </span><br><span class="line"></span><br><span class="line">file slaves  :(查看文件类型)</span><br><span class="line">[hadoop@ruozedata001 hadoop]$ cat slaves </span><br><span class="line">ruozedata001</span><br><span class="line">ruozedata002</span><br><span class="line">ruozedata003[hadoop@ruozedata001 hadoop]$ file slaves </span><br><span class="line">slaves: ASCII text, with CRLF line terminators</span><br><span class="line"></span><br><span class="line">slaves: ASCII text, with CRLF line terminators说明类型是windows的   需要windows 转换成Linux的  </span><br><span class="line">解决：</span><br><span class="line">[root@ruozedata001 ~]# yum install -y dos2unix</span><br><span class="line">[hadoop@ruozedata001 hadoop]$ file slaves </span><br><span class="line">slaves: ASCII text, with CRLF line terminators</span><br><span class="line">[hadoop@ruozedata001 hadoop]$ dos2unix slaves </span><br><span class="line">dos2unix: converting file slaves to Unix format ...</span><br><span class="line">[hadoop@ruozedata001 hadoop]$ file slaves </span><br><span class="line">slaves: ASCII text</span><br><span class="line">hadoop@ruozedata001 hadoop]$ pwd</span><br><span class="line">/home/hadoop/app/hadoop/etc/hadoop</span><br><span class="line">[hadoop@ruozedata001 hadoop]$ scp slaves ruozedata002:/home/hadoop/app/hadoop/etc/hadoop/</span><br><span class="line">slaves                                          100%   38     0.0KB/s   00:00    </span><br><span class="line">[hadoop@ruozedata001 hadoop]$ scp slaves ruozedata003:/home/hadoop/app/hadoop/etc/hadoop/</span><br><span class="line">slaves                                          100%   38     0.0KB/s   00:00    </span><br><span class="line">[hadoop@ruozedata001 hadoop]$</span><br><span class="line"></span><br><span class="line">再次启动：</span><br><span class="line"> start-dfs.sh </span><br><span class="line">		[hadoop@ruozedata001 hadoop]$ start-dfs.sh </span><br><span class="line">		Starting namenodes on [ruozedata001 ruozedata002]</span><br><span class="line">		ruozedata001: namenode running as process 2765. Stop it first.</span><br><span class="line">		ruozedata002: namenode running as process 11693. Stop it first.</span><br><span class="line">		ruozedata003: datanode running as process 11654. Stop it first.</span><br><span class="line">		ruozedata002: starting datanode, logging to /home/hadoop/app/hadoop-2.6.0-cdh5.15.1/logs/hadoop-hadoop-datanode-ruozedata002.out</span><br><span class="line">		ruozedata001: starting datanode, logging to /home/hadoop/app/hadoop-2.6.0-cdh5.15.1/logs/hadoop-hadoop-datanode-ruozedata001.out</span><br><span class="line">		Starting journal nodes [ruozedata001 ruozedata002 ruozedata003]</span><br><span class="line">		ruozedata003: journalnode running as process 2372. Stop it first.</span><br><span class="line">		ruozedata001: journalnode running as process 2468. Stop it first.</span><br><span class="line">		ruozedata002: journalnode running as process 2392. Stop it first.</span><br><span class="line">		Starting ZK Failover Controllers on NN hosts [ruozedata001 ruozedata002]</span><br><span class="line">		ruozedata001: zkfc running as process 3076. Stop it first.</span><br><span class="line">		ruozedata002: zkfc running as process 11816. Stop it first.</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20190821003503698.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTU1NzUxMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6.访问hdfs页面50070</span><br></pre></td></tr></table></figure></div>
<p>避免被挖矿配置只有自己的电脑ip能访问<br><img src="https://img-blog.csdnimg.cn/20190821004032963.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTU1NzUxMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>active:<img src="https://img-blog.csdnimg.cn/20190821004617486.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTU1NzUxMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>standby:<br><img src="https://img-blog.csdnimg.cn/20190821004657105.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTU1NzUxMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">7.start-yarn.sh (一台)</span><br><span class="line">这块第二台的rm是启动不起来的 需要手工去启动</span><br><span class="line">yarn-daemon.sh start resourcemanager(第二台)</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20190821004943576.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTU1NzUxMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>手工启动后：<br><img src="https://img-blog.csdnimg.cn/20190821005107475.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTU1NzUxMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">8.访问yarn页面</span><br><span class="line">注意：</span><br><span class="line">active :ip1:8080 就可以直接访问</span><br><span class="line">standby：ip2:8080/cluster/cluster   才可以访问 他直接8080 访问不了</span><br></pre></td></tr></table></figure></div>

<p>active:<br><img src="https://img-blog.csdnimg.cn/20190821005354827.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTU1NzUxMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>standby:<br><img src="https://img-blog.csdnimg.cn/20190821005540689.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTU1NzUxMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9.$HADOOP_HOME/sbin/mr-jobhistory-daemon.sh start historyserver (001上启动 配置文件里配置的)</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20190821010246716.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTU1NzUxMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>访问页面：<br>  <img src="https://img-blog.csdnimg.cn/20190821010457174.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTU1NzUxMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>(4）关闭集群<br>倒着关闭<br>[root@hadoop001 sbin]# stop-yarn.sh<br>[root@hadoop002 sbin]# yarn-daemon.sh stop resourcemanager<br>[root@hadoop001 sbin]# stop-dfs.sh</p>
<p>(5)常用脚本及命令</p>
<p>1.启动集群<br>[root@hadoop001 ~]# $ZOOKEEPER_HOME/bin/zkServer.sh start<br>[root@hadoop002 ~]# $ZOOKEEPER_HOME/bin/zkServer.sh start<br>[root@hadoop003 ~]# $ZOOKEEPER_HOME/bin/zkServer.sh start<br>[root@hadoop001 ~]# $HADOOP_HOME/sbin/start-all.sh  （hdfs +yarn）<br>[root@hadoop002 ~]# $HADOOP_HOME/sbin/yarn-daemon.sh start resourcemanager<br>[root@hadoop001 ~]# $HADOOP_HOME/sbin/mr-jobhistory-daemon.sh start historyserver<br>2.关闭集群<br>[root@hadoop001 ~]# $HADOOP_HOME/sbin/mr-jobhistory-daemon.sh stop historyserver<br>[root@hadoop002 ~]# $HADOOP_HOME /sbin/yarn-daemon.sh stop resourcemanager<br>[root@hadoop001 ~]# $HADOOP_HOME /sbin/stop-all.sh<br>[root@hadoop001 ~]# $ZOOKEEPER_HOME /bin/zkServer.sh stop<br>[root@hadoop002 ~]# $ZOOKEEPER_HOME /bin/zkServer.sh stop</p>

      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-HDFS-Yarn-HA" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/17/HDFS-Yarn-HA/">HDFS&amp;Yarn HA</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2017/11/17/HDFS-Yarn-HA/" class="article-date">
  <time datetime="2017-11-17T11:33:40.000Z" itemprop="datePublished">2017-11-17</time>
</a>
    
    
  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <h1 id="1-Hadoop编译"><a href="#1-Hadoop编译" class="headerlink" title="1.Hadoop编译"></a>1.Hadoop编译</h1><p>总结一下在开发机上编译源码的小问题：<br>1.maven的setting.xml的配置</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;mirror&gt;</span><br><span class="line">     &lt;id&gt;nexus-aliyun&lt;/id&gt;</span><br><span class="line">     &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;</span><br><span class="line">     &lt;name&gt;Nexus aliyun&lt;/name&gt;</span><br><span class="line">     &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;</span><br><span class="line">&lt;/mirror&gt;</span><br><span class="line">&lt;mirror&gt;</span><br><span class="line">     &lt;id&gt;cloudera&lt;/id&gt;</span><br><span class="line">     &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;</span><br><span class="line">     &lt;name&gt;cloudera&lt;/name&gt;</span><br><span class="line">     &lt;url&gt;https://repository.cloudera.com/artifactory/cloudera-repos/&lt;/url&gt;</span><br><span class="line">&lt;/mirror&gt;</span><br></pre></td></tr></table></figure></div>

<p>2.编译源码里的pom.xml文件里的cloudera-repos的url去掉https的s</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;repositories&gt;</span><br><span class="line">  &lt;repository&gt;</span><br><span class="line">    &lt;id&gt;cloudera&lt;/id&gt;</span><br><span class="line">    &lt;name&gt;cloudera&lt;/name&gt;</span><br><span class="line">    &lt;url&gt;http://repository.cloudera.com/artifactory/cloudera-repos/&lt;/url&gt;</span><br><span class="line">  &lt;/repository&gt;</span><br><span class="line">&lt;/repositories&gt;</span><br></pre></td></tr></table></figure></div>

<p>  注意：idea开发的时候s是不去掉也ok(好像去不去掉都ok 都可以打开url提供的页面)</p>
<p>  3.由于网络问题有些 .pom、.jar下载不完整，决解办法：去maven本地仓库先删掉对应文件，然后wget 文件的url。</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">扩展小知识：</span><br><span class="line">	   org/apache/avro/avro-parent/1.7.6-cdh5.15.1</span><br><span class="line">	   对应maven的坐标是：g：a：v</span><br><span class="line">	   即：org.apache.avro  ： avro-parent ： 1.7.6-cdh5.15.1</span><br></pre></td></tr></table></figure></div>

<h2 id="2-大数据的理解"><a href="#2-大数据的理解" class="headerlink" title="2.大数据的理解"></a>2.大数据的理解</h2><p>1.存储  （HDFS、Hive、HBase、Kudu）<br>2.计算   (Hive、sql、Spark、Flink)<br>3.资源作业调度 （Yarn）<br>这三个方面，个人认为 存储是最重要的，存储涉及到：同步设计、小文件、监控等。如果存储做的不好，计算写的天花乱坠也是没有用的。</p>
<h2 id="3-HDFS-HA-amp-伪分布式"><a href="#3-HDFS-HA-amp-伪分布式" class="headerlink" title="3.HDFS HA &amp; 伪分布式"></a>3.HDFS HA &amp; 伪分布式</h2><p>对比较伪分布式再来引出HDFS的HA：</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">伪分布式：进程</span><br><span class="line">   HDFS：namenode、snn、dn</span><br><span class="line">   Yarn：rm、nm</span><br></pre></td></tr></table></figure></div>

<p>  企业里用的绝对是HDFS的HA，伪分布式的snn无法做到实时checkpoint，snn只是一个冷备。<br>  那么企业是是需要是一个热备，做实时备份的：</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nn节点挂掉，就不能提供对外服务，所以需要两个nn (active、standby)，任何时候只有1台 active的nn对外</span><br><span class="line">另一台是standby 做实时的备份(热备) ，随时准备有standby--&gt;active的状态，对外提供服务。外界是无感知的。</span><br></pre></td></tr></table></figure></div>

<p>扩展小知识：</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">`客户端是通过什么同时对接两个nn呢？===》命名空间  （在配置文件里的）</span><br><span class="line">命名空间：挂载着nn1、nn2，client读写操作就可以通过命名空间操作。</span><br></pre></td></tr></table></figure></div>

<h2 id="4-HDFS-HA-机器进程（emmm以三台开发机为例）"><a href="#4-HDFS-HA-机器进程（emmm以三台开发机为例）" class="headerlink" title="4.HDFS HA 机器进程（emmm以三台开发机为例）"></a>4.HDFS HA 机器进程（emmm以三台开发机为例）</h2><p>首先去hadoop.apache.org官网查看，配置HA有两种QJM、NFS(类似百度网盘，百度一下nfs概念就明白了)，国内大部分是用QJM做HA的。下面的HA也是使用QJM做讲解。</p>
<p>1.HDFS HA 三台机器的进程</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">doublehappy001:  ZK  NN   zkfc(zookeeperFailoverControl)     jn(JournalNode)              DN </span><br><span class="line">doublehappy002:  ZK  NN   zkfc			                     jn                           DN</span><br><span class="line">doublehappy003:  ZK                                          jn                           DN</span><br></pre></td></tr></table></figure></div>

<p>jn：日志节点 记录请求的记录</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">企业里：</span><br><span class="line">		zk最好单独机器部署，不要和其他的进程放在一块，由于企业某些压力 进程放在一块可能（会造成）造成nn挂掉之后</span><br><span class="line">		standby的nn切换active的时候切换不了。</span><br><span class="line">		zk不是越多越好，多了选举的时候会相应慢。</span><br></pre></td></tr></table></figure></div>
<p>经验：</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">jn: &gt;=3台 2n+1</span><br><span class="line">zk: 2n+1  投票选举</span><br><span class="line">zk的台数设置：</span><br><span class="line">    &lt;=20节点 : 5台  </span><br><span class="line">    20~100节点: 7/9/11台</span><br><span class="line">     &gt;100节点: 11台</span><br></pre></td></tr></table></figure></div>


<p> 2.Yarn HA 三台机器的进程    </p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">doublehappy001: ZK        NN          zkfc(zookeeperFailoverControl)        jn(JournalNode)  DN    RM   NM</span><br><span class="line">doublehappy002: ZK        NN          zkfc			                        jn               DN    RM   NM</span><br><span class="line">doublehappy003: ZK                                                          jn               DN         NM</span><br></pre></td></tr></table></figure></div>

<p>Yarn HA它没有用jn   ，这是HDFS HA &amp; Yarn HA 的所有进程</p>
<p>扩展小知识：</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">主从架构 master --》slave </span><br><span class="line">    1.DN NM部署在同一个机器上  为了数据本地化  （spark那块，就是数据本地计算，不用经过网路传输到别的机器去算） </span><br><span class="line">    2.大数据生态圈 大部分组件都是主从架构  </span><br><span class="line">    hbase组件 master regionserver  （这块注意hbase读写流程  一般的主从架构读写是要访问master的 而HBase不访问master）</span><br></pre></td></tr></table></figure></div>



<h2 id="5-HDFS-HA架构图"><a href="#5-HDFS-HA架构图" class="headerlink" title="5.HDFS HA架构图"></a>5.HDFS HA架构图</h2><p>HA使用active NN, standby NN两个节点解决单点问题。两个NN节点通过JN集群，共享状态，通过ZKFC选举active，监控状态，自动备援DN会同时向两个NN节点发送心跳。</p>
<p>扩展小知识：</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">双写</span><br><span class="line">     生产上案例：</span><br><span class="line">       1.结果双写</span><br><span class="line">           spark--&gt;hbase（所有的） + es（对外 2个月数据 ttl）</span><br><span class="line">       2. 数据同步双写  </span><br><span class="line">           A线(延迟了 半小时) B线(没有延迟 )   电商节假日 （开启ab线，如果只开a线，在重要节日数据激增情况下数据会延迟）</span><br></pre></td></tr></table></figure></div>

<p><img src="https://img-blog.csdnimg.cn/2019081812380949.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTU1NzUxMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190818123826419.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTU1NzUxMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>active nn：</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">接收client的rpc请求并处理，同时自己editlog写一份，也向JN的共享存储上的editlog写一份。</span><br><span class="line">也同时接收DN的block report，block location updates 和 heartbeat</span><br></pre></td></tr></table></figure></div>

<p>standby nn:</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">同样会接受到从JN的editlog上读取并执行这些log操作，使自己的NN的元数据和activenn的元数据是同步的，</span><br><span class="line">所以说standby是active nn的一个热备。一旦切换为active状态，就能够立即马上对外提供NN角色的服务。</span><br><span class="line">也同时接收DN的block report，block location updates 和 heartbeat</span><br></pre></td></tr></table></figure></div>

<p>jn：</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用于active nn,standby nn的同步数据，本身由一组的JN节点组成的集群，奇数，3台(CDH)，是支持Paxos协议。</span><br><span class="line">保证高可用。</span><br></pre></td></tr></table></figure></div>

<p>ZKFC：</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">监控NN的健康状态</span><br><span class="line">向ZK集群定期发送心跳  ，让自己被选举，当自己被ZK选举为主时，zkfc进程通过rpc调用让nn转换为active状态</span><br></pre></td></tr></table></figure></div>

<p><img src="https://img-blog.csdnimg.cn/20190818124420729.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTU1NzUxMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="6-Yarn-HA架构图"><a href="#6-Yarn-HA架构图" class="headerlink" title="6.Yarn HA架构图"></a>6.Yarn HA架构图</h2><p><img src="https://img-blog.csdnimg.cn/20190818124348795.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTU1NzUxMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>RM:</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a.启动时会通过向ZK的/hadoop-ha目录写一个lock文件，写成功则为active，否则standby。</span><br><span class="line">  standby RM会一直监控lock文件的是否存在，如果不存在就会尝试去创建，争取为active rm。</span><br><span class="line">b.会接收客户端的任务请求，接收和监控nm的资源的汇报，负责资源的分配与调度，启动和监控 ApplicationMaster（AM）</span><br></pre></td></tr></table></figure></div>

<p>NM:</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">节点上的资源的管理，启动container 容器 运行task的计算，上报资源，container情况汇报给RM和任务的处理情况汇报给 </span><br><span class="line">ApplicationMaster（AM）</span><br></pre></td></tr></table></figure></div>

<p>ApplicationMaster（AM）driver : </p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nm机器上的container</span><br><span class="line">单个application(job)的task的管理和调度，并向rm进行资源的申请，</span><br><span class="line">向nm发出 launch container指令，接收NM的task的处理状态信息。</span><br></pre></td></tr></table></figure></div>

<p>RMstatestore:</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a.RM的作业信息存储在ZK的/rmstore下，active RM向这个目录写app信息</span><br><span class="line">b.当active rm挂了，另外一个standby rm成功转换为active rm后，会从/rmstore目录读取相应的作业信息，</span><br><span class="line">重新构建作业的内存信息。然后启动内部服务，开始接收NM的心跳，构建集群资源的信息，并接收客户端的提交作业的请求等。</span><br></pre></td></tr></table></figure></div>

<p>ZKFC:</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">自动故障转移 只作为RM进程的一个线程  而非独立的守护进程来启动</span><br></pre></td></tr></table></figure></div>

<h2 id="7-HDFS-amp-Yarn-HA架构区别"><a href="#7-HDFS-amp-Yarn-HA架构区别" class="headerlink" title="7.HDFS &amp;Yarn HA架构区别"></a>7.HDFS &amp;Yarn HA架构区别</h2><p>ZKFC：</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">   Yarn：只作为RM进程的一个线程，而非独立的守护进程来启动</span><br><span class="line">HDFS：作为一个进程来启动</span><br></pre></td></tr></table></figure></div>

<p>从节点心跳接收：</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Yarn: 只有active的rm接受nm的心跳 standby不接受nm的心跳。</span><br><span class="line">HDFS：active和standby 都接受dn心跳</span><br></pre></td></tr></table></figure></div>

<p>active-&gt;standby切换：</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Yarn：</span><br><span class="line">     当active rm挂了，另外一个standby rm成功转换为active rm后，会从/rmstore目录读取相应的作业信息，</span><br><span class="line">     重新构建作业的内存信息。然后启动内部服务，开始接收NM的心跳，构建集群资源的信息，并接收客户端的提交作业的请求。</span><br><span class="line"></span><br><span class="line">HDFS：</span><br><span class="line">    active nn 自己写editlog写一份，也向JN的共享存储上的editlog写一份，standby nn 同样会接受到从JN的editlog上</span><br><span class="line">    读取并执行这些log操作，使自己的NN的元数据和activenn的元数据是同步的，所以说standby是active nn的一个热备。</span><br><span class="line">    一旦切换为active状态，就能够立即马上对外提供NN角色的服务。</span><br></pre></td></tr></table></figure></div>
<p>总结：</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Yarn是active挂了之后去RMstatestore读取作业信息</span><br><span class="line">HDFS是standby实时的去JN上读取editlog 使自己的NN的元数据和activenn的元数据是同步的。</span><br></pre></td></tr></table></figure></div>

<p>体现出HDFS比Yarn的HA重要性，也体现出 存储比计算重要。</p>

      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-JVM02" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/15/JVM02/">JVM02</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2017/11/15/JVM02/" class="article-date">
  <time datetime="2017-11-14T17:07:06.000Z" itemprop="datePublished">2017-11-15</time>
</a>
    
    
  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <h2 id="运行时数据区的各个异常"><a href="#运行时数据区的各个异常" class="headerlink" title="运行时数据区的各个异常"></a>运行时数据区的各个异常</h2><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">运行时数据区 ：是一个规范 </span><br><span class="line"> 	那么规范的东西和落地的东西 会有差距的 </span><br><span class="line"> 	对于同一个规范来讲 不同的实现也是有差别的</span><br><span class="line"> </span><br><span class="line"> 内存结构就是一个实现  不同版本的jdk是不一样的  </span><br><span class="line"></span><br><span class="line">JVM内存结构：</span><br><span class="line">	堆区：包括   Young(S0 S1 Eden)新生代  和 Old（）老年代      通常讲的 GC 是针对 堆区的</span><br><span class="line">	非堆区 :Metaspace    ccs   CodeCache</span><br><span class="line"></span><br><span class="line">	Metaspace   是不占用jvm的堆的空间的 它是占本地操作系统的内存的    所以GC是针对 堆区的</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">谈谈你遇到过的常见的[JVM相关]的异常信息？</span><br><span class="line"></span><br><span class="line">	首先 Hadoop、Spark、Flink都是跑在JVM之上的 所以你要结合他们进行回答</span><br><span class="line"></span><br><span class="line">ok下面进行举例：</span><br></pre></td></tr></table></figure></div>
<p><strong>Java Virtual Machine Stacks</strong><br>The following exceptional conditions are associated with Java Virtual Machine stacks:</p>
<p>If the computation in a thread requires a larger Java Virtual Machine stack than is permitted, the Java Virtual Machine throws a StackOverflowError.</p>
<p>If Java Virtual Machine stacks can be dynamically expanded, and expansion is attempted but insufficient memory can be made available to effect the expansion, or if insufficient memory can be made available to create the initial Java Virtual Machine stack for a new thread, the Java Virtual Machine throws an OutOfMemoryError.</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">StackOverflowError：</span><br><span class="line">	主要是针对 栈来说的  那么栈主要用来干嘛的呢？ 上一篇介绍了  记住一句话  “堆管存储  栈管执行”</span><br><span class="line">	什么情况下回产生 StackOverflowError？没有出口的一个递归</span><br><span class="line"></span><br><span class="line">eg：</span><br><span class="line"></span><br><span class="line">public class StackOverflowErrorApp &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        </span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public  static  void  test()&#123;</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">	Exception in thread &quot;main&quot; java.lang.StackOverflowError</span><br><span class="line">	at com.app.java.jvm.StackOverflowError.test(StackOverflowError.java:11)</span><br><span class="line">	at com.app.java.jvm.StackOverflowError.test(StackOverflowError.java:11)</span><br><span class="line">	at com.app.java.jvm.StackOverflowError.test(StackOverflowError.java:11)</span><br><span class="line"></span><br><span class="line">那么问你什么场景会出现 栈溢出  肯定是不小心 写了个递归没有出口的方法 </span><br><span class="line"></span><br><span class="line">那么什么极限下 会报这个异常 ？ 也就是 默认这个栈大小是多少呢？</span><br><span class="line">	Stack 大小 ：？</span><br><span class="line">	使用jvm底层的命令 可以查看这个东西  一会演示 </span><br><span class="line"></span><br><span class="line">那么StackOverflowError 是一个error  它和exeception有什么区别呀 ？</span><br><span class="line">	java里的try catch 捕获的是exeception</span><br><span class="line">	那么要捕获error  需要类extends Throwable  可以捕获error</span><br></pre></td></tr></table></figure></div>
<p>Heap</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"> “堆管存储  栈管执行”   </span><br><span class="line">堆的oom：说明堆里面放了好多存储 干不掉的</span><br><span class="line"></span><br><span class="line">public class JavaHeapSpaceApp &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String word = &quot;double happy&quot;;</span><br><span class="line"></span><br><span class="line">        while (true) &#123;</span><br><span class="line">            word +=word +new Random().nextInt(10000);  //这个 +  会产生新的对象</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">	at java.util.Arrays.copyOf(Arrays.java:3332)</span><br><span class="line">	at java.lang.AbstractStringBuilder.ensureCapacityInternal(AbstractStringBuilder.java:124)</span><br><span class="line">	at java.lang.AbstractStringBuilder.append(AbstractStringBuilder.java:674)</span><br><span class="line">	at java.lang.StringBuilder.append(StringBuilder.java:208)</span><br><span class="line">	at com.app.java.jvm.JavaHeapSpaceApp.main(JavaHeapSpaceApp.java:11)</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">	oom 是有很多种的  这种是  Java heap space   指的是 heap 存对象 被干爆了 </span><br><span class="line">	这个不好理解的话 我再写一个 </span><br><span class="line"></span><br><span class="line">public class JavaHeapSpaceApp &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        //目的是 在分配new byte 这个对象的时候 给他丢一个非常大的东西进去  </span><br><span class="line">        //如果丢的东西 很小的话 内存干不爆   为了测试起见  加一个参数 </span><br><span class="line">        // -Xms10m -Xmx10m</span><br><span class="line">        byte[] bytes = new byte[100 * 1024 * 1024];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">怎么把这个参数设置进去 看下图</span><br><span class="line">结果是：</span><br><span class="line">	Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">	at com.app.java.jvm.JavaHeapSpaceApp.main(JavaHeapSpaceApp.java:12)</span><br><span class="line"></span><br><span class="line">堆的大小只有10m   想一个问题哈？heap大小只有10m  在Heap里的对象是 100m 所以报异常</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191106112010458.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">java jdk里面有三类参数：</span><br><span class="line">	1.标准参数   了解</span><br><span class="line">			就是 jdk各个版本之间没有很大的变化的   eg：java -version  </span><br><span class="line">				[double_happy@hadoop101 ~]$ java -version      </span><br><span class="line">				java version &quot;1.8.0_45&quot;</span><br><span class="line">				Java(TM) SE Runtime Environment (build 1.8.0_45-b14)</span><br><span class="line">				Java HotSpot(TM) 64-Bit Server VM (build 25.45-b02, mixed mode)</span><br><span class="line">	2.X参数   了解</span><br><span class="line">			各个版本变化也很小 </span><br><span class="line">				[double_happy@hadoop101 ~]$ java -Xint -version    解释执行的 不会把java代码转化为本地代码的</span><br><span class="line">				java version &quot;1.8.0_45&quot;</span><br><span class="line">				Java(TM) SE Runtime Environment (build 1.8.0_45-b14)</span><br><span class="line">				Java HotSpot(TM) 64-Bit Server VM (build 25.45-b02, interpreted mode)   </span><br><span class="line">				[double_happy@hadoop101 ~]$ java -Xcomp -version      第一次使用的时候会编译成本地的代码 后面基于前面使用</span><br><span class="line">				java version &quot;1.8.0_45&quot;</span><br><span class="line">				Java(TM) SE Runtime Environment (build 1.8.0_45-b14)</span><br><span class="line">				Java HotSpot(TM) 64-Bit Server VM (build 25.45-b02, compiled mode)</span><br><span class="line">				[double_happy@hadoop101 ~]$ </span><br><span class="line"> </span><br><span class="line">	3.XX参数    重点*****</span><br><span class="line">		主要用来：</span><br><span class="line">			JVM调优、DEBUG 把我们JVM 打出来 </span><br><span class="line">			分为两大类：</span><br><span class="line">				1.Boolean类型   yes or no </span><br><span class="line">						公式 ： -XX:[+/-] &lt;name&gt;  </span><br><span class="line">						+什么意思？表示启用一个禁用</span><br><span class="line">						-表示禁用</span><br><span class="line">				2.非Boolean类型   是kv类型的 可以设置值</span><br><span class="line">						公式：-XX:&lt;name&gt;=&lt;value&gt;</span><br></pre></td></tr></table></figure></div>
<p><strong>1.Boolean类型</strong> </p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">public class XXAPP &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;double happy..&quot;);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(Integer.MAX_VALUE);  //让他一直运行</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">看一下本地：</span><br><span class="line"></span><br><span class="line">C:\Users\Administrator&gt;jps</span><br><span class="line">10212 Launcher</span><br><span class="line">1972</span><br><span class="line">7764 NailgunRunner</span><br><span class="line">2296 RemoteMavenServer</span><br><span class="line">6764 Jps</span><br><span class="line"></span><br><span class="line">C:\Users\Administrator&gt;jps</span><br><span class="line">1984 Launcher</span><br><span class="line">1972</span><br><span class="line">7764 NailgunRunner</span><br><span class="line">2296 RemoteMavenServer</span><br><span class="line">4604 XXAPP</span><br><span class="line">8348 Jps</span><br><span class="line"></span><br><span class="line">C:\Users\Administrator&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">	多了一个 4604 XXAPP</span><br><span class="line"></span><br><span class="line">C:\Users\Administrator&gt;jps</span><br><span class="line">10212 Launcher</span><br><span class="line">1972</span><br><span class="line">7764 NailgunRunner</span><br><span class="line">2296 RemoteMavenServer</span><br><span class="line">6764 Jps</span><br><span class="line">C:\Users\Administrator&gt;jps</span><br><span class="line">1984 Launcher</span><br><span class="line">1972</span><br><span class="line">7764 NailgunRunner</span><br><span class="line">2296 RemoteMavenServer</span><br><span class="line">4604 XXAPP</span><br><span class="line">8348 Jps</span><br><span class="line"></span><br><span class="line">C:\Users\Administrator&gt;jinfo -flag PrintGCDetails 4604</span><br><span class="line">-XX:-PrintGCDetails</span><br><span class="line"></span><br><span class="line">C:\Users\Administrator&gt;</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">这个就是 -XX:[+/-] &lt;name&gt;     </span><br><span class="line">-XX:-PrintGCDetails  表示 我现在这个应用程序并没有开启 PrintGCDetails  </span><br><span class="line"></span><br><span class="line">那么我们开启一下</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191106114044224.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20191106114316275.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ok 看一下 上面程序用的是 </span><br><span class="line">	哪一种GC?</span><br><span class="line">下图表示 没有</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191106114514772.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>2.非Boolean类型</strong> </p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">先查看 metaspace 大小</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191106114945176.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这就是 非Boolean类型的  </span><br><span class="line">那么修改一下</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191106115145528.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2019110611522081.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们再看一个</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191106115347320.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">15 表示 一个对象年纪多大了  </span><br><span class="line">我们修改一下     就是可以设置对象的年龄</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191106115611127.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">代码直接报错：</span><br><span class="line">	Error: Could not create the Java Virtual Machine.</span><br><span class="line">	Error: A fatal exception has occurred. Program will exit.</span><br><span class="line">	MaxTenuringThreshold of 20 is invalid; must be between 0 and 15    *** 可能面试会问的</span><br><span class="line"></span><br><span class="line">那我们改为10</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191106115820789.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ok  会使用了吧 </span><br><span class="line"></span><br><span class="line">但是 公式里的 name 哪里来的呢？</span><br><span class="line">		一会儿写</span><br><span class="line"></span><br><span class="line">-XX:+PrintFlagsInitial      //初始化的时候    查看初始默认值</span><br><span class="line">-XX:+PrintFlagsFinal      // 查看修改后的值</span><br><span class="line">-XX:+PrintCommandLineFlags     // 打印命令行参数</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[double_happy@hadoop101 ~]$ java -XX:+PrintFlagsFinal -version &gt;&gt; flags.txt</span><br><span class="line"></span><br><span class="line">more  flags.txt</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191106120651263.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1.初始化的 堆的大小</span><br><span class="line">[double_happy@hadoop101 ~]$ more flags.txt | grep InitialHeapSize</span><br><span class="line">    uintx InitialHeapSize                          := 125829120                           &#123;product&#125;</span><br><span class="line">[double_happy@hadoop101 ~]$</span><br><span class="line"></span><br><span class="line">2.看看有没有使用 G1GC</span><br><span class="line">[double_happy@hadoop101 ~]$ more flags.txt | grep UseG1GC</span><br><span class="line">     bool UseG1GC                                   = false                               &#123;product&#125;</span><br><span class="line">[double_happy@hadoop101 ~]$ </span><br><span class="line"></span><br><span class="line">3. </span><br><span class="line">	-Xms10m    ：它是 -XX参数     它是简写    -XX:InitialHeapSize</span><br><span class="line">		表示Heap 初始化大小</span><br><span class="line">	 -Xmx10m             -XX:MaxHeapSize    基于java程序 我们很大程度上是要改写的  默认是不够的</span><br><span class="line">	 	表示heap最大的大小 </span><br><span class="line">[double_happy@hadoop101 ~]$ more flags.txt | grep MaxHeapSize </span><br><span class="line">    uintx MaxHeapSize                              := 1981808640                          &#123;product&#125;</span><br><span class="line">[double_happy@hadoop101 ~]$ </span><br><span class="line">这个值是怎么来的 为什么是 1981808640</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">[double_happy@hadoop101 ~]$ jps</span><br><span class="line">9168 Jps</span><br><span class="line">17088 QuorumPeerMain</span><br><span class="line">8484 DataNode</span><br><span class="line">23653 Kafka</span><br><span class="line">8902 NodeManager</span><br><span class="line">14999 AzkabanSingleServer</span><br><span class="line">631 Kafka</span><br><span class="line">8648 SecondaryNameNode</span><br><span class="line">25784 NameNode</span><br><span class="line">24862 Kafka</span><br><span class="line">8798 ResourceManager</span><br><span class="line">[double_happy@hadoop101 ~]$ jinfo -flag MaxHeapSize 14999</span><br><span class="line">-XX:MaxHeapSize=536870912</span><br><span class="line">[double_happy@hadoop101 ~]$ jinfo -flag MaxHeapSize 25784</span><br><span class="line">-XX:MaxHeapSize=1048576000</span><br><span class="line">[double_happy@hadoop101 ~]$ </span><br><span class="line"></span><br><span class="line">默认是这些  这些参数都是要调整的哈 </span><br><span class="line">Hadoop 最大的MaxHeapSize  在哪调呢？知道吗？ </span><br><span class="line"></span><br><span class="line">[double_happy@hadoop101 hadoop]$ cat hadoop-env.sh </span><br><span class="line"># Licensed to the Apache Software Foundation (ASF) under one</span><br><span class="line"># or more contributor license agreements.  See the NOTICE file</span><br><span class="line"># distributed with this work for additional information</span><br><span class="line"># regarding copyright ownership.  The ASF licenses this file</span><br><span class="line"># to you under the Apache License, Version 2.0 (the</span><br><span class="line"># &quot;License&quot;); you may not use this file except in compliance</span><br><span class="line"># with the License.  You may obtain a copy of the License at</span><br><span class="line">#</span><br><span class="line">#     http://www.apache.org/licenses/LICENSE-2.0</span><br><span class="line">#</span><br><span class="line"># Unless required by applicable law or agreed to in writing, software</span><br><span class="line"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span><br><span class="line"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="line"># See the License for the specific language governing permissions and</span><br><span class="line"># limitations under the License.</span><br><span class="line"></span><br><span class="line"># Set Hadoop-specific environment variables here.</span><br><span class="line"></span><br><span class="line"># The only required environment variable is JAVA_HOME.  All others are</span><br><span class="line"># optional.  When running a distributed configuration it is best to</span><br><span class="line"># set JAVA_HOME in this file, so that it is correctly defined on</span><br><span class="line"># remote nodes.</span><br><span class="line"></span><br><span class="line"># The java implementation to use.</span><br><span class="line">export JAVA_HOME=/usr/java/java</span><br><span class="line"></span><br><span class="line"># The jsvc implementation to use. Jsvc is required to run secure datanodes</span><br><span class="line"># that bind to privileged ports to provide authentication of data transfer</span><br><span class="line"># protocol.  Jsvc is not required if SASL is configured for authentication of</span><br><span class="line"># data transfer protocol using non-privileged ports.</span><br><span class="line">#export JSVC_HOME=$&#123;JSVC_HOME&#125;</span><br><span class="line"></span><br><span class="line">export HADOOP_CONF_DIR=$&#123;HADOOP_CONF_DIR:-&quot;/etc/hadoop&quot;&#125;</span><br><span class="line"></span><br><span class="line"># Extra Java CLASSPATH elements.  Automatically insert capacity-scheduler.</span><br><span class="line">for f in $HADOOP_HOME/contrib/capacity-scheduler/*.jar; do</span><br><span class="line">  if [ &quot;$HADOOP_CLASSPATH&quot; ]; then</span><br><span class="line">    export HADOOP_CLASSPATH=$HADOOP_CLASSPATH:$f</span><br><span class="line">  else</span><br><span class="line">    export HADOOP_CLASSPATH=$f</span><br><span class="line">  fi</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"># The maximum amount of heap to use, in MB. Default is 1000.</span><br><span class="line">#export HADOOP_HEAPSIZE=</span><br><span class="line">#export HADOOP_NAMENODE_INIT_HEAPSIZE=&quot;&quot;</span><br><span class="line"></span><br><span class="line"># Extra Java runtime options.  Empty by default.</span><br><span class="line">export HADOOP_OPTS=&quot;$HADOOP_OPTS -Djava.net.preferIPv4Stack=true&quot;</span><br><span class="line"></span><br><span class="line"># Command specific options appended to HADOOP_OPTS when specified</span><br><span class="line">export HADOOP_NAMENODE_OPTS=&quot;-Dhadoop.security.logger=$&#123;HADOOP_SECURITY_LOGGER:-INFO,RFAS&#125; -Dhdfs.audit.logger=$&#123;HDFS_AUDIT_LOGGER:-INFO,NullAppender&#125; $HADOOP_NAMENODE_OPTS&quot;</span><br><span class="line">export HADOOP_DATANODE_OPTS=&quot;-Dhadoop.security.logger=ERROR,RFAS $HADOOP_DATANODE_OPTS&quot;</span><br><span class="line"></span><br><span class="line">export HADOOP_SECONDARYNAMENODE_OPTS=&quot;-Dhadoop.security.logger=$&#123;HADOOP_SECURITY_LOGGER:-INFO,RFAS&#125; -Dhdfs.audit.logger=$&#123;HDFS_AUDIT_LOGGER:-INFO,NullAppender&#125; $HADOOP_SECONDARYNAMENODE_OPTS&quot;</span><br><span class="line"></span><br><span class="line">export HADOOP_NFS3_OPTS=&quot;$HADOOP_NFS3_OPTS&quot;</span><br><span class="line">export HADOOP_PORTMAP_OPTS=&quot;-Xmx512m $HADOOP_PORTMAP_OPTS&quot;</span><br><span class="line"></span><br><span class="line"># The following applies to multiple commands (fs, dfs, fsck, distcp etc)</span><br><span class="line">export HADOOP_CLIENT_OPTS=&quot;-Xmx512m $HADOOP_CLIENT_OPTS&quot;</span><br><span class="line">#HADOOP_JAVA_PLATFORM_OPTS=&quot;-XX:-UsePerfData $HADOOP_JAVA_PLATFORM_OPTS&quot;</span><br><span class="line"></span><br><span class="line"># On secure datanodes, user to run the datanode as after dropping privileges.</span><br><span class="line"># This **MUST** be uncommented to enable secure HDFS if using privileged ports</span><br><span class="line"># to provide authentication of data transfer protocol.  This **MUST NOT** be</span><br><span class="line"># defined if SASL is configured for authentication of data transfer protocol</span><br><span class="line"># using non-privileged ports.</span><br><span class="line">export HADOOP_SECURE_DN_USER=$&#123;HADOOP_SECURE_DN_USER&#125;</span><br><span class="line"></span><br><span class="line"># Where log files are stored.  $HADOOP_HOME/logs by default.</span><br><span class="line">#export HADOOP_LOG_DIR=$&#123;HADOOP_LOG_DIR&#125;/$USER</span><br><span class="line"></span><br><span class="line"># Where log files are stored in the secure data environment.</span><br><span class="line">export HADOOP_SECURE_DN_LOG_DIR=$&#123;HADOOP_LOG_DIR&#125;/$&#123;HADOOP_HDFS_USER&#125;</span><br><span class="line"></span><br><span class="line">###</span><br><span class="line"># HDFS Mover specific parameters</span><br><span class="line">###</span><br><span class="line"># Specify the JVM options to be used when starting the HDFS Mover.</span><br><span class="line"># These options will be appended to the options specified as HADOOP_OPTS</span><br><span class="line"># and therefore may override any similar flags set in HADOOP_OPTS</span><br><span class="line">#</span><br><span class="line"># export HADOOP_MOVER_OPTS=&quot;&quot;</span><br><span class="line"></span><br><span class="line">###</span><br><span class="line"># Advanced Users Only!</span><br><span class="line">###</span><br><span class="line"></span><br><span class="line"># The directory where pid files are stored. /tmp by default.</span><br><span class="line"># NOTE: this should be set to a directory that can only be written to by </span><br><span class="line">#       the user that will run the hadoop daemons.  Otherwise there is the</span><br><span class="line">#       potential for a symlink attack.</span><br><span class="line">export HADOOP_PID_DIR=$&#123;HADOOP_PID_DIR&#125;</span><br><span class="line">export HADOOP_SECURE_DN_PID_DIR=$&#123;HADOOP_PID_DIR&#125;</span><br><span class="line"></span><br><span class="line"># A string representing this instance of hadoop. $USER by default.</span><br><span class="line">export HADOOP_IDENT_STRING=$USER</span><br><span class="line">[double_happy@hadoop101 hadoop]$ </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">	#export HADOOP_HEAPSIZE=</span><br><span class="line">	export HADOOP_PORTMAP_OPTS=&quot;-Xmx512m $HADOOP_PORTMAP_OPTS&quot;  </span><br><span class="line">	都是有的   eg：-Xmx</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">4.stack 大小</span><br><span class="line">[double_happy@hadoop101 ~]$ more flags.txt | grep ThreadStackSize</span><br><span class="line">     intx CompilerThreadStackSize                   = 0                                   &#123;pd product&#125;</span><br><span class="line">     intx ThreadStackSize                           = 1024                                &#123;pd product&#125;</span><br><span class="line">     intx VMThreadStackSize                         = 1024                                &#123;pd product&#125;</span><br><span class="line">[double_happy@hadoop101 ~]$ </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[double_happy@hadoop101 ~]$ jps</span><br><span class="line">17088 QuorumPeerMain</span><br><span class="line">8484 DataNode</span><br><span class="line">23653 Kafka</span><br><span class="line">8902 NodeManager</span><br><span class="line">14999 AzkabanSingleServer</span><br><span class="line">631 Kafka</span><br><span class="line">9416 Jps</span><br><span class="line">8648 SecondaryNameNode</span><br><span class="line">25784 NameNode</span><br><span class="line">24862 Kafka</span><br><span class="line">8798 ResourceManager</span><br><span class="line">[double_happy@hadoop101 ~]$ jinfo -flag ThreadStackSize 25784    </span><br><span class="line">-XX:ThreadStackSize=1024</span><br><span class="line">[double_happy@hadoop101 ~]$ </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">jinfo使用：</span><br><span class="line">[double_happy@hadoop101 ~]$ jinfo</span><br><span class="line">Usage:</span><br><span class="line">    jinfo [option] &lt;pid&gt;</span><br><span class="line">        (to connect to running process)</span><br><span class="line">    jinfo [option] &lt;executable &lt;core&gt;</span><br><span class="line">        (to connect to a core file)</span><br><span class="line">    jinfo [option] [server_id@]&lt;remote server IP or hostname&gt;</span><br><span class="line">        (to connect to remote debug server)</span><br><span class="line"></span><br><span class="line">where &lt;option&gt; is one of:</span><br><span class="line">    -flag &lt;name&gt;         to print the value of the named VM flag</span><br><span class="line">    -flag [+|-]&lt;name&gt;    to enable or disable the named VM flag</span><br><span class="line">    -flag &lt;name&gt;=&lt;value&gt; to set the named VM flag to the given value</span><br><span class="line">    -flags               to print VM flags</span><br><span class="line">    -sysprops            to print Java system properties</span><br><span class="line">    &lt;no option&gt;          to print both of the above</span><br><span class="line">    -h | -help           to print this help message</span><br><span class="line">[double_happy@hadoop101 ~]$ </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">5.-Xss      -XX:ThreadStackSize         </span><br><span class="line">	表示线程栈的大小       单位是 kb     4，5是一个东西  一般这个值 521-1024之间 </span><br><span class="line">6.-Xmn   年轻代大小</span><br></pre></td></tr></table></figure></div>
<p><strong>继续异常：</strong></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.lang.outofMemoryError:GC overhea  limit exceeded</span><br><span class="line"></span><br><span class="line">日志：</span><br><span class="line">	PSYongGen:2048k-&gt;502k(2560k)   指的是  502表示没有被GC的数据</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191106130146847.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20191106130508586.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Full GC  1023-&gt;1023 表示已经干不掉了 </span><br><span class="line"></span><br><span class="line">注意：GC是连续GC</span><br><span class="line">就是发现 到最后 已经没有办法进行GC了 所以抛出异常</span><br><span class="line"></span><br><span class="line">为什么没有办法进行GC呢 ？</span><br><span class="line">	首先 到达一定的阈值 它想去GC 默认值是98%   就是超过了这个阈值 它回收不掉 也就发生了 想去回收 但是发现又GC不了</span><br><span class="line">	所以遇到GC overhea  limit exceeded 错 十有八九你的代码是有问题的 或者参数不够</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2. 先看一个类 nio </span><br><span class="line">非堆区 那块</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191106131313188.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">allocate这个方法  分配JVM内存</span><br><span class="line">allocateDirect     分配本地内存     到底本地内存占多少呢？一般情况下 我们开发不要使用这种的  上一篇文章写了 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">写一个类：</span><br><span class="line">public class DirectBufferMemoryApp &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println((sun.misc.VM.maxDirectMemory())/(double)1024/1024);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果是：</span><br><span class="line">	7264 </span><br><span class="line">7264 与本地的操作系统有很大关系的   是 本地内存大概的的 1/4   我电脑是32g的</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191106132705417.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">结果：</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Direct buffer memory</span><br><span class="line">	at java.nio.Bits.reserveMemory(Bits.java:694)</span><br><span class="line">	at java.nio.DirectByteBuffer.&lt;init&gt;(DirectByteBuffer.java:123)</span><br><span class="line">	at java.nio.ByteBuffer.allocateDirect(ByteBuffer.java:311)</span><br><span class="line">	at com.app.java.jvm.DirectBufferMemoryApp.main(DirectBufferMemoryApp.java:11)</span><br><span class="line"></span><br><span class="line">Direct buffer memory 指的是 你调用的api 直接分配的内存  已经超过了 我们本地操作系统能用的 </span><br><span class="line"></span><br><span class="line">这可不是堆里面的  而是堆外的哦</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">3.</span><br><span class="line">public class UnableCreateNewThreadApp &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        </span><br><span class="line">        for (int i=1 ;;i++) &#123;</span><br><span class="line">            System.out.println(&quot;------&quot;+i);</span><br><span class="line">            </span><br><span class="line">            //搞一堆的线程</span><br><span class="line">            new Thread(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(Integer.MAX_VALUE);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,i+&quot;&quot;).start();</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">一个死循环 每一个循环 会启动一个线程   </span><br><span class="line">去linux上测试  如果在windows上测试 很可能 你懂得</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">------3419</span><br><span class="line">------3420</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: unable to create new native thread</span><br><span class="line">        at java.lang.Thread.start0(Native Method)</span><br><span class="line">        at java.lang.Thread.start(Thread.java:714)</span><br><span class="line">        at UnableCreateNewThreadApp.main(UnableCreateNewThreadApp.java:18)</span><br><span class="line"></span><br><span class="line">为了演示这个错误我Linux 电脑挂了    用root 把 那个进程kill 掉即可  不需要重启</span><br><span class="line"></span><br><span class="line"> unable to create new native thread：</span><br><span class="line"> 	为什么呢？是线程太多了 </span><br><span class="line">到底有多少个线程呢？</span><br><span class="line">		4096 个线程数 </span><br><span class="line">	[double_happy@hadoop101 jvm]$ ulimit -u              </span><br><span class="line">	4096</span><br><span class="line">	[double_happy@hadoop101 jvm]$ 	</span><br><span class="line"></span><br><span class="line">为什么3420 挂了呢  因为 我机器还有别的线程呀 </span><br><span class="line"></span><br><span class="line">修改线程数即可</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">4.</span><br><span class="line">java.lang.outofmemoryError:Metaspace</span><br><span class="line"></span><br><span class="line">Metaspace里面存的是放了类的属性等</span><br></pre></td></tr></table></figure></div>
      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-JVM01" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/15/JVM01/">JVM01</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2017/11/15/JVM01/" class="article-date">
  <time datetime="2017-11-14T17:02:06.000Z" itemprop="datePublished">2017-11-15</time>
</a>
    
    
  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <p><strong>运行时数据区</strong><br><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5" target="_blank" rel="noopener">官网</a><br>2.5. Run-Time Data Areas<br>The Java Virtual Machine defines various run-time data areas that are used during execution of a program. Some of these <strong>data areas</strong> <strong>are created on Java Virtual Machine start-up and are destroyed only when the Java Virtual Machine exits.</strong> <strong>Other data areas are per thread.</strong> Per-thread data areas are created when a thread is created and destroyed when the thread exits.</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1.data areas 有生命周期的 jvm启动的时候被创建 jvm退出的时候被销毁</span><br><span class="line">2.有些data areas是线程独有的      当线程创建的时候被创建 线程退出的时候被销毁</span><br><span class="line"></span><br><span class="line">总结：	</span><br><span class="line">1）JVM创建时创建，退出时销毁</span><br><span class="line">2）每个Thread独有，Thread创建时创建，Thread退出时销毁</span><br><span class="line">	==&gt; 有一些区是共享，有一些区是独享    从线程的角度</span><br><span class="line"></span><br><span class="line">运行时数据区有哪些呢？</span><br><span class="line">运行时数据区</span><br><span class="line">	1） The pc Register        程序计数器</span><br><span class="line">	2） Java Virtual Machine Stacks</span><br><span class="line">	3） Heap          </span><br><span class="line">	4） Method Area                   方法区</span><br><span class="line">	5） Run-Time Constant Pool      这个一般是在方法区里面的</span><br><span class="line">	6） Native Method Stacks</span><br><span class="line"></span><br><span class="line">每一个区做什么事情 下面依次讲解</span><br></pre></td></tr></table></figure></div>
<p><strong>1.The pc Register        程序计数器</strong></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">The pc Register  程序计数器</span><br><span class="line">	1.占用一小块的内存       (指的是占用运行时数据区总的内存 毕竟他是在运行时数据区的内部的)</span><br><span class="line">	2.作用：当前线程所执行的字节码的行号指示器</span><br><span class="line">		什么意思呢？</span><br><span class="line">			在java里可能是以单线程的方式运行的 也有可能以多线程的方式运行的 那么问题来了</span><br><span class="line">			比如说 多线程的方式  你这个线程的在跑 此时另外一个线程它拿到了cpu的执行权 它开始执行的时候</span><br><span class="line">			那么前一个线程肯定会停下来  就是优先级高的调度到的 先执行。等它运行完了再抢占。这个时候如果前面的线程回来了</span><br><span class="line">			问题是 回来的这个线程从什么地方开始执行 它知道吗？这就是当前线程所执行的字节码都是有一个的行号指示器的</span><br><span class="line">			意思就是说 它会从字节码里的某一个行号开始往下继续执行</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">什么是字节码？</span><br><span class="line">	 eg：</span><br><span class="line">[double_happy@hadoop101 jvm]$ cat Hello.java </span><br><span class="line">public class Hello&#123;</span><br><span class="line">        public static void  main(String[] args)&#123;</span><br><span class="line">                System.out.println(&quot;hello..&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">[double_happy@hadoop101 jvm]$ </span><br><span class="line"></span><br><span class="line">Hello.java 这个东西对于jvm来说不知道是什么东西 这仅仅是我们开发的应用程序java源代码而已 系统是不能识别的</span><br><span class="line">系统识别的是class文件  所以需要把Hello.java文件编译成class文件</span><br><span class="line"></span><br><span class="line">[double_happy@hadoop101 jvm]$ javac Hello.java </span><br><span class="line">[double_happy@hadoop101 jvm]$ ll</span><br><span class="line">total 8</span><br><span class="line">-rw-rw-r-- 1 double_happy double_happy 411 Nov  5 19:18 Hello.class</span><br><span class="line">-rw-rw-r-- 1 double_happy double_happy 100 Nov  5 19:18 Hello.java</span><br><span class="line">[double_happy@hadoop101 jvm]$ rm -rf Hello.class </span><br><span class="line">[double_happy@hadoop101 jvm]$ java Hello</span><br><span class="line">Error: Could not find or load main class Hello</span><br><span class="line">[double_happy@hadoop101 jvm]$ javac Hello.java </span><br><span class="line">[double_happy@hadoop101 jvm]$ java Hello</span><br><span class="line">hello..</span><br><span class="line">[double_happy@hadoop101 jvm]$</span><br><span class="line"></span><br><span class="line">Hello.class 是一个class字节码文件  可以通过命令查看他的字节码</span><br><span class="line"></span><br><span class="line">[double_happy@hadoop101 jvm]$ javap -verbose Hello.class &gt;&gt; Hello.txt</span><br><span class="line">[double_happy@hadoop101 jvm]$ cat Hello.txt </span><br><span class="line">Classfile /home/double_happy/script/jvm/Hello.class</span><br><span class="line">  Last modified Nov 5, 2019; size 411 bytes</span><br><span class="line">  MD5 checksum 6f1c4345f8677c12ec8d3eb12da54cda</span><br><span class="line">  Compiled from &quot;Hello.java&quot;</span><br><span class="line">public class Hello         //下面就是他的字节码文件</span><br><span class="line">  minor version: 0         //jdk版本</span><br><span class="line">  major version: 52      ////jdk版本     </span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #6.#15         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Fieldref           #16.#17        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #3 = String             #18            // hello..</span><br><span class="line">   #4 = Methodref          #19.#20        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">   #5 = Class              #21            // Hello</span><br><span class="line">   #6 = Class              #22            // java/lang/Object</span><br><span class="line">   #7 = Utf8               &lt;init&gt;</span><br><span class="line">   #8 = Utf8               ()V</span><br><span class="line">   #9 = Utf8               Code</span><br><span class="line">  #10 = Utf8               LineNumberTable</span><br><span class="line">  #11 = Utf8               main</span><br><span class="line">  #12 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #13 = Utf8               SourceFile</span><br><span class="line">  #14 = Utf8               Hello.java</span><br><span class="line">  #15 = NameAndType        #7:#8          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #16 = Class              #23            // java/lang/System</span><br><span class="line">  #17 = NameAndType        #24:#25        // out:Ljava/io/PrintStream;</span><br><span class="line">  #18 = Utf8               hello..</span><br><span class="line">  #19 = Class              #26            // java/io/PrintStream</span><br><span class="line">  #20 = NameAndType        #27:#28        // println:(Ljava/lang/String;)V</span><br><span class="line">  #21 = Utf8               Hello</span><br><span class="line">  #22 = Utf8               java/lang/Object</span><br><span class="line">  #23 = Utf8               java/lang/System</span><br><span class="line">  #24 = Utf8               out</span><br><span class="line">  #25 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #26 = Utf8               java/io/PrintStream</span><br><span class="line">  #27 = Utf8               println</span><br><span class="line">  #28 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">&#123;</span><br><span class="line">  public Hello();     //自带空的构造器 </span><br><span class="line">    descriptor: ()V     </span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0     //字节码的指令</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:      //行号   在程序或者线程的执行过程当中 它就能知道我这次运行到字节码里面的多少行 </span><br><span class="line">        line 1: 0</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=1, args_size=1</span><br><span class="line">         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: ldc           #3                  // String hello..</span><br><span class="line">         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">         8: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 3: 0</span><br><span class="line">        line 4: 8</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;Hello.java&quot;</span><br><span class="line">[double_happy@hadoop101 jvm]$</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">字节码</span><br><span class="line">	 aload_0    字节码指令   </span><br><span class="line">	  我们的应用程序最后拿到的是一堆的机器的指令  jvm就可以通过我们这些指令 它就知道你开发的应用程序想做一个什么事情 </span><br><span class="line">	  (java 代码一定会被编译成字节码 不同的字节码 干不同的事情）就是这一步.java =&gt;.class </span><br><span class="line"></span><br><span class="line">那么字节码和 程序计数器有什么关系呢？</span><br><span class="line">程序计数器：</span><br><span class="line">	记录当前线程目前执行到你的代码所对应的哪一条字节码指令</span><br><span class="line"></span><br><span class="line">多线程的情况下执行你的代码？</span><br><span class="line">	可能是多个线程并发的执行   那么多个线程共同执行的时候 就有可能出现</span><br><span class="line">	你每一个线程当前运行到的字节码指令行数是不一样的      多线程就是cpu抢占的问题</span><br><span class="line">	也就是说：每个线程都有自己的程序计数器      </span><br><span class="line">		专门用来记录我们所执行的这个线程现在到了哪一步了 </span><br><span class="line"></span><br><span class="line">所以：**</span><br><span class="line">程序计数器   属于  运行时数据区  的第二类       即  每个Thread独有</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191105194645327.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>2） Java Virtual Machine Stacks</strong></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Hello &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Hello hello = new Hello(); </span><br><span class="line">        hello.hello();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public  void hello()&#123;</span><br><span class="line">        String name = &quot;double_happy&quot;;   //局部变量     它的生命周期是在 这个hello函数里面的 </span><br><span class="line">        System.out.println(&quot;Hello: &quot; + name);  </span><br><span class="line">                </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">在main方法里面调用hello这个方法  我们在执行的过程当中 一定是有一个线程在 执行这段代码 去调用hello这个方法</span><br><span class="line"></span><br><span class="line">这里来说是 main这个线程  执行main方法里面的代码   </span><br><span class="line">那么对于 局部变量来说 它到时候会存在 jvm 数据运行区 的哪一个部分呢？</span><br><span class="line"></span><br><span class="line">存在Java Virtual Machine Stacks   jvm的一个栈</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Each Java Virtual Machine thread has a private Java Virtual Machine stack, created at the same time as the thread</span><br><span class="line">A Java Virtual Machine stack stores frames </span><br><span class="line"></span><br><span class="line">Java Virtual Machine Stacks  </span><br><span class="line">	1.方法里面的一些局部变量......   它就是存在 frames里的 </span><br><span class="line">	2.存的是frames: 栈帧</span><br><span class="line">	A new frame is created each time a method is invoked. 方法调用的时候被创建</span><br><span class="line">		对于上面的代码来说  main方法被调用 会创建一个 frame  hello方法被调用 也会创建一个  frame </span><br><span class="line">	A frame is destroyed when its method invocation completes  方法执行完毕的时候被销毁</span><br><span class="line">		</span><br><span class="line">	栈的特性 ：先进后出 </span><br><span class="line">	栈：main==&gt;hello    入栈：就是方法被调用的时候   出栈 ： 方法执行完毕的时候</span><br><span class="line">	可能会抛出的异常：StackOverflowError</span><br><span class="line">		这个很好理解 我们这些区 都是属于jvm运行时的区 每个区肯定都是有大小的 </span><br><span class="line">		你的线程计算时需要的大小 比我们 Java Virtual Machine Stacks   大 会抛出StackOverflowError 这个异常</span><br><span class="line">	</span><br><span class="line">	调用方法时，会为每个方法创建Frame，入栈</span><br><span class="line">	方法执行完毕后，Frame出栈</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191105202251465.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>3.Heap  堆</strong> ****重点</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">The Java Virtual Machine has a heap that is shared among all Java Virtual Machine threads</span><br><span class="line">所有线程共享的一块区域</span><br><span class="line"></span><br><span class="line">Heap ：</span><br><span class="line">	创建对象  是存在Heap里面的</span><br><span class="line">	可能会抛出的异常：OutOfMemoryError</span><br><span class="line">		什么场景下？你new出来的一些东西 最终放在heap里  比你默认的heap的大小大 </span><br><span class="line"></span><br><span class="line">eg：</span><br><span class="line">public class Hello &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Hello hello = new Hello();</span><br><span class="line">        hello.hello();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public  void hello()&#123;</span><br><span class="line">        String name = &quot;double_happy&quot;;</span><br><span class="line">        System.out.println(&quot;Hello: &quot; + name);</span><br><span class="line"></span><br><span class="line">        BasketballPlayer player = new BasketballPlayer(&quot;波兰名宿&quot;);</span><br><span class="line">        player.xxx();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class BasketballPlayer&#123;</span><br><span class="line">    String name;</span><br><span class="line">    </span><br><span class="line">    public BasketballPlayer()&#123;&#125;</span><br><span class="line">    public BasketballPlayer(String name)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;  </span><br><span class="line">    public void xxx()&#123;</span><br><span class="line">        System.out.println(name + &quot;发边线球....&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">在我们的hello方法里面 new 了一个对象  它是在堆里面的</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191105204643975.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>4.Method Area/Metaspace</strong> 方法区</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">The Java Virtual Machine has a method area that is shared among all Java Virtual Machine threads.</span><br><span class="line">所有线程共享的一块区域   1.8之后叫做 Metaspace</span><br><span class="line"></span><br><span class="line">Method Area/Metaspace里面存的是：</span><br><span class="line">	constant pool, 常量池</span><br><span class="line">	field and method data,  属性和方法数据</span><br><span class="line">	and the code for methods and constructors   方法代码和构造器代码</span><br><span class="line">	就是：</span><br><span class="line">		class文件加载进来放这里</span><br><span class="line">	可能会抛出的异常：OutOfMemoryError</span><br><span class="line">    什么场景下发生呢？</span><br></pre></td></tr></table></figure></div>
<p><strong>5.Native Method Stacks</strong>本地方法栈</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Native Method Stacks</span><br><span class="line">	native修饰的方法 是调用本地操作系统里面的方法 c语言或者 一些底层类库等等</span><br><span class="line">	可能会抛出的异常：StackOverflowError/OutOfMemoryError</span><br><span class="line"></span><br><span class="line">那么在调用 native修饰的方法 的时候 每个线程就会创建一个 本地方法栈</span><br><span class="line"></span><br><span class="line">所以方法分为两种：</span><br><span class="line">	native的      放在Native Method Stacks</span><br><span class="line">	非native的   放在 Java Virtual Machine Stacks</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191105210739239.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">还有一个区：是干嘛的呢？</span><br><span class="line">	Area: 不属于JVM   </span><br><span class="line">		eg： 通过nio 直接创建一些内存   就是堆外内存  这块是直接操作内存空间的 性能方面是好的 （Spark里面是有的  得调整堆外内存的空间的）</span><br><span class="line">			但是 如果不节制 会有可能会出现什么场景呢？</span><br><span class="line">			你大量的去这么干肯定是不行的  建议 你如果 去调用底层源码是可以的  自己的代码直接操作堆外内存是不合适的</span><br></pre></td></tr></table></figure></div>
<p><strong>总结</strong><br><img src="https://img-blog.csdnimg.cn/20191105213916315.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line">        String s1 = new String(&quot;double happy&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">问这句话产生了几个对象？</span><br><span class="line">	2个：哪两个呢？</span><br><span class="line">		1.s1   局部变量 存的是对象的地址  在stack里 </span><br><span class="line">		2.  new String     在Heap 里面  </span><br><span class="line">		3.  方法区里面的常量池 存一个对象 叫 double happy </span><br><span class="line"></span><br><span class="line">测试：</span><br><span class="line">	    public static void main(String[] args) &#123;</span><br><span class="line">        String s1 = new String(&quot;double happy&quot;);</span><br><span class="line">        String s2 = &quot;double happy&quot;;</span><br><span class="line"></span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">结果是false </span><br><span class="line">	因为s1 指向heap 里的 new String</span><br><span class="line">	s2 指向的method area 里的常量池里的 double happy</span><br><span class="line"></span><br><span class="line">测试：</span><br><span class="line">	    public static void main(String[] args) &#123;</span><br><span class="line">        String s1 = new String(&quot;double happy&quot;);</span><br><span class="line">        String s2 = &quot;double happy&quot;;</span><br><span class="line"></span><br><span class="line">        System.out.println(s1 == s2); //比较的是 引用地址</span><br><span class="line">        System.out.println(s1.equals(s2));// equals 比较的是内容</span><br><span class="line">    &#125;</span><br><span class="line">  结果是：</span><br><span class="line">  	false</span><br><span class="line">  	true</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191105215809121.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String s1 = &quot;双喜&quot;;</span><br><span class="line">        String s2 = &quot;男的&quot;;</span><br><span class="line">        String s3 = &quot;双喜&quot; + &quot;男的&quot;;</span><br><span class="line">        String s4 = s1 + s2;</span><br><span class="line">        String s5 = &quot;双喜男的&quot;;</span><br><span class="line">       String s6 = s4.intern();</span><br><span class="line">        System.out.println(s3 == s4); </span><br><span class="line">        System.out.println(s3 == s5);</span><br><span class="line">        System.out.println(s4 == s5);</span><br><span class="line">          System.out.println(s3 == s6);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">结果是：</span><br><span class="line">false</span><br><span class="line">true</span><br><span class="line">false</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191105220642702.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Returns a canonical representation for the string object.</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * A pool of strings, initially empty, is maintained privately by the</span><br><span class="line">     * class &#123;@code String&#125;.</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * When the intern method is invoked, if the pool already contains a</span><br><span class="line">     * string equal to this &#123;@code String&#125; object as determined by</span><br><span class="line">     * the &#123;@link #equals(Object)&#125; method, then the string from the pool is</span><br><span class="line">     * returned. Otherwise, this &#123;@code String&#125; object is added to the</span><br><span class="line">     * pool and a reference to this &#123;@code String&#125; object is returned.</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * It follows that for any two strings &#123;@code s&#125; and &#123;@code t&#125;,</span><br><span class="line">     * &#123;@code s.intern() == t.intern()&#125; is &#123;@code true&#125;</span><br><span class="line">     * if and only if &#123;@code s.equals(t)&#125; is &#123;@code true&#125;.</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * All literal strings and string-valued constant expressions are</span><br><span class="line">     * interned. String literals are defined in section 3.10.5 of the</span><br><span class="line">     * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.</span><br><span class="line">     *</span><br><span class="line">     * @return  a string that has the same contents as this string, but is</span><br><span class="line">     *          guaranteed to be from a pool of unique strings.</span><br><span class="line">     */</span><br><span class="line">    public native String intern();</span><br><span class="line">所以  intern  返回 string object. 真实的值 </span><br><span class="line">所以s6 指向的是 常量池里面的东西 </span><br><span class="line"></span><br><span class="line"> if and only if &#123;@code s.equals(t)&#125; is &#123;@code true&#125;.</span><br><span class="line"> 就是 equals相等  intern  就相等</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191105221230853.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">比较特殊：</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">   </span><br><span class="line">        Integer i1 = 50;</span><br><span class="line">        Integer i2 = 50;</span><br><span class="line"></span><br><span class="line">        System.out.println(i1 == i2);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">这个东西按常理来讲是 不等的对吧  包装类 一般是new 出来的 </span><br><span class="line">这是相等的</span><br><span class="line">先这样 </span><br><span class="line">	Integer i1 = new Integer(50);</span><br><span class="line">    Integer i2 = new Integer(50);</span><br><span class="line">这两个相等么？</span><br><span class="line">	false</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">对于基本类型 包装类型 都是放在 常量池里的 new出来的肯定不是放在池子里的哈 </span><br><span class="line"></span><br><span class="line">那么：</span><br><span class="line">	        Integer i1 = 150;</span><br><span class="line">            Integer i2 = 150;</span><br><span class="line">         相等么？  不等的</span><br><span class="line">         因为 池子里面 是有一个范围的   基本类型 包装类型都有</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns an &#123;@code Integer&#125; instance representing the specified</span><br><span class="line">     * &#123;@code int&#125; value.  If a new &#123;@code Integer&#125; instance is not</span><br><span class="line">     * required, this method should generally be used in preference to</span><br><span class="line">     * the constructor &#123;@link #Integer(int)&#125;, as this method is likely</span><br><span class="line">     * to yield significantly better space and time performance by</span><br><span class="line">     * caching frequently requested values.</span><br><span class="line">     *</span><br><span class="line">     * This method will always cache values in the range -128 to 127,</span><br><span class="line">     * inclusive, and may cache other values outside of this range.</span><br><span class="line">     *</span><br><span class="line">     * @param  i an &#123;@code int&#125; value.</span><br><span class="line">     * @return an &#123;@code Integer&#125; instance representing &#123;@code i&#125;.</span><br><span class="line">     * @since  1.5</span><br><span class="line">     */</span><br><span class="line">    public static Integer valueOf(int i) &#123;</span><br><span class="line">        if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">            return IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">        return new Integer(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line"> IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high  </span><br><span class="line">low = -128</span><br><span class="line">int h = 127</span><br><span class="line"></span><br><span class="line">明白了吧 </span><br><span class="line"></span><br><span class="line">但是 </span><br><span class="line">        Double d1 = 10.0D;</span><br><span class="line">        Double d2 = 10.0D;</span><br><span class="line">看源码你就知道了 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	    public static Double valueOf(double d) &#123;</span><br><span class="line">        return new Double(d);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">底层是 new   所以是不等的 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">所以 源码面前了无密码  源码用到的时候  还是要看的</span><br></pre></td></tr></table></figure></div>

      
    </div>
    
  </div>
  
  
</article>

  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/4/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span>
  </nav>


</section>
        <aside id="sidebar">
  
    <div class="widget-box">
  <div class="avatar-box">
    <img class="avatar" src="/images/default-avatar.jpg" title="图片来自网络"></img>
    <h3 class="avatar-name">
      
        DoubleHappy
      
    </h3>
    <p class="avatar-slogan">
      特别耐撕的大数据，资深的打酱油攻城狮。
    </p>
  </div>
</div>


  
    

  
    

  
    
  
    
  <div class="widget-box">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li></ul>
    </div>
  </div>

  
    
  <div class="widget-box">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/01/05/Kudu-Impala%E6%95%85%E9%9A%9C%E6%A1%88%E4%BE%8B01-double-happy/">Kudu+Impala故障案例01--double_happy</a>
          </li>
        
          <li>
            <a href="/2020/01/05/Flink04-double-happy/">Flink04--double_happy</a>
          </li>
        
          <li>
            <a href="/2020/01/05/Flink03-double-happy/">Flink03--double_happy</a>
          </li>
        
          <li>
            <a href="/2020/01/05/Flink02-double-happy/">Flink02--double_happy</a>
          </li>
        
          <li>
            <a href="/2020/01/05/Flink01-double-happy/">Flink01-double_happy</a>
          </li>
        
      </ul>
    </div>
  </div>

  
      <div class="widget-box">
    <h3 class="widget-title">友链</h3>
    <div class="widget">
      
        <a style="display: block;" href="https://liverrrr.fun/archives" title target='_blank'
        >一路眼瞎</a>
      
    </div>
  </div>

  
</aside>
      </div>
      <footer id="footer">
  <div class="foot-box global-width">
    &copy; 2020 DoubleHappy &nbsp;&nbsp;
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    &nbsp;|&nbsp;主题 <a href="https://github.com/yiluyanxia/hexo-theme-antiquity" target="_blank" rel="noopener">antiquity</a>
    <br>
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span id="busuanzi_container_site_pv">不蒜子告之   阁下是第<span id="busuanzi_value_site_pv"></span>个访客</span>
  </div>
</footer>
      <script src="https://code.jquery.com/jquery-2.0.3.min.js"></script>
<script>
if (!window.jQuery) {
var script = document.createElement('script');
script.src = "/js/jquery-2.0.3.min.js";
document.body.write(script);
}
</script>


<script src="/js/script.js"></script>



    </div>
    <nav id="mobile-nav" class="mobile-nav-box">
  <div class="mobile-nav-img mobile-nav-top"></div>
  
    <a href="/archives" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
  <div class="mobile-nav-img  mobile-nav-bottom"></div>
</nav>    
  </div>
</body>
</html>