<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;page&#x2F;5&#x2F;index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/images/default-avatar.jpg">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/css/highlight.css">
</head>

<body>
  <div id="fullpage" class="mobile-nav-right">
    
      <div id="wrapper" title="图片来自网络">
    
    
      <header id="header">
  <div id="nav-toggle" class="nav-toggle"></div>
  <div class="head-box global-width">
    <nav class="nav-box nav-right">
      
        <a class="nav-item" href="/" title
        
        >首页</a>
      
        <a class="nav-item" href="/archives" title
        
        >归档</a>
      
    </nav>
  </div>
</header>
      <div id="middlecontent" title class="global-width sidebar-right">
        <section id="main">
  
    <article id="post-HDFS-Yarn-HA" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/17/HDFS-Yarn-HA/">HDFS&amp;Yarn HA</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2017/11/17/HDFS-Yarn-HA/" class="article-date">
  <time datetime="2017-11-17T11:33:40.000Z" itemprop="datePublished">2017-11-17</time>
</a>
    
    
  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <h1 id="1-Hadoop编译"><a href="#1-Hadoop编译" class="headerlink" title="1.Hadoop编译"></a>1.Hadoop编译</h1><p>总结一下在开发机上编译源码的小问题：<br>1.maven的setting.xml的配置</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;mirror&gt;</span><br><span class="line">     &lt;id&gt;nexus-aliyun&lt;/id&gt;</span><br><span class="line">     &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;</span><br><span class="line">     &lt;name&gt;Nexus aliyun&lt;/name&gt;</span><br><span class="line">     &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;</span><br><span class="line">&lt;/mirror&gt;</span><br><span class="line">&lt;mirror&gt;</span><br><span class="line">     &lt;id&gt;cloudera&lt;/id&gt;</span><br><span class="line">     &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;</span><br><span class="line">     &lt;name&gt;cloudera&lt;/name&gt;</span><br><span class="line">     &lt;url&gt;https://repository.cloudera.com/artifactory/cloudera-repos/&lt;/url&gt;</span><br><span class="line">&lt;/mirror&gt;</span><br></pre></td></tr></table></figure></div>

<p>2.编译源码里的pom.xml文件里的cloudera-repos的url去掉https的s</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;repositories&gt;</span><br><span class="line">  &lt;repository&gt;</span><br><span class="line">    &lt;id&gt;cloudera&lt;/id&gt;</span><br><span class="line">    &lt;name&gt;cloudera&lt;/name&gt;</span><br><span class="line">    &lt;url&gt;http://repository.cloudera.com/artifactory/cloudera-repos/&lt;/url&gt;</span><br><span class="line">  &lt;/repository&gt;</span><br><span class="line">&lt;/repositories&gt;</span><br></pre></td></tr></table></figure></div>

<p>  注意：idea开发的时候s是不去掉也ok(好像去不去掉都ok 都可以打开url提供的页面)</p>
<p>  3.由于网络问题有些 .pom、.jar下载不完整，决解办法：去maven本地仓库先删掉对应文件，然后wget 文件的url。</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">扩展小知识：</span><br><span class="line">	   org/apache/avro/avro-parent/1.7.6-cdh5.15.1</span><br><span class="line">	   对应maven的坐标是：g：a：v</span><br><span class="line">	   即：org.apache.avro  ： avro-parent ： 1.7.6-cdh5.15.1</span><br></pre></td></tr></table></figure></div>

<h2 id="2-大数据的理解"><a href="#2-大数据的理解" class="headerlink" title="2.大数据的理解"></a>2.大数据的理解</h2><p>1.存储  （HDFS、Hive、HBase、Kudu）<br>2.计算   (Hive、sql、Spark、Flink)<br>3.资源作业调度 （Yarn）<br>这三个方面，个人认为 存储是最重要的，存储涉及到：同步设计、小文件、监控等。如果存储做的不好，计算写的天花乱坠也是没有用的。</p>
<h2 id="3-HDFS-HA-amp-伪分布式"><a href="#3-HDFS-HA-amp-伪分布式" class="headerlink" title="3.HDFS HA &amp; 伪分布式"></a>3.HDFS HA &amp; 伪分布式</h2><p>对比较伪分布式再来引出HDFS的HA：</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">伪分布式：进程</span><br><span class="line">   HDFS：namenode、snn、dn</span><br><span class="line">   Yarn：rm、nm</span><br></pre></td></tr></table></figure></div>

<p>  企业里用的绝对是HDFS的HA，伪分布式的snn无法做到实时checkpoint，snn只是一个冷备。<br>  那么企业是是需要是一个热备，做实时备份的：</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nn节点挂掉，就不能提供对外服务，所以需要两个nn (active、standby)，任何时候只有1台 active的nn对外</span><br><span class="line">另一台是standby 做实时的备份(热备) ，随时准备有standby--&gt;active的状态，对外提供服务。外界是无感知的。</span><br></pre></td></tr></table></figure></div>

<p>扩展小知识：</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">`客户端是通过什么同时对接两个nn呢？===》命名空间  （在配置文件里的）</span><br><span class="line">命名空间：挂载着nn1、nn2，client读写操作就可以通过命名空间操作。</span><br></pre></td></tr></table></figure></div>

<h2 id="4-HDFS-HA-机器进程（emmm以三台开发机为例）"><a href="#4-HDFS-HA-机器进程（emmm以三台开发机为例）" class="headerlink" title="4.HDFS HA 机器进程（emmm以三台开发机为例）"></a>4.HDFS HA 机器进程（emmm以三台开发机为例）</h2><p>首先去hadoop.apache.org官网查看，配置HA有两种QJM、NFS(类似百度网盘，百度一下nfs概念就明白了)，国内大部分是用QJM做HA的。下面的HA也是使用QJM做讲解。</p>
<p>1.HDFS HA 三台机器的进程</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">doublehappy001:  ZK  NN   zkfc(zookeeperFailoverControl)     jn(JournalNode)              DN </span><br><span class="line">doublehappy002:  ZK  NN   zkfc			                     jn                           DN</span><br><span class="line">doublehappy003:  ZK                                          jn                           DN</span><br></pre></td></tr></table></figure></div>

<p>jn：日志节点 记录请求的记录</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">企业里：</span><br><span class="line">		zk最好单独机器部署，不要和其他的进程放在一块，由于企业某些压力 进程放在一块可能（会造成）造成nn挂掉之后</span><br><span class="line">		standby的nn切换active的时候切换不了。</span><br><span class="line">		zk不是越多越好，多了选举的时候会相应慢。</span><br></pre></td></tr></table></figure></div>
<p>经验：</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">jn: &gt;=3台 2n+1</span><br><span class="line">zk: 2n+1  投票选举</span><br><span class="line">zk的台数设置：</span><br><span class="line">    &lt;=20节点 : 5台  </span><br><span class="line">    20~100节点: 7/9/11台</span><br><span class="line">     &gt;100节点: 11台</span><br></pre></td></tr></table></figure></div>


<p> 2.Yarn HA 三台机器的进程    </p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">doublehappy001: ZK        NN          zkfc(zookeeperFailoverControl)        jn(JournalNode)  DN    RM   NM</span><br><span class="line">doublehappy002: ZK        NN          zkfc			                        jn               DN    RM   NM</span><br><span class="line">doublehappy003: ZK                                                          jn               DN         NM</span><br></pre></td></tr></table></figure></div>

<p>Yarn HA它没有用jn   ，这是HDFS HA &amp; Yarn HA 的所有进程</p>
<p>扩展小知识：</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">主从架构 master --》slave </span><br><span class="line">    1.DN NM部署在同一个机器上  为了数据本地化  （spark那块，就是数据本地计算，不用经过网路传输到别的机器去算） </span><br><span class="line">    2.大数据生态圈 大部分组件都是主从架构  </span><br><span class="line">    hbase组件 master regionserver  （这块注意hbase读写流程  一般的主从架构读写是要访问master的 而HBase不访问master）</span><br></pre></td></tr></table></figure></div>



<h2 id="5-HDFS-HA架构图"><a href="#5-HDFS-HA架构图" class="headerlink" title="5.HDFS HA架构图"></a>5.HDFS HA架构图</h2><p>HA使用active NN, standby NN两个节点解决单点问题。两个NN节点通过JN集群，共享状态，通过ZKFC选举active，监控状态，自动备援DN会同时向两个NN节点发送心跳。</p>
<p>扩展小知识：</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">双写</span><br><span class="line">     生产上案例：</span><br><span class="line">       1.结果双写</span><br><span class="line">           spark--&gt;hbase（所有的） + es（对外 2个月数据 ttl）</span><br><span class="line">       2. 数据同步双写  </span><br><span class="line">           A线(延迟了 半小时) B线(没有延迟 )   电商节假日 （开启ab线，如果只开a线，在重要节日数据激增情况下数据会延迟）</span><br></pre></td></tr></table></figure></div>

<p><img src="https://img-blog.csdnimg.cn/2019081812380949.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTU1NzUxMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190818123826419.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTU1NzUxMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>active nn：</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">接收client的rpc请求并处理，同时自己editlog写一份，也向JN的共享存储上的editlog写一份。</span><br><span class="line">也同时接收DN的block report，block location updates 和 heartbeat</span><br></pre></td></tr></table></figure></div>

<p>standby nn:</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">同样会接受到从JN的editlog上读取并执行这些log操作，使自己的NN的元数据和activenn的元数据是同步的，</span><br><span class="line">所以说standby是active nn的一个热备。一旦切换为active状态，就能够立即马上对外提供NN角色的服务。</span><br><span class="line">也同时接收DN的block report，block location updates 和 heartbeat</span><br></pre></td></tr></table></figure></div>

<p>jn：</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用于active nn,standby nn的同步数据，本身由一组的JN节点组成的集群，奇数，3台(CDH)，是支持Paxos协议。</span><br><span class="line">保证高可用。</span><br></pre></td></tr></table></figure></div>

<p>ZKFC：</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">监控NN的健康状态</span><br><span class="line">向ZK集群定期发送心跳  ，让自己被选举，当自己被ZK选举为主时，zkfc进程通过rpc调用让nn转换为active状态</span><br></pre></td></tr></table></figure></div>

<p><img src="https://img-blog.csdnimg.cn/20190818124420729.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTU1NzUxMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="6-Yarn-HA架构图"><a href="#6-Yarn-HA架构图" class="headerlink" title="6.Yarn HA架构图"></a>6.Yarn HA架构图</h2><p><img src="https://img-blog.csdnimg.cn/20190818124348795.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTU1NzUxMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>RM:</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a.启动时会通过向ZK的/hadoop-ha目录写一个lock文件，写成功则为active，否则standby。</span><br><span class="line">  standby RM会一直监控lock文件的是否存在，如果不存在就会尝试去创建，争取为active rm。</span><br><span class="line">b.会接收客户端的任务请求，接收和监控nm的资源的汇报，负责资源的分配与调度，启动和监控 ApplicationMaster（AM）</span><br></pre></td></tr></table></figure></div>

<p>NM:</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">节点上的资源的管理，启动container 容器 运行task的计算，上报资源，container情况汇报给RM和任务的处理情况汇报给 </span><br><span class="line">ApplicationMaster（AM）</span><br></pre></td></tr></table></figure></div>

<p>ApplicationMaster（AM）driver : </p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nm机器上的container</span><br><span class="line">单个application(job)的task的管理和调度，并向rm进行资源的申请，</span><br><span class="line">向nm发出 launch container指令，接收NM的task的处理状态信息。</span><br></pre></td></tr></table></figure></div>

<p>RMstatestore:</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a.RM的作业信息存储在ZK的/rmstore下，active RM向这个目录写app信息</span><br><span class="line">b.当active rm挂了，另外一个standby rm成功转换为active rm后，会从/rmstore目录读取相应的作业信息，</span><br><span class="line">重新构建作业的内存信息。然后启动内部服务，开始接收NM的心跳，构建集群资源的信息，并接收客户端的提交作业的请求等。</span><br></pre></td></tr></table></figure></div>

<p>ZKFC:</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">自动故障转移 只作为RM进程的一个线程  而非独立的守护进程来启动</span><br></pre></td></tr></table></figure></div>

<h2 id="7-HDFS-amp-Yarn-HA架构区别"><a href="#7-HDFS-amp-Yarn-HA架构区别" class="headerlink" title="7.HDFS &amp;Yarn HA架构区别"></a>7.HDFS &amp;Yarn HA架构区别</h2><p>ZKFC：</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">   Yarn：只作为RM进程的一个线程，而非独立的守护进程来启动</span><br><span class="line">HDFS：作为一个进程来启动</span><br></pre></td></tr></table></figure></div>

<p>从节点心跳接收：</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Yarn: 只有active的rm接受nm的心跳 standby不接受nm的心跳。</span><br><span class="line">HDFS：active和standby 都接受dn心跳</span><br></pre></td></tr></table></figure></div>

<p>active-&gt;standby切换：</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Yarn：</span><br><span class="line">     当active rm挂了，另外一个standby rm成功转换为active rm后，会从/rmstore目录读取相应的作业信息，</span><br><span class="line">     重新构建作业的内存信息。然后启动内部服务，开始接收NM的心跳，构建集群资源的信息，并接收客户端的提交作业的请求。</span><br><span class="line"></span><br><span class="line">HDFS：</span><br><span class="line">    active nn 自己写editlog写一份，也向JN的共享存储上的editlog写一份，standby nn 同样会接受到从JN的editlog上</span><br><span class="line">    读取并执行这些log操作，使自己的NN的元数据和activenn的元数据是同步的，所以说standby是active nn的一个热备。</span><br><span class="line">    一旦切换为active状态，就能够立即马上对外提供NN角色的服务。</span><br></pre></td></tr></table></figure></div>
<p>总结：</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Yarn是active挂了之后去RMstatestore读取作业信息</span><br><span class="line">HDFS是standby实时的去JN上读取editlog 使自己的NN的元数据和activenn的元数据是同步的。</span><br></pre></td></tr></table></figure></div>

<p>体现出HDFS比Yarn的HA重要性，也体现出 存储比计算重要。</p>

      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-JVM02" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/15/JVM02/">JVM02</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2017/11/15/JVM02/" class="article-date">
  <time datetime="2017-11-14T17:07:06.000Z" itemprop="datePublished">2017-11-15</time>
</a>
    
    
  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <h2 id="运行时数据区的各个异常"><a href="#运行时数据区的各个异常" class="headerlink" title="运行时数据区的各个异常"></a>运行时数据区的各个异常</h2><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">运行时数据区 ：是一个规范 </span><br><span class="line"> 	那么规范的东西和落地的东西 会有差距的 </span><br><span class="line"> 	对于同一个规范来讲 不同的实现也是有差别的</span><br><span class="line"> </span><br><span class="line"> 内存结构就是一个实现  不同版本的jdk是不一样的  </span><br><span class="line"></span><br><span class="line">JVM内存结构：</span><br><span class="line">	堆区：包括   Young(S0 S1 Eden)新生代  和 Old（）老年代      通常讲的 GC 是针对 堆区的</span><br><span class="line">	非堆区 :Metaspace    ccs   CodeCache</span><br><span class="line"></span><br><span class="line">	Metaspace   是不占用jvm的堆的空间的 它是占本地操作系统的内存的    所以GC是针对 堆区的</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">谈谈你遇到过的常见的[JVM相关]的异常信息？</span><br><span class="line"></span><br><span class="line">	首先 Hadoop、Spark、Flink都是跑在JVM之上的 所以你要结合他们进行回答</span><br><span class="line"></span><br><span class="line">ok下面进行举例：</span><br></pre></td></tr></table></figure></div>
<p><strong>Java Virtual Machine Stacks</strong><br>The following exceptional conditions are associated with Java Virtual Machine stacks:</p>
<p>If the computation in a thread requires a larger Java Virtual Machine stack than is permitted, the Java Virtual Machine throws a StackOverflowError.</p>
<p>If Java Virtual Machine stacks can be dynamically expanded, and expansion is attempted but insufficient memory can be made available to effect the expansion, or if insufficient memory can be made available to create the initial Java Virtual Machine stack for a new thread, the Java Virtual Machine throws an OutOfMemoryError.</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">StackOverflowError：</span><br><span class="line">	主要是针对 栈来说的  那么栈主要用来干嘛的呢？ 上一篇介绍了  记住一句话  “堆管存储  栈管执行”</span><br><span class="line">	什么情况下回产生 StackOverflowError？没有出口的一个递归</span><br><span class="line"></span><br><span class="line">eg：</span><br><span class="line"></span><br><span class="line">public class StackOverflowErrorApp &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        </span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public  static  void  test()&#123;</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">	Exception in thread &quot;main&quot; java.lang.StackOverflowError</span><br><span class="line">	at com.app.java.jvm.StackOverflowError.test(StackOverflowError.java:11)</span><br><span class="line">	at com.app.java.jvm.StackOverflowError.test(StackOverflowError.java:11)</span><br><span class="line">	at com.app.java.jvm.StackOverflowError.test(StackOverflowError.java:11)</span><br><span class="line"></span><br><span class="line">那么问你什么场景会出现 栈溢出  肯定是不小心 写了个递归没有出口的方法 </span><br><span class="line"></span><br><span class="line">那么什么极限下 会报这个异常 ？ 也就是 默认这个栈大小是多少呢？</span><br><span class="line">	Stack 大小 ：？</span><br><span class="line">	使用jvm底层的命令 可以查看这个东西  一会演示 </span><br><span class="line"></span><br><span class="line">那么StackOverflowError 是一个error  它和exeception有什么区别呀 ？</span><br><span class="line">	java里的try catch 捕获的是exeception</span><br><span class="line">	那么要捕获error  需要类extends Throwable  可以捕获error</span><br></pre></td></tr></table></figure></div>
<p>Heap</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"> “堆管存储  栈管执行”   </span><br><span class="line">堆的oom：说明堆里面放了好多存储 干不掉的</span><br><span class="line"></span><br><span class="line">public class JavaHeapSpaceApp &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String word = &quot;double happy&quot;;</span><br><span class="line"></span><br><span class="line">        while (true) &#123;</span><br><span class="line">            word +=word +new Random().nextInt(10000);  //这个 +  会产生新的对象</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">	at java.util.Arrays.copyOf(Arrays.java:3332)</span><br><span class="line">	at java.lang.AbstractStringBuilder.ensureCapacityInternal(AbstractStringBuilder.java:124)</span><br><span class="line">	at java.lang.AbstractStringBuilder.append(AbstractStringBuilder.java:674)</span><br><span class="line">	at java.lang.StringBuilder.append(StringBuilder.java:208)</span><br><span class="line">	at com.app.java.jvm.JavaHeapSpaceApp.main(JavaHeapSpaceApp.java:11)</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">	oom 是有很多种的  这种是  Java heap space   指的是 heap 存对象 被干爆了 </span><br><span class="line">	这个不好理解的话 我再写一个 </span><br><span class="line"></span><br><span class="line">public class JavaHeapSpaceApp &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        //目的是 在分配new byte 这个对象的时候 给他丢一个非常大的东西进去  </span><br><span class="line">        //如果丢的东西 很小的话 内存干不爆   为了测试起见  加一个参数 </span><br><span class="line">        // -Xms10m -Xmx10m</span><br><span class="line">        byte[] bytes = new byte[100 * 1024 * 1024];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">怎么把这个参数设置进去 看下图</span><br><span class="line">结果是：</span><br><span class="line">	Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">	at com.app.java.jvm.JavaHeapSpaceApp.main(JavaHeapSpaceApp.java:12)</span><br><span class="line"></span><br><span class="line">堆的大小只有10m   想一个问题哈？heap大小只有10m  在Heap里的对象是 100m 所以报异常</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191106112010458.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">java jdk里面有三类参数：</span><br><span class="line">	1.标准参数   了解</span><br><span class="line">			就是 jdk各个版本之间没有很大的变化的   eg：java -version  </span><br><span class="line">				[double_happy@hadoop101 ~]$ java -version      </span><br><span class="line">				java version &quot;1.8.0_45&quot;</span><br><span class="line">				Java(TM) SE Runtime Environment (build 1.8.0_45-b14)</span><br><span class="line">				Java HotSpot(TM) 64-Bit Server VM (build 25.45-b02, mixed mode)</span><br><span class="line">	2.X参数   了解</span><br><span class="line">			各个版本变化也很小 </span><br><span class="line">				[double_happy@hadoop101 ~]$ java -Xint -version    解释执行的 不会把java代码转化为本地代码的</span><br><span class="line">				java version &quot;1.8.0_45&quot;</span><br><span class="line">				Java(TM) SE Runtime Environment (build 1.8.0_45-b14)</span><br><span class="line">				Java HotSpot(TM) 64-Bit Server VM (build 25.45-b02, interpreted mode)   </span><br><span class="line">				[double_happy@hadoop101 ~]$ java -Xcomp -version      第一次使用的时候会编译成本地的代码 后面基于前面使用</span><br><span class="line">				java version &quot;1.8.0_45&quot;</span><br><span class="line">				Java(TM) SE Runtime Environment (build 1.8.0_45-b14)</span><br><span class="line">				Java HotSpot(TM) 64-Bit Server VM (build 25.45-b02, compiled mode)</span><br><span class="line">				[double_happy@hadoop101 ~]$ </span><br><span class="line"> </span><br><span class="line">	3.XX参数    重点*****</span><br><span class="line">		主要用来：</span><br><span class="line">			JVM调优、DEBUG 把我们JVM 打出来 </span><br><span class="line">			分为两大类：</span><br><span class="line">				1.Boolean类型   yes or no </span><br><span class="line">						公式 ： -XX:[+/-] &lt;name&gt;  </span><br><span class="line">						+什么意思？表示启用一个禁用</span><br><span class="line">						-表示禁用</span><br><span class="line">				2.非Boolean类型   是kv类型的 可以设置值</span><br><span class="line">						公式：-XX:&lt;name&gt;=&lt;value&gt;</span><br></pre></td></tr></table></figure></div>
<p><strong>1.Boolean类型</strong> </p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">public class XXAPP &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;double happy..&quot;);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(Integer.MAX_VALUE);  //让他一直运行</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">看一下本地：</span><br><span class="line"></span><br><span class="line">C:\Users\Administrator&gt;jps</span><br><span class="line">10212 Launcher</span><br><span class="line">1972</span><br><span class="line">7764 NailgunRunner</span><br><span class="line">2296 RemoteMavenServer</span><br><span class="line">6764 Jps</span><br><span class="line"></span><br><span class="line">C:\Users\Administrator&gt;jps</span><br><span class="line">1984 Launcher</span><br><span class="line">1972</span><br><span class="line">7764 NailgunRunner</span><br><span class="line">2296 RemoteMavenServer</span><br><span class="line">4604 XXAPP</span><br><span class="line">8348 Jps</span><br><span class="line"></span><br><span class="line">C:\Users\Administrator&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">	多了一个 4604 XXAPP</span><br><span class="line"></span><br><span class="line">C:\Users\Administrator&gt;jps</span><br><span class="line">10212 Launcher</span><br><span class="line">1972</span><br><span class="line">7764 NailgunRunner</span><br><span class="line">2296 RemoteMavenServer</span><br><span class="line">6764 Jps</span><br><span class="line">C:\Users\Administrator&gt;jps</span><br><span class="line">1984 Launcher</span><br><span class="line">1972</span><br><span class="line">7764 NailgunRunner</span><br><span class="line">2296 RemoteMavenServer</span><br><span class="line">4604 XXAPP</span><br><span class="line">8348 Jps</span><br><span class="line"></span><br><span class="line">C:\Users\Administrator&gt;jinfo -flag PrintGCDetails 4604</span><br><span class="line">-XX:-PrintGCDetails</span><br><span class="line"></span><br><span class="line">C:\Users\Administrator&gt;</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">这个就是 -XX:[+/-] &lt;name&gt;     </span><br><span class="line">-XX:-PrintGCDetails  表示 我现在这个应用程序并没有开启 PrintGCDetails  </span><br><span class="line"></span><br><span class="line">那么我们开启一下</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191106114044224.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20191106114316275.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ok 看一下 上面程序用的是 </span><br><span class="line">	哪一种GC?</span><br><span class="line">下图表示 没有</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191106114514772.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>2.非Boolean类型</strong> </p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">先查看 metaspace 大小</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191106114945176.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这就是 非Boolean类型的  </span><br><span class="line">那么修改一下</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191106115145528.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2019110611522081.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们再看一个</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191106115347320.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">15 表示 一个对象年纪多大了  </span><br><span class="line">我们修改一下     就是可以设置对象的年龄</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191106115611127.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">代码直接报错：</span><br><span class="line">	Error: Could not create the Java Virtual Machine.</span><br><span class="line">	Error: A fatal exception has occurred. Program will exit.</span><br><span class="line">	MaxTenuringThreshold of 20 is invalid; must be between 0 and 15    *** 可能面试会问的</span><br><span class="line"></span><br><span class="line">那我们改为10</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191106115820789.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ok  会使用了吧 </span><br><span class="line"></span><br><span class="line">但是 公式里的 name 哪里来的呢？</span><br><span class="line">		一会儿写</span><br><span class="line"></span><br><span class="line">-XX:+PrintFlagsInitial      //初始化的时候    查看初始默认值</span><br><span class="line">-XX:+PrintFlagsFinal      // 查看修改后的值</span><br><span class="line">-XX:+PrintCommandLineFlags     // 打印命令行参数</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[double_happy@hadoop101 ~]$ java -XX:+PrintFlagsFinal -version &gt;&gt; flags.txt</span><br><span class="line"></span><br><span class="line">more  flags.txt</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191106120651263.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1.初始化的 堆的大小</span><br><span class="line">[double_happy@hadoop101 ~]$ more flags.txt | grep InitialHeapSize</span><br><span class="line">    uintx InitialHeapSize                          := 125829120                           &#123;product&#125;</span><br><span class="line">[double_happy@hadoop101 ~]$</span><br><span class="line"></span><br><span class="line">2.看看有没有使用 G1GC</span><br><span class="line">[double_happy@hadoop101 ~]$ more flags.txt | grep UseG1GC</span><br><span class="line">     bool UseG1GC                                   = false                               &#123;product&#125;</span><br><span class="line">[double_happy@hadoop101 ~]$ </span><br><span class="line"></span><br><span class="line">3. </span><br><span class="line">	-Xms10m    ：它是 -XX参数     它是简写    -XX:InitialHeapSize</span><br><span class="line">		表示Heap 初始化大小</span><br><span class="line">	 -Xmx10m             -XX:MaxHeapSize    基于java程序 我们很大程度上是要改写的  默认是不够的</span><br><span class="line">	 	表示heap最大的大小 </span><br><span class="line">[double_happy@hadoop101 ~]$ more flags.txt | grep MaxHeapSize </span><br><span class="line">    uintx MaxHeapSize                              := 1981808640                          &#123;product&#125;</span><br><span class="line">[double_happy@hadoop101 ~]$ </span><br><span class="line">这个值是怎么来的 为什么是 1981808640</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">[double_happy@hadoop101 ~]$ jps</span><br><span class="line">9168 Jps</span><br><span class="line">17088 QuorumPeerMain</span><br><span class="line">8484 DataNode</span><br><span class="line">23653 Kafka</span><br><span class="line">8902 NodeManager</span><br><span class="line">14999 AzkabanSingleServer</span><br><span class="line">631 Kafka</span><br><span class="line">8648 SecondaryNameNode</span><br><span class="line">25784 NameNode</span><br><span class="line">24862 Kafka</span><br><span class="line">8798 ResourceManager</span><br><span class="line">[double_happy@hadoop101 ~]$ jinfo -flag MaxHeapSize 14999</span><br><span class="line">-XX:MaxHeapSize=536870912</span><br><span class="line">[double_happy@hadoop101 ~]$ jinfo -flag MaxHeapSize 25784</span><br><span class="line">-XX:MaxHeapSize=1048576000</span><br><span class="line">[double_happy@hadoop101 ~]$ </span><br><span class="line"></span><br><span class="line">默认是这些  这些参数都是要调整的哈 </span><br><span class="line">Hadoop 最大的MaxHeapSize  在哪调呢？知道吗？ </span><br><span class="line"></span><br><span class="line">[double_happy@hadoop101 hadoop]$ cat hadoop-env.sh </span><br><span class="line"># Licensed to the Apache Software Foundation (ASF) under one</span><br><span class="line"># or more contributor license agreements.  See the NOTICE file</span><br><span class="line"># distributed with this work for additional information</span><br><span class="line"># regarding copyright ownership.  The ASF licenses this file</span><br><span class="line"># to you under the Apache License, Version 2.0 (the</span><br><span class="line"># &quot;License&quot;); you may not use this file except in compliance</span><br><span class="line"># with the License.  You may obtain a copy of the License at</span><br><span class="line">#</span><br><span class="line">#     http://www.apache.org/licenses/LICENSE-2.0</span><br><span class="line">#</span><br><span class="line"># Unless required by applicable law or agreed to in writing, software</span><br><span class="line"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span><br><span class="line"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="line"># See the License for the specific language governing permissions and</span><br><span class="line"># limitations under the License.</span><br><span class="line"></span><br><span class="line"># Set Hadoop-specific environment variables here.</span><br><span class="line"></span><br><span class="line"># The only required environment variable is JAVA_HOME.  All others are</span><br><span class="line"># optional.  When running a distributed configuration it is best to</span><br><span class="line"># set JAVA_HOME in this file, so that it is correctly defined on</span><br><span class="line"># remote nodes.</span><br><span class="line"></span><br><span class="line"># The java implementation to use.</span><br><span class="line">export JAVA_HOME=/usr/java/java</span><br><span class="line"></span><br><span class="line"># The jsvc implementation to use. Jsvc is required to run secure datanodes</span><br><span class="line"># that bind to privileged ports to provide authentication of data transfer</span><br><span class="line"># protocol.  Jsvc is not required if SASL is configured for authentication of</span><br><span class="line"># data transfer protocol using non-privileged ports.</span><br><span class="line">#export JSVC_HOME=$&#123;JSVC_HOME&#125;</span><br><span class="line"></span><br><span class="line">export HADOOP_CONF_DIR=$&#123;HADOOP_CONF_DIR:-&quot;/etc/hadoop&quot;&#125;</span><br><span class="line"></span><br><span class="line"># Extra Java CLASSPATH elements.  Automatically insert capacity-scheduler.</span><br><span class="line">for f in $HADOOP_HOME/contrib/capacity-scheduler/*.jar; do</span><br><span class="line">  if [ &quot;$HADOOP_CLASSPATH&quot; ]; then</span><br><span class="line">    export HADOOP_CLASSPATH=$HADOOP_CLASSPATH:$f</span><br><span class="line">  else</span><br><span class="line">    export HADOOP_CLASSPATH=$f</span><br><span class="line">  fi</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"># The maximum amount of heap to use, in MB. Default is 1000.</span><br><span class="line">#export HADOOP_HEAPSIZE=</span><br><span class="line">#export HADOOP_NAMENODE_INIT_HEAPSIZE=&quot;&quot;</span><br><span class="line"></span><br><span class="line"># Extra Java runtime options.  Empty by default.</span><br><span class="line">export HADOOP_OPTS=&quot;$HADOOP_OPTS -Djava.net.preferIPv4Stack=true&quot;</span><br><span class="line"></span><br><span class="line"># Command specific options appended to HADOOP_OPTS when specified</span><br><span class="line">export HADOOP_NAMENODE_OPTS=&quot;-Dhadoop.security.logger=$&#123;HADOOP_SECURITY_LOGGER:-INFO,RFAS&#125; -Dhdfs.audit.logger=$&#123;HDFS_AUDIT_LOGGER:-INFO,NullAppender&#125; $HADOOP_NAMENODE_OPTS&quot;</span><br><span class="line">export HADOOP_DATANODE_OPTS=&quot;-Dhadoop.security.logger=ERROR,RFAS $HADOOP_DATANODE_OPTS&quot;</span><br><span class="line"></span><br><span class="line">export HADOOP_SECONDARYNAMENODE_OPTS=&quot;-Dhadoop.security.logger=$&#123;HADOOP_SECURITY_LOGGER:-INFO,RFAS&#125; -Dhdfs.audit.logger=$&#123;HDFS_AUDIT_LOGGER:-INFO,NullAppender&#125; $HADOOP_SECONDARYNAMENODE_OPTS&quot;</span><br><span class="line"></span><br><span class="line">export HADOOP_NFS3_OPTS=&quot;$HADOOP_NFS3_OPTS&quot;</span><br><span class="line">export HADOOP_PORTMAP_OPTS=&quot;-Xmx512m $HADOOP_PORTMAP_OPTS&quot;</span><br><span class="line"></span><br><span class="line"># The following applies to multiple commands (fs, dfs, fsck, distcp etc)</span><br><span class="line">export HADOOP_CLIENT_OPTS=&quot;-Xmx512m $HADOOP_CLIENT_OPTS&quot;</span><br><span class="line">#HADOOP_JAVA_PLATFORM_OPTS=&quot;-XX:-UsePerfData $HADOOP_JAVA_PLATFORM_OPTS&quot;</span><br><span class="line"></span><br><span class="line"># On secure datanodes, user to run the datanode as after dropping privileges.</span><br><span class="line"># This **MUST** be uncommented to enable secure HDFS if using privileged ports</span><br><span class="line"># to provide authentication of data transfer protocol.  This **MUST NOT** be</span><br><span class="line"># defined if SASL is configured for authentication of data transfer protocol</span><br><span class="line"># using non-privileged ports.</span><br><span class="line">export HADOOP_SECURE_DN_USER=$&#123;HADOOP_SECURE_DN_USER&#125;</span><br><span class="line"></span><br><span class="line"># Where log files are stored.  $HADOOP_HOME/logs by default.</span><br><span class="line">#export HADOOP_LOG_DIR=$&#123;HADOOP_LOG_DIR&#125;/$USER</span><br><span class="line"></span><br><span class="line"># Where log files are stored in the secure data environment.</span><br><span class="line">export HADOOP_SECURE_DN_LOG_DIR=$&#123;HADOOP_LOG_DIR&#125;/$&#123;HADOOP_HDFS_USER&#125;</span><br><span class="line"></span><br><span class="line">###</span><br><span class="line"># HDFS Mover specific parameters</span><br><span class="line">###</span><br><span class="line"># Specify the JVM options to be used when starting the HDFS Mover.</span><br><span class="line"># These options will be appended to the options specified as HADOOP_OPTS</span><br><span class="line"># and therefore may override any similar flags set in HADOOP_OPTS</span><br><span class="line">#</span><br><span class="line"># export HADOOP_MOVER_OPTS=&quot;&quot;</span><br><span class="line"></span><br><span class="line">###</span><br><span class="line"># Advanced Users Only!</span><br><span class="line">###</span><br><span class="line"></span><br><span class="line"># The directory where pid files are stored. /tmp by default.</span><br><span class="line"># NOTE: this should be set to a directory that can only be written to by </span><br><span class="line">#       the user that will run the hadoop daemons.  Otherwise there is the</span><br><span class="line">#       potential for a symlink attack.</span><br><span class="line">export HADOOP_PID_DIR=$&#123;HADOOP_PID_DIR&#125;</span><br><span class="line">export HADOOP_SECURE_DN_PID_DIR=$&#123;HADOOP_PID_DIR&#125;</span><br><span class="line"></span><br><span class="line"># A string representing this instance of hadoop. $USER by default.</span><br><span class="line">export HADOOP_IDENT_STRING=$USER</span><br><span class="line">[double_happy@hadoop101 hadoop]$ </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">	#export HADOOP_HEAPSIZE=</span><br><span class="line">	export HADOOP_PORTMAP_OPTS=&quot;-Xmx512m $HADOOP_PORTMAP_OPTS&quot;  </span><br><span class="line">	都是有的   eg：-Xmx</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">4.stack 大小</span><br><span class="line">[double_happy@hadoop101 ~]$ more flags.txt | grep ThreadStackSize</span><br><span class="line">     intx CompilerThreadStackSize                   = 0                                   &#123;pd product&#125;</span><br><span class="line">     intx ThreadStackSize                           = 1024                                &#123;pd product&#125;</span><br><span class="line">     intx VMThreadStackSize                         = 1024                                &#123;pd product&#125;</span><br><span class="line">[double_happy@hadoop101 ~]$ </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[double_happy@hadoop101 ~]$ jps</span><br><span class="line">17088 QuorumPeerMain</span><br><span class="line">8484 DataNode</span><br><span class="line">23653 Kafka</span><br><span class="line">8902 NodeManager</span><br><span class="line">14999 AzkabanSingleServer</span><br><span class="line">631 Kafka</span><br><span class="line">9416 Jps</span><br><span class="line">8648 SecondaryNameNode</span><br><span class="line">25784 NameNode</span><br><span class="line">24862 Kafka</span><br><span class="line">8798 ResourceManager</span><br><span class="line">[double_happy@hadoop101 ~]$ jinfo -flag ThreadStackSize 25784    </span><br><span class="line">-XX:ThreadStackSize=1024</span><br><span class="line">[double_happy@hadoop101 ~]$ </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">jinfo使用：</span><br><span class="line">[double_happy@hadoop101 ~]$ jinfo</span><br><span class="line">Usage:</span><br><span class="line">    jinfo [option] &lt;pid&gt;</span><br><span class="line">        (to connect to running process)</span><br><span class="line">    jinfo [option] &lt;executable &lt;core&gt;</span><br><span class="line">        (to connect to a core file)</span><br><span class="line">    jinfo [option] [server_id@]&lt;remote server IP or hostname&gt;</span><br><span class="line">        (to connect to remote debug server)</span><br><span class="line"></span><br><span class="line">where &lt;option&gt; is one of:</span><br><span class="line">    -flag &lt;name&gt;         to print the value of the named VM flag</span><br><span class="line">    -flag [+|-]&lt;name&gt;    to enable or disable the named VM flag</span><br><span class="line">    -flag &lt;name&gt;=&lt;value&gt; to set the named VM flag to the given value</span><br><span class="line">    -flags               to print VM flags</span><br><span class="line">    -sysprops            to print Java system properties</span><br><span class="line">    &lt;no option&gt;          to print both of the above</span><br><span class="line">    -h | -help           to print this help message</span><br><span class="line">[double_happy@hadoop101 ~]$ </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">5.-Xss      -XX:ThreadStackSize         </span><br><span class="line">	表示线程栈的大小       单位是 kb     4，5是一个东西  一般这个值 521-1024之间 </span><br><span class="line">6.-Xmn   年轻代大小</span><br></pre></td></tr></table></figure></div>
<p><strong>继续异常：</strong></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.lang.outofMemoryError:GC overhea  limit exceeded</span><br><span class="line"></span><br><span class="line">日志：</span><br><span class="line">	PSYongGen:2048k-&gt;502k(2560k)   指的是  502表示没有被GC的数据</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191106130146847.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20191106130508586.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Full GC  1023-&gt;1023 表示已经干不掉了 </span><br><span class="line"></span><br><span class="line">注意：GC是连续GC</span><br><span class="line">就是发现 到最后 已经没有办法进行GC了 所以抛出异常</span><br><span class="line"></span><br><span class="line">为什么没有办法进行GC呢 ？</span><br><span class="line">	首先 到达一定的阈值 它想去GC 默认值是98%   就是超过了这个阈值 它回收不掉 也就发生了 想去回收 但是发现又GC不了</span><br><span class="line">	所以遇到GC overhea  limit exceeded 错 十有八九你的代码是有问题的 或者参数不够</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2. 先看一个类 nio </span><br><span class="line">非堆区 那块</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191106131313188.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">allocate这个方法  分配JVM内存</span><br><span class="line">allocateDirect     分配本地内存     到底本地内存占多少呢？一般情况下 我们开发不要使用这种的  上一篇文章写了 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">写一个类：</span><br><span class="line">public class DirectBufferMemoryApp &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println((sun.misc.VM.maxDirectMemory())/(double)1024/1024);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果是：</span><br><span class="line">	7264 </span><br><span class="line">7264 与本地的操作系统有很大关系的   是 本地内存大概的的 1/4   我电脑是32g的</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191106132705417.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">结果：</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Direct buffer memory</span><br><span class="line">	at java.nio.Bits.reserveMemory(Bits.java:694)</span><br><span class="line">	at java.nio.DirectByteBuffer.&lt;init&gt;(DirectByteBuffer.java:123)</span><br><span class="line">	at java.nio.ByteBuffer.allocateDirect(ByteBuffer.java:311)</span><br><span class="line">	at com.app.java.jvm.DirectBufferMemoryApp.main(DirectBufferMemoryApp.java:11)</span><br><span class="line"></span><br><span class="line">Direct buffer memory 指的是 你调用的api 直接分配的内存  已经超过了 我们本地操作系统能用的 </span><br><span class="line"></span><br><span class="line">这可不是堆里面的  而是堆外的哦</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">3.</span><br><span class="line">public class UnableCreateNewThreadApp &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        </span><br><span class="line">        for (int i=1 ;;i++) &#123;</span><br><span class="line">            System.out.println(&quot;------&quot;+i);</span><br><span class="line">            </span><br><span class="line">            //搞一堆的线程</span><br><span class="line">            new Thread(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(Integer.MAX_VALUE);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,i+&quot;&quot;).start();</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">一个死循环 每一个循环 会启动一个线程   </span><br><span class="line">去linux上测试  如果在windows上测试 很可能 你懂得</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">------3419</span><br><span class="line">------3420</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: unable to create new native thread</span><br><span class="line">        at java.lang.Thread.start0(Native Method)</span><br><span class="line">        at java.lang.Thread.start(Thread.java:714)</span><br><span class="line">        at UnableCreateNewThreadApp.main(UnableCreateNewThreadApp.java:18)</span><br><span class="line"></span><br><span class="line">为了演示这个错误我Linux 电脑挂了    用root 把 那个进程kill 掉即可  不需要重启</span><br><span class="line"></span><br><span class="line"> unable to create new native thread：</span><br><span class="line"> 	为什么呢？是线程太多了 </span><br><span class="line">到底有多少个线程呢？</span><br><span class="line">		4096 个线程数 </span><br><span class="line">	[double_happy@hadoop101 jvm]$ ulimit -u              </span><br><span class="line">	4096</span><br><span class="line">	[double_happy@hadoop101 jvm]$ 	</span><br><span class="line"></span><br><span class="line">为什么3420 挂了呢  因为 我机器还有别的线程呀 </span><br><span class="line"></span><br><span class="line">修改线程数即可</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">4.</span><br><span class="line">java.lang.outofmemoryError:Metaspace</span><br><span class="line"></span><br><span class="line">Metaspace里面存的是放了类的属性等</span><br></pre></td></tr></table></figure></div>
      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-JVM01" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/15/JVM01/">JVM01</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2017/11/15/JVM01/" class="article-date">
  <time datetime="2017-11-14T17:02:06.000Z" itemprop="datePublished">2017-11-15</time>
</a>
    
    
  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <p><strong>运行时数据区</strong><br><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5" target="_blank" rel="noopener">官网</a><br>2.5. Run-Time Data Areas<br>The Java Virtual Machine defines various run-time data areas that are used during execution of a program. Some of these <strong>data areas</strong> <strong>are created on Java Virtual Machine start-up and are destroyed only when the Java Virtual Machine exits.</strong> <strong>Other data areas are per thread.</strong> Per-thread data areas are created when a thread is created and destroyed when the thread exits.</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1.data areas 有生命周期的 jvm启动的时候被创建 jvm退出的时候被销毁</span><br><span class="line">2.有些data areas是线程独有的      当线程创建的时候被创建 线程退出的时候被销毁</span><br><span class="line"></span><br><span class="line">总结：	</span><br><span class="line">1）JVM创建时创建，退出时销毁</span><br><span class="line">2）每个Thread独有，Thread创建时创建，Thread退出时销毁</span><br><span class="line">	==&gt; 有一些区是共享，有一些区是独享    从线程的角度</span><br><span class="line"></span><br><span class="line">运行时数据区有哪些呢？</span><br><span class="line">运行时数据区</span><br><span class="line">	1） The pc Register        程序计数器</span><br><span class="line">	2） Java Virtual Machine Stacks</span><br><span class="line">	3） Heap          </span><br><span class="line">	4） Method Area                   方法区</span><br><span class="line">	5） Run-Time Constant Pool      这个一般是在方法区里面的</span><br><span class="line">	6） Native Method Stacks</span><br><span class="line"></span><br><span class="line">每一个区做什么事情 下面依次讲解</span><br></pre></td></tr></table></figure></div>
<p><strong>1.The pc Register        程序计数器</strong></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">The pc Register  程序计数器</span><br><span class="line">	1.占用一小块的内存       (指的是占用运行时数据区总的内存 毕竟他是在运行时数据区的内部的)</span><br><span class="line">	2.作用：当前线程所执行的字节码的行号指示器</span><br><span class="line">		什么意思呢？</span><br><span class="line">			在java里可能是以单线程的方式运行的 也有可能以多线程的方式运行的 那么问题来了</span><br><span class="line">			比如说 多线程的方式  你这个线程的在跑 此时另外一个线程它拿到了cpu的执行权 它开始执行的时候</span><br><span class="line">			那么前一个线程肯定会停下来  就是优先级高的调度到的 先执行。等它运行完了再抢占。这个时候如果前面的线程回来了</span><br><span class="line">			问题是 回来的这个线程从什么地方开始执行 它知道吗？这就是当前线程所执行的字节码都是有一个的行号指示器的</span><br><span class="line">			意思就是说 它会从字节码里的某一个行号开始往下继续执行</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">什么是字节码？</span><br><span class="line">	 eg：</span><br><span class="line">[double_happy@hadoop101 jvm]$ cat Hello.java </span><br><span class="line">public class Hello&#123;</span><br><span class="line">        public static void  main(String[] args)&#123;</span><br><span class="line">                System.out.println(&quot;hello..&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">[double_happy@hadoop101 jvm]$ </span><br><span class="line"></span><br><span class="line">Hello.java 这个东西对于jvm来说不知道是什么东西 这仅仅是我们开发的应用程序java源代码而已 系统是不能识别的</span><br><span class="line">系统识别的是class文件  所以需要把Hello.java文件编译成class文件</span><br><span class="line"></span><br><span class="line">[double_happy@hadoop101 jvm]$ javac Hello.java </span><br><span class="line">[double_happy@hadoop101 jvm]$ ll</span><br><span class="line">total 8</span><br><span class="line">-rw-rw-r-- 1 double_happy double_happy 411 Nov  5 19:18 Hello.class</span><br><span class="line">-rw-rw-r-- 1 double_happy double_happy 100 Nov  5 19:18 Hello.java</span><br><span class="line">[double_happy@hadoop101 jvm]$ rm -rf Hello.class </span><br><span class="line">[double_happy@hadoop101 jvm]$ java Hello</span><br><span class="line">Error: Could not find or load main class Hello</span><br><span class="line">[double_happy@hadoop101 jvm]$ javac Hello.java </span><br><span class="line">[double_happy@hadoop101 jvm]$ java Hello</span><br><span class="line">hello..</span><br><span class="line">[double_happy@hadoop101 jvm]$</span><br><span class="line"></span><br><span class="line">Hello.class 是一个class字节码文件  可以通过命令查看他的字节码</span><br><span class="line"></span><br><span class="line">[double_happy@hadoop101 jvm]$ javap -verbose Hello.class &gt;&gt; Hello.txt</span><br><span class="line">[double_happy@hadoop101 jvm]$ cat Hello.txt </span><br><span class="line">Classfile /home/double_happy/script/jvm/Hello.class</span><br><span class="line">  Last modified Nov 5, 2019; size 411 bytes</span><br><span class="line">  MD5 checksum 6f1c4345f8677c12ec8d3eb12da54cda</span><br><span class="line">  Compiled from &quot;Hello.java&quot;</span><br><span class="line">public class Hello         //下面就是他的字节码文件</span><br><span class="line">  minor version: 0         //jdk版本</span><br><span class="line">  major version: 52      ////jdk版本     </span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #6.#15         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Fieldref           #16.#17        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #3 = String             #18            // hello..</span><br><span class="line">   #4 = Methodref          #19.#20        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">   #5 = Class              #21            // Hello</span><br><span class="line">   #6 = Class              #22            // java/lang/Object</span><br><span class="line">   #7 = Utf8               &lt;init&gt;</span><br><span class="line">   #8 = Utf8               ()V</span><br><span class="line">   #9 = Utf8               Code</span><br><span class="line">  #10 = Utf8               LineNumberTable</span><br><span class="line">  #11 = Utf8               main</span><br><span class="line">  #12 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #13 = Utf8               SourceFile</span><br><span class="line">  #14 = Utf8               Hello.java</span><br><span class="line">  #15 = NameAndType        #7:#8          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #16 = Class              #23            // java/lang/System</span><br><span class="line">  #17 = NameAndType        #24:#25        // out:Ljava/io/PrintStream;</span><br><span class="line">  #18 = Utf8               hello..</span><br><span class="line">  #19 = Class              #26            // java/io/PrintStream</span><br><span class="line">  #20 = NameAndType        #27:#28        // println:(Ljava/lang/String;)V</span><br><span class="line">  #21 = Utf8               Hello</span><br><span class="line">  #22 = Utf8               java/lang/Object</span><br><span class="line">  #23 = Utf8               java/lang/System</span><br><span class="line">  #24 = Utf8               out</span><br><span class="line">  #25 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #26 = Utf8               java/io/PrintStream</span><br><span class="line">  #27 = Utf8               println</span><br><span class="line">  #28 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">&#123;</span><br><span class="line">  public Hello();     //自带空的构造器 </span><br><span class="line">    descriptor: ()V     </span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0     //字节码的指令</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:      //行号   在程序或者线程的执行过程当中 它就能知道我这次运行到字节码里面的多少行 </span><br><span class="line">        line 1: 0</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=1, args_size=1</span><br><span class="line">         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: ldc           #3                  // String hello..</span><br><span class="line">         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">         8: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 3: 0</span><br><span class="line">        line 4: 8</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;Hello.java&quot;</span><br><span class="line">[double_happy@hadoop101 jvm]$</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">字节码</span><br><span class="line">	 aload_0    字节码指令   </span><br><span class="line">	  我们的应用程序最后拿到的是一堆的机器的指令  jvm就可以通过我们这些指令 它就知道你开发的应用程序想做一个什么事情 </span><br><span class="line">	  (java 代码一定会被编译成字节码 不同的字节码 干不同的事情）就是这一步.java =&gt;.class </span><br><span class="line"></span><br><span class="line">那么字节码和 程序计数器有什么关系呢？</span><br><span class="line">程序计数器：</span><br><span class="line">	记录当前线程目前执行到你的代码所对应的哪一条字节码指令</span><br><span class="line"></span><br><span class="line">多线程的情况下执行你的代码？</span><br><span class="line">	可能是多个线程并发的执行   那么多个线程共同执行的时候 就有可能出现</span><br><span class="line">	你每一个线程当前运行到的字节码指令行数是不一样的      多线程就是cpu抢占的问题</span><br><span class="line">	也就是说：每个线程都有自己的程序计数器      </span><br><span class="line">		专门用来记录我们所执行的这个线程现在到了哪一步了 </span><br><span class="line"></span><br><span class="line">所以：**</span><br><span class="line">程序计数器   属于  运行时数据区  的第二类       即  每个Thread独有</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191105194645327.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>2） Java Virtual Machine Stacks</strong></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Hello &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Hello hello = new Hello(); </span><br><span class="line">        hello.hello();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public  void hello()&#123;</span><br><span class="line">        String name = &quot;double_happy&quot;;   //局部变量     它的生命周期是在 这个hello函数里面的 </span><br><span class="line">        System.out.println(&quot;Hello: &quot; + name);  </span><br><span class="line">                </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">在main方法里面调用hello这个方法  我们在执行的过程当中 一定是有一个线程在 执行这段代码 去调用hello这个方法</span><br><span class="line"></span><br><span class="line">这里来说是 main这个线程  执行main方法里面的代码   </span><br><span class="line">那么对于 局部变量来说 它到时候会存在 jvm 数据运行区 的哪一个部分呢？</span><br><span class="line"></span><br><span class="line">存在Java Virtual Machine Stacks   jvm的一个栈</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Each Java Virtual Machine thread has a private Java Virtual Machine stack, created at the same time as the thread</span><br><span class="line">A Java Virtual Machine stack stores frames </span><br><span class="line"></span><br><span class="line">Java Virtual Machine Stacks  </span><br><span class="line">	1.方法里面的一些局部变量......   它就是存在 frames里的 </span><br><span class="line">	2.存的是frames: 栈帧</span><br><span class="line">	A new frame is created each time a method is invoked. 方法调用的时候被创建</span><br><span class="line">		对于上面的代码来说  main方法被调用 会创建一个 frame  hello方法被调用 也会创建一个  frame </span><br><span class="line">	A frame is destroyed when its method invocation completes  方法执行完毕的时候被销毁</span><br><span class="line">		</span><br><span class="line">	栈的特性 ：先进后出 </span><br><span class="line">	栈：main==&gt;hello    入栈：就是方法被调用的时候   出栈 ： 方法执行完毕的时候</span><br><span class="line">	可能会抛出的异常：StackOverflowError</span><br><span class="line">		这个很好理解 我们这些区 都是属于jvm运行时的区 每个区肯定都是有大小的 </span><br><span class="line">		你的线程计算时需要的大小 比我们 Java Virtual Machine Stacks   大 会抛出StackOverflowError 这个异常</span><br><span class="line">	</span><br><span class="line">	调用方法时，会为每个方法创建Frame，入栈</span><br><span class="line">	方法执行完毕后，Frame出栈</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191105202251465.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>3.Heap  堆</strong> ****重点</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">The Java Virtual Machine has a heap that is shared among all Java Virtual Machine threads</span><br><span class="line">所有线程共享的一块区域</span><br><span class="line"></span><br><span class="line">Heap ：</span><br><span class="line">	创建对象  是存在Heap里面的</span><br><span class="line">	可能会抛出的异常：OutOfMemoryError</span><br><span class="line">		什么场景下？你new出来的一些东西 最终放在heap里  比你默认的heap的大小大 </span><br><span class="line"></span><br><span class="line">eg：</span><br><span class="line">public class Hello &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Hello hello = new Hello();</span><br><span class="line">        hello.hello();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public  void hello()&#123;</span><br><span class="line">        String name = &quot;double_happy&quot;;</span><br><span class="line">        System.out.println(&quot;Hello: &quot; + name);</span><br><span class="line"></span><br><span class="line">        BasketballPlayer player = new BasketballPlayer(&quot;波兰名宿&quot;);</span><br><span class="line">        player.xxx();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class BasketballPlayer&#123;</span><br><span class="line">    String name;</span><br><span class="line">    </span><br><span class="line">    public BasketballPlayer()&#123;&#125;</span><br><span class="line">    public BasketballPlayer(String name)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;  </span><br><span class="line">    public void xxx()&#123;</span><br><span class="line">        System.out.println(name + &quot;发边线球....&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">在我们的hello方法里面 new 了一个对象  它是在堆里面的</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191105204643975.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>4.Method Area/Metaspace</strong> 方法区</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">The Java Virtual Machine has a method area that is shared among all Java Virtual Machine threads.</span><br><span class="line">所有线程共享的一块区域   1.8之后叫做 Metaspace</span><br><span class="line"></span><br><span class="line">Method Area/Metaspace里面存的是：</span><br><span class="line">	constant pool, 常量池</span><br><span class="line">	field and method data,  属性和方法数据</span><br><span class="line">	and the code for methods and constructors   方法代码和构造器代码</span><br><span class="line">	就是：</span><br><span class="line">		class文件加载进来放这里</span><br><span class="line">	可能会抛出的异常：OutOfMemoryError</span><br><span class="line">    什么场景下发生呢？</span><br></pre></td></tr></table></figure></div>
<p><strong>5.Native Method Stacks</strong>本地方法栈</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Native Method Stacks</span><br><span class="line">	native修饰的方法 是调用本地操作系统里面的方法 c语言或者 一些底层类库等等</span><br><span class="line">	可能会抛出的异常：StackOverflowError/OutOfMemoryError</span><br><span class="line"></span><br><span class="line">那么在调用 native修饰的方法 的时候 每个线程就会创建一个 本地方法栈</span><br><span class="line"></span><br><span class="line">所以方法分为两种：</span><br><span class="line">	native的      放在Native Method Stacks</span><br><span class="line">	非native的   放在 Java Virtual Machine Stacks</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191105210739239.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">还有一个区：是干嘛的呢？</span><br><span class="line">	Area: 不属于JVM   </span><br><span class="line">		eg： 通过nio 直接创建一些内存   就是堆外内存  这块是直接操作内存空间的 性能方面是好的 （Spark里面是有的  得调整堆外内存的空间的）</span><br><span class="line">			但是 如果不节制 会有可能会出现什么场景呢？</span><br><span class="line">			你大量的去这么干肯定是不行的  建议 你如果 去调用底层源码是可以的  自己的代码直接操作堆外内存是不合适的</span><br></pre></td></tr></table></figure></div>
<p><strong>总结</strong><br><img src="https://img-blog.csdnimg.cn/20191105213916315.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line">        String s1 = new String(&quot;double happy&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">问这句话产生了几个对象？</span><br><span class="line">	2个：哪两个呢？</span><br><span class="line">		1.s1   局部变量 存的是对象的地址  在stack里 </span><br><span class="line">		2.  new String     在Heap 里面  </span><br><span class="line">		3.  方法区里面的常量池 存一个对象 叫 double happy </span><br><span class="line"></span><br><span class="line">测试：</span><br><span class="line">	    public static void main(String[] args) &#123;</span><br><span class="line">        String s1 = new String(&quot;double happy&quot;);</span><br><span class="line">        String s2 = &quot;double happy&quot;;</span><br><span class="line"></span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">结果是false </span><br><span class="line">	因为s1 指向heap 里的 new String</span><br><span class="line">	s2 指向的method area 里的常量池里的 double happy</span><br><span class="line"></span><br><span class="line">测试：</span><br><span class="line">	    public static void main(String[] args) &#123;</span><br><span class="line">        String s1 = new String(&quot;double happy&quot;);</span><br><span class="line">        String s2 = &quot;double happy&quot;;</span><br><span class="line"></span><br><span class="line">        System.out.println(s1 == s2); //比较的是 引用地址</span><br><span class="line">        System.out.println(s1.equals(s2));// equals 比较的是内容</span><br><span class="line">    &#125;</span><br><span class="line">  结果是：</span><br><span class="line">  	false</span><br><span class="line">  	true</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191105215809121.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String s1 = &quot;双喜&quot;;</span><br><span class="line">        String s2 = &quot;男的&quot;;</span><br><span class="line">        String s3 = &quot;双喜&quot; + &quot;男的&quot;;</span><br><span class="line">        String s4 = s1 + s2;</span><br><span class="line">        String s5 = &quot;双喜男的&quot;;</span><br><span class="line">       String s6 = s4.intern();</span><br><span class="line">        System.out.println(s3 == s4); </span><br><span class="line">        System.out.println(s3 == s5);</span><br><span class="line">        System.out.println(s4 == s5);</span><br><span class="line">          System.out.println(s3 == s6);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">结果是：</span><br><span class="line">false</span><br><span class="line">true</span><br><span class="line">false</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191105220642702.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Returns a canonical representation for the string object.</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * A pool of strings, initially empty, is maintained privately by the</span><br><span class="line">     * class &#123;@code String&#125;.</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * When the intern method is invoked, if the pool already contains a</span><br><span class="line">     * string equal to this &#123;@code String&#125; object as determined by</span><br><span class="line">     * the &#123;@link #equals(Object)&#125; method, then the string from the pool is</span><br><span class="line">     * returned. Otherwise, this &#123;@code String&#125; object is added to the</span><br><span class="line">     * pool and a reference to this &#123;@code String&#125; object is returned.</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * It follows that for any two strings &#123;@code s&#125; and &#123;@code t&#125;,</span><br><span class="line">     * &#123;@code s.intern() == t.intern()&#125; is &#123;@code true&#125;</span><br><span class="line">     * if and only if &#123;@code s.equals(t)&#125; is &#123;@code true&#125;.</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * All literal strings and string-valued constant expressions are</span><br><span class="line">     * interned. String literals are defined in section 3.10.5 of the</span><br><span class="line">     * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.</span><br><span class="line">     *</span><br><span class="line">     * @return  a string that has the same contents as this string, but is</span><br><span class="line">     *          guaranteed to be from a pool of unique strings.</span><br><span class="line">     */</span><br><span class="line">    public native String intern();</span><br><span class="line">所以  intern  返回 string object. 真实的值 </span><br><span class="line">所以s6 指向的是 常量池里面的东西 </span><br><span class="line"></span><br><span class="line"> if and only if &#123;@code s.equals(t)&#125; is &#123;@code true&#125;.</span><br><span class="line"> 就是 equals相等  intern  就相等</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191105221230853.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">比较特殊：</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">   </span><br><span class="line">        Integer i1 = 50;</span><br><span class="line">        Integer i2 = 50;</span><br><span class="line"></span><br><span class="line">        System.out.println(i1 == i2);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">这个东西按常理来讲是 不等的对吧  包装类 一般是new 出来的 </span><br><span class="line">这是相等的</span><br><span class="line">先这样 </span><br><span class="line">	Integer i1 = new Integer(50);</span><br><span class="line">    Integer i2 = new Integer(50);</span><br><span class="line">这两个相等么？</span><br><span class="line">	false</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">对于基本类型 包装类型 都是放在 常量池里的 new出来的肯定不是放在池子里的哈 </span><br><span class="line"></span><br><span class="line">那么：</span><br><span class="line">	        Integer i1 = 150;</span><br><span class="line">            Integer i2 = 150;</span><br><span class="line">         相等么？  不等的</span><br><span class="line">         因为 池子里面 是有一个范围的   基本类型 包装类型都有</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns an &#123;@code Integer&#125; instance representing the specified</span><br><span class="line">     * &#123;@code int&#125; value.  If a new &#123;@code Integer&#125; instance is not</span><br><span class="line">     * required, this method should generally be used in preference to</span><br><span class="line">     * the constructor &#123;@link #Integer(int)&#125;, as this method is likely</span><br><span class="line">     * to yield significantly better space and time performance by</span><br><span class="line">     * caching frequently requested values.</span><br><span class="line">     *</span><br><span class="line">     * This method will always cache values in the range -128 to 127,</span><br><span class="line">     * inclusive, and may cache other values outside of this range.</span><br><span class="line">     *</span><br><span class="line">     * @param  i an &#123;@code int&#125; value.</span><br><span class="line">     * @return an &#123;@code Integer&#125; instance representing &#123;@code i&#125;.</span><br><span class="line">     * @since  1.5</span><br><span class="line">     */</span><br><span class="line">    public static Integer valueOf(int i) &#123;</span><br><span class="line">        if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">            return IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">        return new Integer(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line"> IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high  </span><br><span class="line">low = -128</span><br><span class="line">int h = 127</span><br><span class="line"></span><br><span class="line">明白了吧 </span><br><span class="line"></span><br><span class="line">但是 </span><br><span class="line">        Double d1 = 10.0D;</span><br><span class="line">        Double d2 = 10.0D;</span><br><span class="line">看源码你就知道了 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	    public static Double valueOf(double d) &#123;</span><br><span class="line">        return new Double(d);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">底层是 new   所以是不等的 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">所以 源码面前了无密码  源码用到的时候  还是要看的</span><br></pre></td></tr></table></figure></div>

      
    </div>
    
  </div>
  
  
</article>

  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/4/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span>
  </nav>


</section>
        <aside id="sidebar">
  
    <div class="widget-box">
  <div class="avatar-box">
    <img class="avatar" src="/images/default-avatar.jpg" title="图片来自网络"></img>
    <h3 class="avatar-name">
      
        DoubleHappy
      
    </h3>
    <p class="avatar-slogan">
      特别耐撕的大数据，资深的打酱油攻城狮。
    </p>
  </div>
</div>


  
    

  
    

  
    
  
    
  <div class="widget-box">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li></ul>
    </div>
  </div>

  
    
  <div class="widget-box">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/01/05/Azkaban%E8%B0%83%E5%BA%A6-double-happy/">Azkaban调度--double_happy</a>
          </li>
        
          <li>
            <a href="/2019/01/04/Zookeeper%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%9B%91%E6%8E%A7-Curator/">Zookeeper基本使用与监控(Curator)</a>
          </li>
        
          <li>
            <a href="/2018/04/17/SparkSQL-TextFile%E8%BE%93%E5%87%BA%E5%A4%9A%E5%88%97/">SparkSQL--TextFile输出多列</a>
          </li>
        
          <li>
            <a href="/2018/03/17/%E9%9B%85%E6%81%A9%E8%B5%84%E6%BA%90%E8%B0%83%E4%BC%98-double-happy/">雅恩资源调优---double_happy</a>
          </li>
        
          <li>
            <a href="/2018/02/22/SS04/">SS04</a>
          </li>
        
      </ul>
    </div>
  </div>

  
      <div class="widget-box">
    <h3 class="widget-title">友链</h3>
    <div class="widget">
      
        <a style="display: block;" href="https://sxwanggit126.github.io/" title target='_blank'
        >一路眼瞎</a>
      
    </div>
  </div>

  
</aside>
      </div>
      <footer id="footer">
  <div class="foot-box global-width">
    &copy; 2019 DoubleHappy &nbsp;&nbsp;
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    &nbsp;|&nbsp;主题 <a href="https://github.com/yiluyanxia/hexo-theme-antiquity" target="_blank" rel="noopener">antiquity</a>
    <br>
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span id="busuanzi_container_site_pv">不蒜子告之   阁下是第<span id="busuanzi_value_site_pv"></span>个访客</span>
  </div>
</footer>
      <script src="https://code.jquery.com/jquery-2.0.3.min.js"></script>
<script>
if (!window.jQuery) {
var script = document.createElement('script');
script.src = "/js/jquery-2.0.3.min.js";
document.body.write(script);
}
</script>

  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



    </div>
    <nav id="mobile-nav" class="mobile-nav-box">
  <div class="mobile-nav-img mobile-nav-top"></div>
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
  <div class="mobile-nav-img  mobile-nav-bottom"></div>
</nav>    
  </div>
</body>
</html>