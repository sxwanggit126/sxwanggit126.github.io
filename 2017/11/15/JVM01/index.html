<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>JVM01 | DoubleHappy or Jepson</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  
  <meta name="description" content="运行时数据区官网2.5. Run-Time Data AreasThe Java Virtual Machine defines various run-time data areas that are used during execution of a program. Some of these data areas are created on Java Virtual Machine s">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM01">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2017&#x2F;11&#x2F;15&#x2F;JVM01&#x2F;index.html">
<meta property="og:site_name" content="DoubleHappy or Jepson">
<meta property="og:description" content="运行时数据区官网2.5. Run-Time Data AreasThe Java Virtual Machine defines various run-time data areas that are used during execution of a program. Some of these data areas are created on Java Virtual Machine s">
<meta property="og:locale" content="en">
<meta property="og:image" content="https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;20191105194645327.png?x-oss-process=image&#x2F;watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;20191105202251465.png?x-oss-process=image&#x2F;watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;20191105204643975.png?x-oss-process=image&#x2F;watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;20191105210739239.png?x-oss-process=image&#x2F;watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;20191105213916315.png?x-oss-process=image&#x2F;watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;20191105215809121.png?x-oss-process=image&#x2F;watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;20191105220642702.png?x-oss-process=image&#x2F;watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;20191105221230853.png?x-oss-process=image&#x2F;watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70">
<meta property="og:updated_time" content="2019-11-14T17:02:49.245Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;20191105194645327.png?x-oss-process=image&#x2F;watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70">
  
    <link rel="alternate" href="/atom.xml" title="DoubleHappy or Jepson" type="application/atom+xml">
  
  
    <link rel="icon" href="/images/default-avatar.jpg">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/css/highlight.css">
</head>

<body>
  <div id="fullpage" class="mobile-nav-right">
    
      <div id="wrapper" title="图片来自网络">
    
    
      <header id="header">
  <div id="nav-toggle" class="nav-toggle"></div>
  <div class="head-box global-width">
    <nav class="nav-box nav-right">
      
        <a class="nav-item" href="/archives" title
        
        >首页</a>
      
        <a class="nav-item" href="/archives" title
        
        >归档</a>
      
    </nav>
  </div>
</header>
      <div id="middlecontent" title class="global-width sidebar-right">
        <section id="main"><article id="post-JVM01" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 class="article-title" itemprop="name">
      JVM01
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2017/11/15/JVM01/" class="article-date">
  <time datetime="2017-11-14T17:02:06.000Z" itemprop="datePublished">2017-11-15</time>
</a>
    
    
  </div>
  
    <span id="busuanzi_container_page_pv">
      本文总阅读量<span id="busuanzi_value_page_pv"></span>次
    </span>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <p><strong>运行时数据区</strong><br><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5" target="_blank" rel="noopener">官网</a><br>2.5. Run-Time Data Areas<br>The Java Virtual Machine defines various run-time data areas that are used during execution of a program. Some of these <strong>data areas</strong> <strong>are created on Java Virtual Machine start-up and are destroyed only when the Java Virtual Machine exits.</strong> <strong>Other data areas are per thread.</strong> Per-thread data areas are created when a thread is created and destroyed when the thread exits.</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1.data areas 有生命周期的 jvm启动的时候被创建 jvm退出的时候被销毁</span><br><span class="line">2.有些data areas是线程独有的      当线程创建的时候被创建 线程退出的时候被销毁</span><br><span class="line"></span><br><span class="line">总结：	</span><br><span class="line">1）JVM创建时创建，退出时销毁</span><br><span class="line">2）每个Thread独有，Thread创建时创建，Thread退出时销毁</span><br><span class="line">	==&gt; 有一些区是共享，有一些区是独享    从线程的角度</span><br><span class="line"></span><br><span class="line">运行时数据区有哪些呢？</span><br><span class="line">运行时数据区</span><br><span class="line">	1） The pc Register        程序计数器</span><br><span class="line">	2） Java Virtual Machine Stacks</span><br><span class="line">	3） Heap          </span><br><span class="line">	4） Method Area                   方法区</span><br><span class="line">	5） Run-Time Constant Pool      这个一般是在方法区里面的</span><br><span class="line">	6） Native Method Stacks</span><br><span class="line"></span><br><span class="line">每一个区做什么事情 下面依次讲解</span><br></pre></td></tr></table></figure></div>
<p><strong>1.The pc Register        程序计数器</strong></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">The pc Register  程序计数器</span><br><span class="line">	1.占用一小块的内存       (指的是占用运行时数据区总的内存 毕竟他是在运行时数据区的内部的)</span><br><span class="line">	2.作用：当前线程所执行的字节码的行号指示器</span><br><span class="line">		什么意思呢？</span><br><span class="line">			在java里可能是以单线程的方式运行的 也有可能以多线程的方式运行的 那么问题来了</span><br><span class="line">			比如说 多线程的方式  你这个线程的在跑 此时另外一个线程它拿到了cpu的执行权 它开始执行的时候</span><br><span class="line">			那么前一个线程肯定会停下来  就是优先级高的调度到的 先执行。等它运行完了再抢占。这个时候如果前面的线程回来了</span><br><span class="line">			问题是 回来的这个线程从什么地方开始执行 它知道吗？这就是当前线程所执行的字节码都是有一个的行号指示器的</span><br><span class="line">			意思就是说 它会从字节码里的某一个行号开始往下继续执行</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">什么是字节码？</span><br><span class="line">	 eg：</span><br><span class="line">[double_happy@hadoop101 jvm]$ cat Hello.java </span><br><span class="line">public class Hello&#123;</span><br><span class="line">        public static void  main(String[] args)&#123;</span><br><span class="line">                System.out.println(&quot;hello..&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">[double_happy@hadoop101 jvm]$ </span><br><span class="line"></span><br><span class="line">Hello.java 这个东西对于jvm来说不知道是什么东西 这仅仅是我们开发的应用程序java源代码而已 系统是不能识别的</span><br><span class="line">系统识别的是class文件  所以需要把Hello.java文件编译成class文件</span><br><span class="line"></span><br><span class="line">[double_happy@hadoop101 jvm]$ javac Hello.java </span><br><span class="line">[double_happy@hadoop101 jvm]$ ll</span><br><span class="line">total 8</span><br><span class="line">-rw-rw-r-- 1 double_happy double_happy 411 Nov  5 19:18 Hello.class</span><br><span class="line">-rw-rw-r-- 1 double_happy double_happy 100 Nov  5 19:18 Hello.java</span><br><span class="line">[double_happy@hadoop101 jvm]$ rm -rf Hello.class </span><br><span class="line">[double_happy@hadoop101 jvm]$ java Hello</span><br><span class="line">Error: Could not find or load main class Hello</span><br><span class="line">[double_happy@hadoop101 jvm]$ javac Hello.java </span><br><span class="line">[double_happy@hadoop101 jvm]$ java Hello</span><br><span class="line">hello..</span><br><span class="line">[double_happy@hadoop101 jvm]$</span><br><span class="line"></span><br><span class="line">Hello.class 是一个class字节码文件  可以通过命令查看他的字节码</span><br><span class="line"></span><br><span class="line">[double_happy@hadoop101 jvm]$ javap -verbose Hello.class &gt;&gt; Hello.txt</span><br><span class="line">[double_happy@hadoop101 jvm]$ cat Hello.txt </span><br><span class="line">Classfile /home/double_happy/script/jvm/Hello.class</span><br><span class="line">  Last modified Nov 5, 2019; size 411 bytes</span><br><span class="line">  MD5 checksum 6f1c4345f8677c12ec8d3eb12da54cda</span><br><span class="line">  Compiled from &quot;Hello.java&quot;</span><br><span class="line">public class Hello         //下面就是他的字节码文件</span><br><span class="line">  minor version: 0         //jdk版本</span><br><span class="line">  major version: 52      ////jdk版本     </span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #6.#15         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Fieldref           #16.#17        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #3 = String             #18            // hello..</span><br><span class="line">   #4 = Methodref          #19.#20        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">   #5 = Class              #21            // Hello</span><br><span class="line">   #6 = Class              #22            // java/lang/Object</span><br><span class="line">   #7 = Utf8               &lt;init&gt;</span><br><span class="line">   #8 = Utf8               ()V</span><br><span class="line">   #9 = Utf8               Code</span><br><span class="line">  #10 = Utf8               LineNumberTable</span><br><span class="line">  #11 = Utf8               main</span><br><span class="line">  #12 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #13 = Utf8               SourceFile</span><br><span class="line">  #14 = Utf8               Hello.java</span><br><span class="line">  #15 = NameAndType        #7:#8          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #16 = Class              #23            // java/lang/System</span><br><span class="line">  #17 = NameAndType        #24:#25        // out:Ljava/io/PrintStream;</span><br><span class="line">  #18 = Utf8               hello..</span><br><span class="line">  #19 = Class              #26            // java/io/PrintStream</span><br><span class="line">  #20 = NameAndType        #27:#28        // println:(Ljava/lang/String;)V</span><br><span class="line">  #21 = Utf8               Hello</span><br><span class="line">  #22 = Utf8               java/lang/Object</span><br><span class="line">  #23 = Utf8               java/lang/System</span><br><span class="line">  #24 = Utf8               out</span><br><span class="line">  #25 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #26 = Utf8               java/io/PrintStream</span><br><span class="line">  #27 = Utf8               println</span><br><span class="line">  #28 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">&#123;</span><br><span class="line">  public Hello();     //自带空的构造器 </span><br><span class="line">    descriptor: ()V     </span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0     //字节码的指令</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:      //行号   在程序或者线程的执行过程当中 它就能知道我这次运行到字节码里面的多少行 </span><br><span class="line">        line 1: 0</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=1, args_size=1</span><br><span class="line">         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: ldc           #3                  // String hello..</span><br><span class="line">         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">         8: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 3: 0</span><br><span class="line">        line 4: 8</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;Hello.java&quot;</span><br><span class="line">[double_happy@hadoop101 jvm]$</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">字节码</span><br><span class="line">	 aload_0    字节码指令   </span><br><span class="line">	  我们的应用程序最后拿到的是一堆的机器的指令  jvm就可以通过我们这些指令 它就知道你开发的应用程序想做一个什么事情 </span><br><span class="line">	  (java 代码一定会被编译成字节码 不同的字节码 干不同的事情）就是这一步.java =&gt;.class </span><br><span class="line"></span><br><span class="line">那么字节码和 程序计数器有什么关系呢？</span><br><span class="line">程序计数器：</span><br><span class="line">	记录当前线程目前执行到你的代码所对应的哪一条字节码指令</span><br><span class="line"></span><br><span class="line">多线程的情况下执行你的代码？</span><br><span class="line">	可能是多个线程并发的执行   那么多个线程共同执行的时候 就有可能出现</span><br><span class="line">	你每一个线程当前运行到的字节码指令行数是不一样的      多线程就是cpu抢占的问题</span><br><span class="line">	也就是说：每个线程都有自己的程序计数器      </span><br><span class="line">		专门用来记录我们所执行的这个线程现在到了哪一步了 </span><br><span class="line"></span><br><span class="line">所以：**</span><br><span class="line">程序计数器   属于  运行时数据区  的第二类       即  每个Thread独有</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191105194645327.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>2） Java Virtual Machine Stacks</strong></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Hello &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Hello hello = new Hello(); </span><br><span class="line">        hello.hello();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public  void hello()&#123;</span><br><span class="line">        String name = &quot;double_happy&quot;;   //局部变量     它的生命周期是在 这个hello函数里面的 </span><br><span class="line">        System.out.println(&quot;Hello: &quot; + name);  </span><br><span class="line">                </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">在main方法里面调用hello这个方法  我们在执行的过程当中 一定是有一个线程在 执行这段代码 去调用hello这个方法</span><br><span class="line"></span><br><span class="line">这里来说是 main这个线程  执行main方法里面的代码   </span><br><span class="line">那么对于 局部变量来说 它到时候会存在 jvm 数据运行区 的哪一个部分呢？</span><br><span class="line"></span><br><span class="line">存在Java Virtual Machine Stacks   jvm的一个栈</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Each Java Virtual Machine thread has a private Java Virtual Machine stack, created at the same time as the thread</span><br><span class="line">A Java Virtual Machine stack stores frames </span><br><span class="line"></span><br><span class="line">Java Virtual Machine Stacks  </span><br><span class="line">	1.方法里面的一些局部变量......   它就是存在 frames里的 </span><br><span class="line">	2.存的是frames: 栈帧</span><br><span class="line">	A new frame is created each time a method is invoked. 方法调用的时候被创建</span><br><span class="line">		对于上面的代码来说  main方法被调用 会创建一个 frame  hello方法被调用 也会创建一个  frame </span><br><span class="line">	A frame is destroyed when its method invocation completes  方法执行完毕的时候被销毁</span><br><span class="line">		</span><br><span class="line">	栈的特性 ：先进后出 </span><br><span class="line">	栈：main==&gt;hello    入栈：就是方法被调用的时候   出栈 ： 方法执行完毕的时候</span><br><span class="line">	可能会抛出的异常：StackOverflowError</span><br><span class="line">		这个很好理解 我们这些区 都是属于jvm运行时的区 每个区肯定都是有大小的 </span><br><span class="line">		你的线程计算时需要的大小 比我们 Java Virtual Machine Stacks   大 会抛出StackOverflowError 这个异常</span><br><span class="line">	</span><br><span class="line">	调用方法时，会为每个方法创建Frame，入栈</span><br><span class="line">	方法执行完毕后，Frame出栈</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191105202251465.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>3.Heap  堆</strong> ****重点</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">The Java Virtual Machine has a heap that is shared among all Java Virtual Machine threads</span><br><span class="line">所有线程共享的一块区域</span><br><span class="line"></span><br><span class="line">Heap ：</span><br><span class="line">	创建对象  是存在Heap里面的</span><br><span class="line">	可能会抛出的异常：OutOfMemoryError</span><br><span class="line">		什么场景下？你new出来的一些东西 最终放在heap里  比你默认的heap的大小大 </span><br><span class="line"></span><br><span class="line">eg：</span><br><span class="line">public class Hello &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Hello hello = new Hello();</span><br><span class="line">        hello.hello();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public  void hello()&#123;</span><br><span class="line">        String name = &quot;double_happy&quot;;</span><br><span class="line">        System.out.println(&quot;Hello: &quot; + name);</span><br><span class="line"></span><br><span class="line">        BasketballPlayer player = new BasketballPlayer(&quot;波兰名宿&quot;);</span><br><span class="line">        player.xxx();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class BasketballPlayer&#123;</span><br><span class="line">    String name;</span><br><span class="line">    </span><br><span class="line">    public BasketballPlayer()&#123;&#125;</span><br><span class="line">    public BasketballPlayer(String name)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;  </span><br><span class="line">    public void xxx()&#123;</span><br><span class="line">        System.out.println(name + &quot;发边线球....&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">在我们的hello方法里面 new 了一个对象  它是在堆里面的</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191105204643975.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>4.Method Area/Metaspace</strong> 方法区</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">The Java Virtual Machine has a method area that is shared among all Java Virtual Machine threads.</span><br><span class="line">所有线程共享的一块区域   1.8之后叫做 Metaspace</span><br><span class="line"></span><br><span class="line">Method Area/Metaspace里面存的是：</span><br><span class="line">	constant pool, 常量池</span><br><span class="line">	field and method data,  属性和方法数据</span><br><span class="line">	and the code for methods and constructors   方法代码和构造器代码</span><br><span class="line">	就是：</span><br><span class="line">		class文件加载进来放这里</span><br><span class="line">	可能会抛出的异常：OutOfMemoryError</span><br><span class="line">    什么场景下发生呢？</span><br></pre></td></tr></table></figure></div>
<p><strong>5.Native Method Stacks</strong>本地方法栈</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Native Method Stacks</span><br><span class="line">	native修饰的方法 是调用本地操作系统里面的方法 c语言或者 一些底层类库等等</span><br><span class="line">	可能会抛出的异常：StackOverflowError/OutOfMemoryError</span><br><span class="line"></span><br><span class="line">那么在调用 native修饰的方法 的时候 每个线程就会创建一个 本地方法栈</span><br><span class="line"></span><br><span class="line">所以方法分为两种：</span><br><span class="line">	native的      放在Native Method Stacks</span><br><span class="line">	非native的   放在 Java Virtual Machine Stacks</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191105210739239.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">还有一个区：是干嘛的呢？</span><br><span class="line">	Area: 不属于JVM   </span><br><span class="line">		eg： 通过nio 直接创建一些内存   就是堆外内存  这块是直接操作内存空间的 性能方面是好的 （Spark里面是有的  得调整堆外内存的空间的）</span><br><span class="line">			但是 如果不节制 会有可能会出现什么场景呢？</span><br><span class="line">			你大量的去这么干肯定是不行的  建议 你如果 去调用底层源码是可以的  自己的代码直接操作堆外内存是不合适的</span><br></pre></td></tr></table></figure></div>
<p><strong>总结</strong><br><img src="https://img-blog.csdnimg.cn/20191105213916315.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line">        String s1 = new String(&quot;double happy&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">问这句话产生了几个对象？</span><br><span class="line">	2个：哪两个呢？</span><br><span class="line">		1.s1   局部变量 存的是对象的地址  在stack里 </span><br><span class="line">		2.  new String     在Heap 里面  </span><br><span class="line">		3.  方法区里面的常量池 存一个对象 叫 double happy </span><br><span class="line"></span><br><span class="line">测试：</span><br><span class="line">	    public static void main(String[] args) &#123;</span><br><span class="line">        String s1 = new String(&quot;double happy&quot;);</span><br><span class="line">        String s2 = &quot;double happy&quot;;</span><br><span class="line"></span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">结果是false </span><br><span class="line">	因为s1 指向heap 里的 new String</span><br><span class="line">	s2 指向的method area 里的常量池里的 double happy</span><br><span class="line"></span><br><span class="line">测试：</span><br><span class="line">	    public static void main(String[] args) &#123;</span><br><span class="line">        String s1 = new String(&quot;double happy&quot;);</span><br><span class="line">        String s2 = &quot;double happy&quot;;</span><br><span class="line"></span><br><span class="line">        System.out.println(s1 == s2); //比较的是 引用地址</span><br><span class="line">        System.out.println(s1.equals(s2));// equals 比较的是内容</span><br><span class="line">    &#125;</span><br><span class="line">  结果是：</span><br><span class="line">  	false</span><br><span class="line">  	true</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191105215809121.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String s1 = &quot;双喜&quot;;</span><br><span class="line">        String s2 = &quot;男的&quot;;</span><br><span class="line">        String s3 = &quot;双喜&quot; + &quot;男的&quot;;</span><br><span class="line">        String s4 = s1 + s2;</span><br><span class="line">        String s5 = &quot;双喜男的&quot;;</span><br><span class="line">       String s6 = s4.intern();</span><br><span class="line">        System.out.println(s3 == s4); </span><br><span class="line">        System.out.println(s3 == s5);</span><br><span class="line">        System.out.println(s4 == s5);</span><br><span class="line">          System.out.println(s3 == s6);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">结果是：</span><br><span class="line">false</span><br><span class="line">true</span><br><span class="line">false</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191105220642702.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Returns a canonical representation for the string object.</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * A pool of strings, initially empty, is maintained privately by the</span><br><span class="line">     * class &#123;@code String&#125;.</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * When the intern method is invoked, if the pool already contains a</span><br><span class="line">     * string equal to this &#123;@code String&#125; object as determined by</span><br><span class="line">     * the &#123;@link #equals(Object)&#125; method, then the string from the pool is</span><br><span class="line">     * returned. Otherwise, this &#123;@code String&#125; object is added to the</span><br><span class="line">     * pool and a reference to this &#123;@code String&#125; object is returned.</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * It follows that for any two strings &#123;@code s&#125; and &#123;@code t&#125;,</span><br><span class="line">     * &#123;@code s.intern() == t.intern()&#125; is &#123;@code true&#125;</span><br><span class="line">     * if and only if &#123;@code s.equals(t)&#125; is &#123;@code true&#125;.</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * All literal strings and string-valued constant expressions are</span><br><span class="line">     * interned. String literals are defined in section 3.10.5 of the</span><br><span class="line">     * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.</span><br><span class="line">     *</span><br><span class="line">     * @return  a string that has the same contents as this string, but is</span><br><span class="line">     *          guaranteed to be from a pool of unique strings.</span><br><span class="line">     */</span><br><span class="line">    public native String intern();</span><br><span class="line">所以  intern  返回 string object. 真实的值 </span><br><span class="line">所以s6 指向的是 常量池里面的东西 </span><br><span class="line"></span><br><span class="line"> if and only if &#123;@code s.equals(t)&#125; is &#123;@code true&#125;.</span><br><span class="line"> 就是 equals相等  intern  就相等</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191105221230853.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">比较特殊：</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">   </span><br><span class="line">        Integer i1 = 50;</span><br><span class="line">        Integer i2 = 50;</span><br><span class="line"></span><br><span class="line">        System.out.println(i1 == i2);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">这个东西按常理来讲是 不等的对吧  包装类 一般是new 出来的 </span><br><span class="line">这是相等的</span><br><span class="line">先这样 </span><br><span class="line">	Integer i1 = new Integer(50);</span><br><span class="line">    Integer i2 = new Integer(50);</span><br><span class="line">这两个相等么？</span><br><span class="line">	false</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">对于基本类型 包装类型 都是放在 常量池里的 new出来的肯定不是放在池子里的哈 </span><br><span class="line"></span><br><span class="line">那么：</span><br><span class="line">	        Integer i1 = 150;</span><br><span class="line">            Integer i2 = 150;</span><br><span class="line">         相等么？  不等的</span><br><span class="line">         因为 池子里面 是有一个范围的   基本类型 包装类型都有</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns an &#123;@code Integer&#125; instance representing the specified</span><br><span class="line">     * &#123;@code int&#125; value.  If a new &#123;@code Integer&#125; instance is not</span><br><span class="line">     * required, this method should generally be used in preference to</span><br><span class="line">     * the constructor &#123;@link #Integer(int)&#125;, as this method is likely</span><br><span class="line">     * to yield significantly better space and time performance by</span><br><span class="line">     * caching frequently requested values.</span><br><span class="line">     *</span><br><span class="line">     * This method will always cache values in the range -128 to 127,</span><br><span class="line">     * inclusive, and may cache other values outside of this range.</span><br><span class="line">     *</span><br><span class="line">     * @param  i an &#123;@code int&#125; value.</span><br><span class="line">     * @return an &#123;@code Integer&#125; instance representing &#123;@code i&#125;.</span><br><span class="line">     * @since  1.5</span><br><span class="line">     */</span><br><span class="line">    public static Integer valueOf(int i) &#123;</span><br><span class="line">        if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">            return IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">        return new Integer(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line"> IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high  </span><br><span class="line">low = -128</span><br><span class="line">int h = 127</span><br><span class="line"></span><br><span class="line">明白了吧 </span><br><span class="line"></span><br><span class="line">但是 </span><br><span class="line">        Double d1 = 10.0D;</span><br><span class="line">        Double d2 = 10.0D;</span><br><span class="line">看源码你就知道了 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	    public static Double valueOf(double d) &#123;</span><br><span class="line">        return new Double(d);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">底层是 new   所以是不等的 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">所以 源码面前了无密码  源码用到的时候  还是要看的</span><br></pre></td></tr></table></figure></div>

      
    </div>
    
      <footer class="article-footer">
        完
      </footer>
    
  </div>
  
    
<nav id="article-nav">
  <div class="article-nav-block">
    
      <a href="/2017/11/15/JVM02/" id="article-nav-newer" class="article-nav-link-wrap">
        <strong class="article-nav-caption"></strong>
        <div class="article-nav-title">
          
            JVM02
          
        </div>
      </a>
    
  </div>
  <div class="article-nav-block">
    
  </div>
</nav>

    <link rel="stylesheet" href="/css/gitment.css"> 
<script src="/js/gitment.js"></script>

<div id="gitmentContainer"></div>

<script>
var gitment = new Gitment({
  owner: '',
  repo: '',
  oauth: {
    client_id: '',
    client_secret: '',
  },
})
gitment.render('gitmentContainer')
</script>

  
  
</article>
</section>
        <aside id="sidebar">
  
    <div class="widget-box">
  <div class="avatar-box">
    <img class="avatar" src="/images/default-avatar.jpg" title="图片来自网络"></img>
    <h3 class="avatar-name">
      
        DoubleHappy
      
    </h3>
    <p class="avatar-slogan">
      特别耐撕的大数据，资深的打酱油攻城狮。
    </p>
  </div>
</div>


  
    

  
    

  
    
  
    
  <div class="widget-box">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li></ul>
    </div>
  </div>

  
    
  <div class="widget-box">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/01/05/Azkaban%E8%B0%83%E5%BA%A6-double-happy/">Azkaban调度--double_happy</a>
          </li>
        
          <li>
            <a href="/2019/01/04/Zookeeper%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%9B%91%E6%8E%A7-Curator/">Zookeeper基本使用与监控(Curator)</a>
          </li>
        
          <li>
            <a href="/2018/04/17/SparkSQL-TextFile%E8%BE%93%E5%87%BA%E5%A4%9A%E5%88%97/">SparkSQL--TextFile输出多列</a>
          </li>
        
          <li>
            <a href="/2018/03/17/%E9%9B%85%E6%81%A9%E8%B5%84%E6%BA%90%E8%B0%83%E4%BC%98-double-happy/">雅恩资源调优---double_happy</a>
          </li>
        
          <li>
            <a href="/2018/02/22/SS04/">SS04</a>
          </li>
        
      </ul>
    </div>
  </div>

  
      <div class="widget-box">
    <h3 class="widget-title">友链</h3>
    <div class="widget">
      
        <a style="display: block;" href="https://sxwanggit126.github.io/" title target='_blank'
        >一路眼瞎</a>
      
    </div>
  </div>

  
</aside>
      </div>
      <footer id="footer">
  <div class="foot-box global-width">
    &copy; 2019 DoubleHappy &nbsp;&nbsp;
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    &nbsp;|&nbsp;主题 <a href="https://github.com/yiluyanxia/hexo-theme-antiquity" target="_blank" rel="noopener">antiquity</a>
    <br>
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span id="busuanzi_container_site_pv">不蒜子告之   阁下是第<span id="busuanzi_value_site_pv"></span>个访客</span>
  </div>
</footer>
      <script src="https://code.jquery.com/jquery-2.0.3.min.js"></script>
<script>
if (!window.jQuery) {
var script = document.createElement('script');
script.src = "/js/jquery-2.0.3.min.js";
document.body.write(script);
}
</script>


<script src="/js/script.js"></script>



    </div>
    <nav id="mobile-nav" class="mobile-nav-box">
  <div class="mobile-nav-img mobile-nav-top"></div>
  
    <a href="/archives" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
  <div class="mobile-nav-img  mobile-nav-bottom"></div>
</nav>    
  </div>
</body>
</html>