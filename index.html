<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>DoubleHappy or Jepson</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  
  <meta property="og:type" content="website">
<meta property="og:title" content="DoubleHappy or Jepson">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;index.html">
<meta property="og:site_name" content="DoubleHappy or Jepson">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="DoubleHappy or Jepson" type="application/atom+xml">
  
  
    <link rel="icon" href="/images/default-avatar.jpg">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/css/highlight.css">
</head>

<body>
  <div id="fullpage" class="mobile-nav-right">
    
      <div id="wrapper" title="图片来自网络">
    
    
      <header id="header">
  <div id="nav-toggle" class="nav-toggle"></div>
  <div class="head-box global-width">
    <nav class="nav-box nav-right">
      
        <a class="nav-item" href="/archives" title
        
        >首页</a>
      
        <a class="nav-item" href="/archives" title
        
        >归档</a>
      
    </nav>
  </div>
</header>
      <div id="middlecontent" title class="global-width sidebar-right">
        <section id="main">
  
    <article id="post-Azkaban调度-double-happy" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/05/Azkaban%E8%B0%83%E5%BA%A6-double-happy/">Azkaban调度--double_happy</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2019/01/05/Azkaban%E8%B0%83%E5%BA%A6-double-happy/" class="article-date">
  <time datetime="2019-01-05T11:56:15.000Z" itemprop="datePublished">2019-01-05</time>
</a>
    
    
  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <h2 id="安装Azkaban的坑"><a href="#安装Azkaban的坑" class="headerlink" title="安装Azkaban的坑"></a>安装Azkaban的坑</h2><p>当你使用单机模式运行azkaban时候：</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2019/09/23 22:06:53.626 +0800 ERROR [AzkabanWebServer] [Azkaban] Failed to start single server. Shutting down.</span><br><span class="line">java.io.IOException: Cannot find &apos;database.properties&apos; file in /home/double_happy/app/azkaban-solo-server/bin/sql/database.properties</span><br><span class="line">        at azkaban.database.AzkabanDatabaseSetup.loadDBProps(AzkabanDatabaseSetup.java:178)</span><br><span class="line">        at azkaban.database.AzkabanDatabaseSetup.loadTableInfo(AzkabanDatabaseSetup.java:102)</span><br><span class="line">        at azkaban.database.AzkabanDatabaseUpdater.runDatabaseUpdater(AzkabanDatabaseUpdater.java:82)</span><br><span class="line">        at azkaban.soloserver.AzkabanSingleServer.start(AzkabanSingleServer.java:93)</span><br><span class="line">        at azkaban.soloserver.AzkabanSingleServer.main(AzkabanSingleServer.java:58)</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">解决方式：</span><br><span class="line"></span><br><span class="line">必须使用bin/azkaban-solo-start.sh</span><br></pre></td></tr></table></figure></div>
<h2 id="调度解决多个作业之间的依赖关系"><a href="#调度解决多个作业之间的依赖关系" class="headerlink" title="调度解决多个作业之间的依赖关系"></a>调度解决多个作业之间的依赖关系</h2><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">nodes:</span><br><span class="line">  - name: platform_stat</span><br><span class="line">    type: command</span><br><span class="line">    dependsOn:</span><br><span class="line">      - etl</span><br><span class="line">    config:</span><br><span class="line">      command: sh /home/double_happy/ruozedata/project/hadoop-project/shell/platform_stat.sh 20190921</span><br><span class="line"></span><br><span class="line">  - name: etl</span><br><span class="line">    type: command</span><br><span class="line">    config:</span><br><span class="line">      command: sh /home/double_happy/ruozedata/project/hadoop-project/shell/etl.sh 20190921</span><br></pre></td></tr></table></figure></div>

<p><img src="https://img-blog.csdnimg.cn/20190923234758109.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">但是又一个问题呀：</span><br><span class="line">	shell 里的参数我可以不可以在 azkaban上面通过 parameters 传进来呢？</span><br><span class="line">	待续。。。。。。。</span><br></pre></td></tr></table></figure></div>
      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-Zookeeper基本使用与监控-Curator" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/04/Zookeeper%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%9B%91%E6%8E%A7-Curator/">Zookeeper基本使用与监控(Curator)</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2019/01/04/Zookeeper%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%9B%91%E6%8E%A7-Curator/" class="article-date">
  <time datetime="2019-01-04T11:46:26.000Z" itemprop="datePublished">2019-01-04</time>
</a>
    
    
  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <h2 id="1-Zookeeper基本使用"><a href="#1-Zookeeper基本使用" class="headerlink" title="1.Zookeeper基本使用"></a>1.Zookeeper基本使用</h2><p>(0)基本了解</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ZK核心术语</span><br><span class="line">    ZK的数据模型： 树形结构</span><br><span class="line">        /home/hadoop/app/ruozedata.txt</span><br><span class="line">    ZK每个节点znode，有一个唯一的路径标识</span><br><span class="line">    znode</span><br><span class="line">        临时的 ephemeral  临时znode下面不能有子节点</span><br><span class="line">            普通的</span><br><span class="line">            sequential</span><br><span class="line">        永久的 persistent</span><br><span class="line">            普通的</span><br><span class="line">            sequential  顺序编号目录节点</span><br><span class="line">    每个znode节点有各自的版本号</span><br><span class="line">    每个节点数据发生了变化，该节点的版本会加</span><br><span class="line">    ZK节点存储的数据量不宜过大，几K  *****</span><br><span class="line">    znode可以设置访问权限</span><br><span class="line">    znode可以设置watcher：当节点数据发生变化时，可以通过监视器获取</span><br></pre></td></tr></table></figure></div>

<p>(1)客户端命令行操作</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> 命令基本语法						功能描述</span><br><span class="line">help										显示所有操作命令</span><br><span class="line">ls path [watch]						使用 ls 命令来查看当前znode中所包含的内容</span><br><span class="line">ls2 path [watch]					查看当前节点数据并能看到更新次数等数据</span><br><span class="line">create									普通创建</span><br><span class="line">											-s  含有序列</span><br><span class="line">											-e  临时（重启或者超时消失）</span><br><span class="line">get path [watch]					获得节点的值</span><br><span class="line">set										设置节点的具体值</span><br><span class="line">stat										查看节点状态</span><br><span class="line">delete									删除节点</span><br><span class="line">rmr										递归删除节点</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">上面带[watch]  的是可以监控的  但是watcher zookeeper自身的api和命令都是一次性的 </span><br><span class="line">也就是用过了不能再用了（你懂的 ）</span><br><span class="line">解决办法 可以使用 curator 作为zkClient 来监控zookeeper的变化信息****</span><br><span class="line"></span><br><span class="line">eg：一些监控的种类</span><br><span class="line">watcher</span><br><span class="line">    zk中的watcher是一次性(*****)的</span><br><span class="line">    NodeCreated</span><br><span class="line">    NodeDataChanged</span><br><span class="line">    NodeDeleted</span><br><span class="line">    NodeChildrenChanged</span><br><span class="line">    </span><br><span class="line">四字命令 了解一下</span><br></pre></td></tr></table></figure></div>
<p>(2)CuratorApi<br>Curator是Netflix公司开源的一套zookeeper客户端框架，解决了很多Zookeeper客户端非常底层的细节开发工作，包括连接重连、反复注册Watcher和NodeExistsException异常等等。</p>
<p>版本选择：</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这里我们的zookeeper的版本是3.4.x，所以api开发的时候 maven不同版本会用不同</span><br><span class="line">https://curator.apache.org/zk-compatibility.html      curator官网</span><br></pre></td></tr></table></figure></div>
<p>curator api 官网 ：<a href="https://curator.apache.org/curator-framework/index.html" target="_blank" rel="noopener">https://curator.apache.org/curator-framework/index.html</a></p>
<p>可以去官网上去学习，可以结合zookeeper api 来学习 curator api （突然手里来活了 写不了了 ）<br>这里可以借鉴：<br>    <a href="http://www.throwable.club/2018/12/16/zookeeper-curator-usage/#%E5%89%8D%E6%8F%90" target="_blank" rel="noopener">http://www.throwable.club/2018/12/16/zookeeper-curator-usage/#%E5%89%8D%E6%8F%90</a><br>英文不好的小伙伴 ，这篇文章很好的介绍Curator 使用 。</p>
<p>还有我的小组长的博客：<br><a href="https://liverrrr.fun/archives/quickstart_zookeeper" target="_blank" rel="noopener">https://liverrrr.fun/archives/quickstart_zookeeper</a><br>可以很好的学习 。</p>

      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-SparkSQL-TextFile输出多列" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/17/SparkSQL-TextFile%E8%BE%93%E5%87%BA%E5%A4%9A%E5%88%97/">SparkSQL--TextFile输出多列</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2018/04/17/SparkSQL-TextFile%E8%BE%93%E5%87%BA%E5%A4%9A%E5%88%97/" class="article-date">
  <time datetime="2018-04-17T12:14:56.000Z" itemprop="datePublished">2018-04-17</time>
</a>
    
    
  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">这个问题我在SparkSQL001里面提出过这个问题 </span><br><span class="line">解决的方法有很多 </span><br><span class="line">我看了很多同组的同学解决思路  大部分是用RDD函数式编程解决的 </span><br><span class="line"></span><br><span class="line">但是我觉得没有必要那么做 </span><br><span class="line"></span><br><span class="line">曾经我在工作的时候 有个人问过我这个问题 我当时解决过  </span><br><span class="line"></span><br><span class="line">就在刚刚我查看我的博客时候 决定把我的解决办法给总结一下</span><br></pre></td></tr></table></figure></div>
<p><strong>数据格式和内容</strong><br><img src="https://img-blog.csdnimg.cn/20191112214900905.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">object TextFileApp &#123;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    val spark = SparkSession.builder().appName(&quot;TextFileApp&quot;).master(&quot;local[2]&quot;).enableHiveSupport().getOrCreate()</span><br><span class="line"></span><br><span class="line">    var df = spark.read.format(&quot;text&quot;).load(&quot;file:////Users/double_happy/Downloads/f16/data/text/man.txt&quot;)</span><br><span class="line"></span><br><span class="line">    df.printSchema()</span><br><span class="line">    df.show()</span><br><span class="line"></span><br><span class="line">    df = df.withColumn(&quot;data&quot;,UDFUtils.string2fields(df.col(&quot;value&quot;)))</span><br><span class="line">    df = df.withColumn(&quot;id&quot;,df.col(&quot;data.id&quot;))</span><br><span class="line">    df = df.withColumn(&quot;age&quot;,df.col(&quot;data.age&quot;))</span><br><span class="line"></span><br><span class="line">    df.printSchema()</span><br><span class="line">    df.show()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果是：</span><br><span class="line">root</span><br><span class="line"> |-- value: string (nullable = true)</span><br><span class="line"></span><br><span class="line">+---------------+</span><br><span class="line">|          value|</span><br><span class="line">+---------------+</span><br><span class="line">|double_happy,25|</span><br><span class="line">|      Kairis,25|</span><br><span class="line">|        Kite,32|</span><br><span class="line">+---------------+</span><br><span class="line"></span><br><span class="line">root</span><br><span class="line"> |-- value: string (nullable = true)</span><br><span class="line"> |-- data: struct (nullable = true)</span><br><span class="line"> |    |-- id: string (nullable = true)</span><br><span class="line"> |    |-- age: integer (nullable = false)</span><br><span class="line"> |-- id: string (nullable = true)</span><br><span class="line"> |-- age: integer (nullable = true)</span><br><span class="line"></span><br><span class="line">+---------------+------------------+------------+---+</span><br><span class="line">|          value|              data|          id|age|</span><br><span class="line">+---------------+------------------+------------+---+</span><br><span class="line">|double_happy,25|[double_happy, 25]|double_happy| 25|</span><br><span class="line">|      Kairis,25|      [Kairis, 25]|      Kairis| 25|</span><br><span class="line">|        Kite,32|        [Kite, 32]|        Kite| 32|</span><br><span class="line">+---------------+------------------+------------+---+</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">object UDFUtils &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  import org.apache.spark.sql.functions._</span><br><span class="line"></span><br><span class="line">  def string2fields=udf((data:String)=&gt;&#123;</span><br><span class="line"></span><br><span class="line">    DataFormat(data.split(&quot;,&quot;)(0),data.split(&quot;,&quot;)(1).toInt)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  case class DataFormat(id:String,age:Int)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">上面的解决办法明白了吗 ？</span><br><span class="line">定义一个udf函数即可 </span><br><span class="line"></span><br><span class="line">这个代码同时也解决了 struct类型的你应该怎么处理 </span><br><span class="line">之前的文章也提到过这个问题 这里给解决了</span><br></pre></td></tr></table></figure></div>

      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-雅恩资源调优-double-happy" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/17/%E9%9B%85%E6%81%A9%E8%B5%84%E6%BA%90%E8%B0%83%E4%BC%98-double-happy/">雅恩资源调优---double_happy</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2018/03/17/%E9%9B%85%E6%81%A9%E8%B5%84%E6%BA%90%E8%B0%83%E4%BC%98-double-happy/" class="article-date">
  <time datetime="2018-03-17T12:13:41.000Z" itemprop="datePublished">2018-03-17</time>
</a>
    
    
  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一台机器能运行多少个container 到底是由谁决定的 ？</span><br></pre></td></tr></table></figure></div>
<p><a href="https://hadoop.apache.org/docs/stable/hadoop-yarn/hadoop-yarn-common/yarn-default.xml" target="_blank" rel="noopener">官网</a></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">生产上一台机器：</span><br><span class="line">	48G物理内存  8core--》16vcore</span><br><span class="line">	Linux系统本身要占内存+空留:  20% =9.6G</span><br><span class="line">	剩余: 80% =38.4G=38G    这些留给大数据组件</span><br><span class="line">	</span><br><span class="line">DN进程: 生产4G  </span><br><span class="line">	1000m</span><br><span class="line">	hadoop-env.sh</span><br><span class="line">	HADOOP_NAMENODE_OPTS=-Xmx1024m</span><br><span class="line">	HADOOP_DATANODE_OPTS=-Xmx1024m</span><br><span class="line">	</span><br><span class="line">NM进程: 生产4G</span><br><span class="line">	yarn-env.sh</span><br><span class="line">	export YARN_RESOURCEMANAGER_HEAPSIZE=1024</span><br><span class="line">	export YARN_NODEMANAGER_HEAPSIZE=1024</span><br><span class="line">NM 与DN 部署在同一台机器上： 数据本地化</span><br><span class="line"></span><br><span class="line">NN RM 经常性部署同一台  说白了 集群节点少</span><br><span class="line"></span><br><span class="line">*****</span><br><span class="line">资源内存: 38G-4-4=30G   这就是运行container容器 的 </span><br><span class="line">yarn.nodemanager.resource.memory-mb   30*1024   总的  </span><br><span class="line">默认配置</span><br><span class="line">yarn.scheduler.minimum-allocation-mb  1024     给容器最小的 内存     生产上 2g</span><br><span class="line">yarn.scheduler.maximum-allocation-mb  8192   给容器最大的 内存       生产上 30g</span><br><span class="line"></span><br><span class="line">按照官网默认的算：</span><br><span class="line">30G 30G/1G=30个container </span><br><span class="line">30G 30/8G=3个container ...6G    这里面 30这个值不好  30/8   还剩6g  32g 比较好 </span><br><span class="line">30个~3个</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191108162536413.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>内存：</strong></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">生产一: </span><br><span class="line">yarn.nodemanager.resource.memory-mb   30G</span><br><span class="line">yarn.scheduler.minimum-allocation-mb  2G</span><br><span class="line">yarn.scheduler.maximum-allocation-mb  30G</span><br><span class="line"></span><br><span class="line">2g--》  yarn给你分配的时候先给你最小的  当计算过程中发现内存不够了 yarn会给你长一个g</span><br><span class="line"></span><br><span class="line">15个~1个</span><br><span class="line"></span><br><span class="line">30G 是不是太大了 根据你作业来分的  你作业就是需要30g 你只能给30g</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">生产二：</span><br><span class="line">yarn.nodemanager.resource.memory-mb   32G</span><br><span class="line">yarn.scheduler.minimum-allocation-mb  2G</span><br><span class="line">yarn.scheduler.maximum-allocation-mb  8G</span><br><span class="line"></span><br><span class="line">16c~4c</span><br><span class="line"></span><br><span class="line">如果container  memory oom      那么调大yarn.scheduler.maximum-allocation-mb 这个 先把oom这个进程kill掉</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">生产三:</span><br><span class="line">256G:</span><br><span class="line"></span><br><span class="line">yarn.nodemanager.resource.memory-mb   168G</span><br><span class="line">yarn.scheduler.minimum-allocation-mb  4G</span><br><span class="line">yarn.scheduler.maximum-allocation-mb  24G</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">container p memory oom kill</span><br><span class="line"></span><br><span class="line">生产默认 </span><br><span class="line">yarn.nodemanager.pmem-check-enabled	true       //物理内存</span><br><span class="line">yarn.nodemanager.vmem-check-enabled	true      </span><br><span class="line">yarn.nodemanager.vmem-pmem-ratio	2.1     //物理内存 和虚拟内存的比例 </span><br><span class="line"></span><br><span class="line">物理内存 1m  虚拟内存 2.1m</span><br><span class="line"></span><br><span class="line">这两个内存超了 都会抱 oom</span><br></pre></td></tr></table></figure></div>
<p><strong>cpu</strong></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CPU:</span><br><span class="line">yarn.nodemanager.resource.cpu-vcores	 12</span><br><span class="line">yarn.scheduler.minimum-allocation-vcores  1</span><br><span class="line">yarn.scheduler.maximum-allocation-vcores  4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">container: </span><br><span class="line">	memory 16c~4c</span><br><span class="line">	vcores 12c~3c </span><br><span class="line"></span><br><span class="line">所以这个两个变量</span><br><span class="line">cpu 和 mem  你应该怎么调 才能 资源最大化呢?  </span><br><span class="line">	到底是根据mem 来算 还是 core来算呢？ 已加密</span><br></pre></td></tr></table></figure></div>

      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-SS04" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/22/SS04/">SS04</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2018/02/22/SS04/" class="article-date">
  <time datetime="2018-02-22T12:12:50.000Z" itemprop="datePublished">2018-02-22</time>
</a>
    
    
  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">之前的ss程序都是运行在idea</span><br><span class="line">那么如何提交到服务器上运行呢？</span><br><span class="line">  演示：</span><br><span class="line">  一步一步来  先不管理offset 把代码提交到yarn上 把wc统计出来</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">数据从Kafka过来然后 ss消费到 把wc统计出来：</span><br><span class="line"></span><br><span class="line">object StreamingKakfaDirectYarnApp &#123;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line"></span><br><span class="line">    //参数从外面传进 来    topics groupId brokers</span><br><span class="line">    if(args.size != 3)&#123;</span><br><span class="line">      System.err.println(&quot;Usage:StreamingKakfaDirectYarnApp &lt;brokers&gt; &lt;topic&gt; &lt;groupId&gt;&quot;)</span><br><span class="line">      System.exit(-1)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    val Array(brokers,topic,groupId) = args</span><br><span class="line">    </span><br><span class="line">    val sparkConf: SparkConf = new SparkConf()</span><br><span class="line">    val ssc =new StreamingContext(sparkConf,Seconds(10))</span><br><span class="line">   // val ssc = ContextUtils.getStreamingContext(this.getClass.getSimpleName, 10)</span><br><span class="line"></span><br><span class="line">    val kafkaParams = Map[String, Object](</span><br><span class="line">      &quot;bootstrap.servers&quot; -&gt; brokers, //Kafka地址</span><br><span class="line">      &quot;key.deserializer&quot; -&gt; classOf[StringDeserializer], //反序列化  接收端是反序列化   数据发送是要序列化</span><br><span class="line">      &quot;value.deserializer&quot; -&gt; classOf[StringDeserializer],</span><br><span class="line">      &quot;group.id&quot; -&gt; groupId,</span><br><span class="line">      &quot;auto.offset.reset&quot; -&gt; &quot;earliest&quot;, //偏移量 从哪开始</span><br><span class="line">      &quot;enable.auto.commit&quot; -&gt; (false: java.lang.Boolean) //自动提交么？ 选择不自动提交  手工来管理</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    val topics = Array(topic)</span><br><span class="line">    val stream = KafkaUtils.createDirectStream[String, String](</span><br><span class="line">      ssc,</span><br><span class="line">      PreferConsistent, //数据尽量均匀分布到各个executor上去</span><br><span class="line">      Subscribe[String, String](topics, kafkaParams) //固定写法</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //TODO...业务逻辑</span><br><span class="line">    val result: DStream[(String, Int)] = stream.map(_.value()).</span><br><span class="line">      flatMap(_.split(&quot;,&quot;))</span><br><span class="line">      .map((_, 1)).reduceByKey(_ + _)</span><br><span class="line"></span><br><span class="line">    result.print()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ssc.start()</span><br><span class="line">    ssc.awaitTermination()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">idea测试结果：</span><br><span class="line">Usage:StreamingKakfaDirectYarnApp &lt;brokers&gt; &lt;topic&gt; &lt;groupId&gt;</span><br><span class="line"></span><br><span class="line">注意：idea里怎么把参数传进去呢？</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191103144003315.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20191103144048102.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">运行结果：</span><br><span class="line">-------------------------------------------</span><br><span class="line">Time: 1572763410000 ms</span><br><span class="line">-------------------------------------------</span><br><span class="line">(d,19)</span><br><span class="line">(b,18)</span><br><span class="line">(f,21)</span><br><span class="line">(e,17)</span><br><span class="line">(a,24)</span><br><span class="line">(c,21)</span><br><span class="line"></span><br><span class="line">-------------------------------------------</span><br><span class="line">Time: 1572763420000 ms</span><br><span class="line">-------------------------------------------</span><br><span class="line"></span><br><span class="line">-------------------------------------------</span><br><span class="line">Time: 1572763430000 ms</span><br><span class="line">-------------------------------------------</span><br><span class="line"></span><br><span class="line">说明本地改造完成 那么我们打包上传到服务器上运行</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">提交命令：</span><br><span class="line">./spark-submit \</span><br><span class="line">--master local[2] \</span><br><span class="line">--name StreamingKakfaDirectYarnApp \</span><br><span class="line">--class com.ruozedata.spark.ss04.StreamingKakfaDirectYarnApp \</span><br><span class="line">/home/double_happy/lib/spark-core-1.0.jar \</span><br><span class="line">hadoop101:9092,hadoop101:9093,hadoop101:9094 double_happy_offset double_happy_group3</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">[double_happy@hadoop101 bin]$ ./spark-submit \</span><br><span class="line">&gt; --master local[2] \</span><br><span class="line">&gt; --name StreamingKakfaDirectYarnApp \</span><br><span class="line">&gt; --class com.ruozedata.spark.ss04.StreamingKakfaDirectYarnApp \</span><br><span class="line">&gt; /home/double_happy/lib/spark-core-1.0.jar \</span><br><span class="line">&gt; hadoop101:9092,hadoop101:9093,hadoop101:9094 double_happy_offset double_happy_group3</span><br><span class="line">19/11/03 15:08:42 WARN NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicable</span><br><span class="line">19/11/03 15:08:42 INFO SparkContext: Running Spark version 2.4.4</span><br><span class="line">19/11/03 15:08:43 INFO SparkContext: Submitted application: StreamingKakfaDirectYarnApp</span><br><span class="line">19/11/03 15:08:43 INFO SecurityManager: Changing view acls to: double_happy</span><br><span class="line">19/11/03 15:08:43 INFO SecurityManager: Changing modify acls to: double_happy</span><br><span class="line">19/11/03 15:08:43 INFO SecurityManager: Changing view acls groups to: </span><br><span class="line">19/11/03 15:08:43 INFO SecurityManager: Changing modify acls groups to: </span><br><span class="line">19/11/03 15:08:43 INFO SecurityManager: SecurityManager: authentication disabled; ui acls disabled; users  with view permissions: Set(double_happy); groups with view permissions: Set(); users  with modify permissions: Set(double_happy); groups with modify permissions: Set()</span><br><span class="line">19/11/03 15:08:43 INFO Utils: Successfully started service &apos;sparkDriver&apos; on port 40978.</span><br><span class="line">19/11/03 15:08:43 INFO SparkEnv: Registering MapOutputTracker</span><br><span class="line">19/11/03 15:08:43 INFO SparkEnv: Registering BlockManagerMaster</span><br><span class="line">19/11/03 15:08:43 INFO BlockManagerMasterEndpoint: Using org.apache.spark.storage.DefaultTopologyMapper for getting topology information</span><br><span class="line">19/11/03 15:08:43 INFO BlockManagerMasterEndpoint: BlockManagerMasterEndpoint up</span><br><span class="line">19/11/03 15:08:43 INFO DiskBlockManager: Created local directory at /tmp/blockmgr-d01d319f-1fe4-4025-bcf4-418a06809ccc</span><br><span class="line">19/11/03 15:08:43 INFO MemoryStore: MemoryStore started with capacity 366.3 MB</span><br><span class="line">19/11/03 15:08:43 INFO SparkEnv: Registering OutputCommitCoordinator</span><br><span class="line">19/11/03 15:08:43 INFO Utils: Successfully started service &apos;SparkUI&apos; on port 4040.</span><br><span class="line">19/11/03 15:08:43 INFO SparkUI: Bound SparkUI to 0.0.0.0, and started at http://hadoop101:4040</span><br><span class="line">19/11/03 15:08:43 INFO SparkContext: Added JAR file:/home/double_happy/lib/spark-core-1.0.jar at spark://hadoop101:40978/jars/spark-core-1.0.jar with timestamp 1572764923743</span><br><span class="line">19/11/03 15:08:43 INFO Executor: Starting executor ID driver on host localhost</span><br><span class="line">19/11/03 15:08:43 INFO Utils: Successfully started service &apos;org.apache.spark.network.netty.NettyBlockTransferService&apos; on port 33748.</span><br><span class="line">19/11/03 15:08:43 INFO NettyBlockTransferService: Server created on hadoop101:33748</span><br><span class="line">19/11/03 15:08:43 INFO BlockManager: Using org.apache.spark.storage.RandomBlockReplicationPolicy for block replication policy</span><br><span class="line">19/11/03 15:08:43 INFO BlockManagerMaster: Registering BlockManager BlockManagerId(driver, hadoop101, 33748, None)</span><br><span class="line">19/11/03 15:08:43 INFO BlockManagerMasterEndpoint: Registering block manager hadoop101:33748 with 366.3 MB RAM, BlockManagerId(driver, hadoop101, 33748, None)</span><br><span class="line">19/11/03 15:08:43 INFO BlockManagerMaster: Registered BlockManager BlockManagerId(driver, hadoop101, 33748, None)</span><br><span class="line">19/11/03 15:08:43 INFO BlockManager: Initialized BlockManager: BlockManagerId(driver, hadoop101, 33748, None)</span><br><span class="line">19/11/03 15:08:45 INFO EventLoggingListener: Logging events to hdfs://hadoop101:8020/spark_directory/local-1572764923782</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.NoClassDefFoundError: org/apache/kafka/common/serialization/StringDeserializer</span><br><span class="line">        at com.ruozedata.spark.ss04.StreamingKakfaDirectYarnApp$.main(StreamingKakfaDirectYarnApp.scala:36)</span><br><span class="line">        at com.ruozedata.spark.ss04.StreamingKakfaDirectYarnApp.main(StreamingKakfaDirectYarnApp.scala)</span><br><span class="line">        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">        at java.lang.reflect.Method.invoke(Method.java:497)</span><br><span class="line">        at org.apache.spark.deploy.JavaMainApplication.start(SparkApplication.scala:52)</span><br><span class="line">        at org.apache.spark.deploy.SparkSubmit.org$apache$spark$deploy$SparkSubmit$$runMain(SparkSubmit.scala:845)</span><br><span class="line">        at org.apache.spark.deploy.SparkSubmit.doRunMain$1(SparkSubmit.scala:161)</span><br><span class="line">        at org.apache.spark.deploy.SparkSubmit.submit(SparkSubmit.scala:184)</span><br><span class="line">        at org.apache.spark.deploy.SparkSubmit.doSubmit(SparkSubmit.scala:86)</span><br><span class="line">        at org.apache.spark.deploy.SparkSubmit$$anon$2.doSubmit(SparkSubmit.scala:920)</span><br><span class="line">        at org.apache.spark.deploy.SparkSubmit$.main(SparkSubmit.scala:929)</span><br><span class="line">        at org.apache.spark.deploy.SparkSubmit.main(SparkSubmit.scala)</span><br><span class="line">Caused by: java.lang.ClassNotFoundException: org.apache.kafka.common.serialization.StringDeserializer</span><br><span class="line">        at java.net.URLClassLoader.findClass(URLClassLoader.java:381)</span><br><span class="line">        at java.lang.ClassLoader.loadClass(ClassLoader.java:424)</span><br><span class="line">        at java.lang.ClassLoader.loadClass(ClassLoader.java:357)</span><br><span class="line">        ... 14 more</span><br><span class="line">19/11/03 15:08:45 INFO SparkContext: Invoking stop() from shutdown hook</span><br><span class="line">19/11/03 15:08:45 INFO SparkUI: Stopped Spark web UI at http://hadoop101:4040</span><br><span class="line">19/11/03 15:08:45 INFO MapOutputTrackerMasterEndpoint: MapOutputTrackerMasterEndpoint stopped!</span><br><span class="line">19/11/03 15:08:45 INFO MemoryStore: MemoryStore cleared</span><br><span class="line">19/11/03 15:08:45 INFO BlockManager: BlockManager stopped</span><br><span class="line">19/11/03 15:08:46 INFO BlockManagerMaster: BlockManagerMaster stopped</span><br><span class="line">19/11/03 15:08:46 INFO OutputCommitCoordinator$OutputCommitCoordinatorEndpoint: OutputCommitCoordinator stopped!</span><br><span class="line">19/11/03 15:08:46 INFO SparkContext: Successfully stopped SparkContext</span><br><span class="line">19/11/03 15:08:46 INFO ShutdownHookManager: Shutdown hook called</span><br><span class="line">19/11/03 15:08:46 INFO ShutdownHookManager: Deleting directory /tmp/spark-6ffb645c-d7fd-44e8-b0e5-256cae7b11ea</span><br><span class="line">19/11/03 15:08:46 INFO ShutdownHookManager: Deleting directory /tmp/spark-8a31f335-3d75-4c59-b7a5-c5bf023d1265</span><br><span class="line">[double_happy@hadoop101 bin]$</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">注意：</span><br><span class="line">1. Exception in thread &quot;main&quot; java.lang.NoClassDefFoundError: org/apache/kafka/common/serialization/StringDeserializer</span><br><span class="line">为什么呢？ 在idea里都可以的 </span><br><span class="line">StringDeserializer 类是在</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.spark&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spark-streaming-kafka-0-10_2.11&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;spark.version&#125;&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">这个包里面的</span><br><span class="line"></span><br><span class="line">而这个包Spark本身是没有的 是我们额外加进来的喽 </span><br><span class="line">那么这个包没有在服务器上 为什么该怎么办呢？ 看看官网怎么说的</span><br></pre></td></tr></table></figure></div>
<p><a href="http://spark.apache.org/docs/latest/streaming-kafka-0-10-integration.html#deploying" target="_blank" rel="noopener">Deploying</a>：部署<br>As with any Spark applications, spark-submit is used to launch your application.</p>
<p>For Scala and Java applications, if you are using SBT or Maven for project management, <strong>then package spark-streaming-kafka-0-10_2.12 and its dependencies into the application JAR.</strong> <strong>Make sure spark-core_2.12 and spark-streaming_2.12 are marked as provided dependencies as those are already present in a Spark installation.</strong> Then use spark-submit to launch your application (see Deploying section in the main programming guide).<br>这种方式不好 换一个</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">因为需要把这个spark-streaming-kafka-0-10_2.11包 传到服务器上</span><br><span class="line">./spark-submit --help  查查 可以加maven 的依赖  怎么加呢？</span><br><span class="line"></span><br><span class="line"> --packages                  Comma-separated list of maven coordinates of jars to include</span><br><span class="line">                              on the driver and executor classpaths. Will search the local</span><br><span class="line">                              maven repo, then maven central and any additional remote</span><br><span class="line">                              repositories given by --repositories. The format for the</span><br><span class="line">                              coordinates should be groupId:artifactId:version.</span><br><span class="line"></span><br><span class="line">这个参数 可以指向 maven的一些jar包 **** </span><br><span class="line">修改提交命令：</span><br><span class="line">./spark-submit \</span><br><span class="line">--master local[2] \</span><br><span class="line">--name StreamingKakfaDirectYarnApp \</span><br><span class="line"> --packages org.apache.spark:spark-streaming-kafka-0-10_2.11:2.4.4 \</span><br><span class="line">--class com.ruozedata.spark.ss04.StreamingKakfaDirectYarnApp \</span><br><span class="line">/home/double_happy/lib/spark-core-1.0.jar \</span><br><span class="line">hadoop101:9092,hadoop101:9093,hadoop101:9094 double_happy_offset double_happy_group3</span><br><span class="line"></span><br><span class="line">但是这个东西 需要联网 不能联网是不行的 一会看日志就清除了 它需要联网去下载 maven依赖</span><br><span class="line"></span><br><span class="line">[double_happy@hadoop101 bin]$ ./spark-submit --master local[2] --name StreamingKakfaDirectYarnApp  --packageg.apache.spark:spark-streaming-kafka-0-10_2.11:2.4.4 --class com.ruozedata.spark.ss04.StreamingKakfaDirectYarnApp /home/double_happy/lib/spark-core-1.0.jar hadoop101:9092,hadoop101:9093,hadoop101:9094 double_happy_offset double_happy_group3</span><br><span class="line">Ivy Default Cache set to: /home/double_happy/.ivy2/cache</span><br><span class="line">The jars for the packages stored in: /home/double_happy/.ivy2/jars</span><br><span class="line">:: loading settings :: url = jar:file:/home/double_happy/app/spark-2.4.4-bin-2.6.0-cdh5.15.1/jars/ivy-2.4.0.jar!/org/apache/ivy/core/settings/ivysettings.xml</span><br><span class="line">org.apache.spark#spark-streaming-kafka-0-10_2.11 added as a dependency</span><br><span class="line">:: resolving dependencies :: org.apache.spark#spark-submit-parent-c0781f34-3101-4762-8694-9aa38b463184;1.0</span><br><span class="line">        confs: [default]</span><br><span class="line">        found org.apache.spark#spark-streaming-kafka-0-10_2.11;2.4.4 in central</span><br><span class="line">        found org.apache.kafka#kafka-clients;2.0.0 in central</span><br><span class="line">        found org.lz4#lz4-java;1.4.0 in central</span><br><span class="line">        found org.xerial.snappy#snappy-java;1.1.7.3 in central</span><br><span class="line">        found org.slf4j#slf4j-api;1.7.16 in central</span><br><span class="line">        found org.spark-project.spark#unused;1.0.0 in central</span><br><span class="line">:: resolution report :: resolve 496ms :: artifacts dl 9ms</span><br><span class="line">        :: modules in use:</span><br><span class="line">        org.apache.kafka#kafka-clients;2.0.0 from central in [default]</span><br><span class="line">        org.apache.spark#spark-streaming-kafka-0-10_2.11;2.4.4 from central in [default]</span><br><span class="line">        org.lz4#lz4-java;1.4.0 from central in [default]</span><br><span class="line">        org.slf4j#slf4j-api;1.7.16 from central in [default]</span><br><span class="line">        org.spark-project.spark#unused;1.0.0 from central in [default]</span><br><span class="line">        org.xerial.snappy#snappy-java;1.1.7.3 from central in [default]</span><br><span class="line">        ---------------------------------------------------------------------</span><br><span class="line">        |                  |            modules            ||   artifacts   |</span><br><span class="line">        |       conf       | number| search|dwnlded|evicted|| number|dwnlded|</span><br><span class="line">        ---------------------------------------------------------------------</span><br><span class="line">        |      default     |   6   |   0   |   0   |   0   ||   6   |   0   |</span><br><span class="line">        ---------------------------------------------------------------------</span><br><span class="line">:: retrieving :: org.apache.spark#spark-submit-parent-c0781f34-3101-4762-8694-9aa38b463184</span><br><span class="line">        confs: [default]</span><br><span class="line">        0 artifacts copied, 6 already retrieved (0kB/10ms)</span><br><span class="line"></span><br><span class="line">我截取了一小部分日志 你看 第一次需要下载maven依赖的  </span><br><span class="line">所以这个 参数也有弊端的  (毕竟公司的服务器是不可能连接外网的  )</span><br><span class="line"></span><br><span class="line">还有其他的方式可以解决 一会介绍</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191103152748544.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="结果"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">那么刚刚packages  有小问题  那么怎么办呢 ？</span><br><span class="line"></span><br><span class="line">1.先把spark-streaming-kafka-0-10_2.11依赖包 上传到服务器上 </span><br><span class="line">2.通过--jars 来指定</span><br><span class="line"></span><br><span class="line">./spark-submit \</span><br><span class="line">--master local[2] \</span><br><span class="line">--name StreamingKakfaDirectYarnApp \</span><br><span class="line">--jars /home/double_happy/lib/spark-streaming-kafka-0-10_2.11-2.4.4.jar \</span><br><span class="line">--class com.ruozedata.spark.ss04.StreamingKakfaDirectYarnApp \</span><br><span class="line">/home/double_happy/lib/spark-core-1.0.jar \</span><br><span class="line">hadoop101:9092,hadoop101:9093,hadoop101:9094 double_happy_offset double_happy_group3</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">[double_happy@hadoop101 bin]$ ./spark-submit \</span><br><span class="line">&gt; --master local[2] \</span><br><span class="line">&gt; --name StreamingKakfaDirectYarnApp \</span><br><span class="line">&gt; --jars /home/double_happy/lib/spark-streaming-kafka-0-10_2.11-2.4.4.jar \</span><br><span class="line">&gt; --class com.ruozedata.spark.ss04.StreamingKakfaDirectYarnApp \</span><br><span class="line">&gt; /home/double_happy/lib/spark-core-1.0.jar \</span><br><span class="line">&gt; hadoop101:9092,hadoop101:9093,hadoop101:9094 double_happy_offset double_happy_group3</span><br><span class="line">19/11/03 15:38:38 WARN NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicable</span><br><span class="line">19/11/03 15:38:39 INFO SparkContext: Running Spark version 2.4.4</span><br><span class="line">19/11/03 15:38:39 INFO SparkContext: Submitted application: StreamingKakfaDirectYarnApp</span><br><span class="line">19/11/03 15:38:39 INFO SecurityManager: Changing view acls to: double_happy</span><br><span class="line">19/11/03 15:38:39 INFO SecurityManager: Changing modify acls to: double_happy</span><br><span class="line">19/11/03 15:38:39 INFO SecurityManager: Changing view acls groups to: </span><br><span class="line">19/11/03 15:38:39 INFO SecurityManager: Changing modify acls groups to: </span><br><span class="line">19/11/03 15:38:39 INFO SecurityManager: SecurityManager: authentication disabled; ui acls disabled; users  with view permissions: Set(double_happy); groups with view permissions: Set(); users  with modify permissions: Set(double_happy); groups with modify permissions: Set()</span><br><span class="line">19/11/03 15:38:39 INFO Utils: Successfully started service &apos;sparkDriver&apos; on port 45422.</span><br><span class="line">19/11/03 15:38:39 INFO SparkEnv: Registering MapOutputTracker</span><br><span class="line">19/11/03 15:38:39 INFO SparkEnv: Registering BlockManagerMaster</span><br><span class="line">19/11/03 15:38:39 INFO BlockManagerMasterEndpoint: Using org.apache.spark.storage.DefaultTopologyMapper for getting topology information</span><br><span class="line">19/11/03 15:38:39 INFO BlockManagerMasterEndpoint: BlockManagerMasterEndpoint up</span><br><span class="line">19/11/03 15:38:39 INFO DiskBlockManager: Created local directory at /tmp/blockmgr-ed285e0b-aab6-4fa6-a09d-6776f02d7a71</span><br><span class="line">19/11/03 15:38:39 INFO MemoryStore: MemoryStore started with capacity 366.3 MB</span><br><span class="line">19/11/03 15:38:39 INFO SparkEnv: Registering OutputCommitCoordinator</span><br><span class="line">19/11/03 15:38:39 INFO Utils: Successfully started service &apos;SparkUI&apos; on port 4040.</span><br><span class="line">19/11/03 15:38:39 INFO SparkUI: Bound SparkUI to 0.0.0.0, and started at http://hadoop101:4040</span><br><span class="line">19/11/03 15:38:39 INFO SparkContext: Added JAR file:///home/double_happy/lib/spark-streaming-kafka-0-10_2.11-2.4.4.jar at spark://hadoop101:45422/jars/spark-streaming-kafka-0-10_2.11-2.4.4.jar with timestamp 1572766719888</span><br><span class="line">19/11/03 15:38:39 INFO SparkContext: Added JAR file:/home/double_happy/lib/spark-core-1.0.jar at spark://hadoop101:45422/jars/spark-core-1.0.jar with timestamp 1572766719889</span><br><span class="line">19/11/03 15:38:39 INFO Executor: Starting executor ID driver on host localhost</span><br><span class="line">19/11/03 15:38:40 INFO Utils: Successfully started service &apos;org.apache.spark.network.netty.NettyBlockTransferService&apos; on port 40256.</span><br><span class="line">19/11/03 15:38:40 INFO NettyBlockTransferService: Server created on hadoop101:40256</span><br><span class="line">19/11/03 15:38:40 INFO BlockManager: Using org.apache.spark.storage.RandomBlockReplicationPolicy for block replication policy</span><br><span class="line">19/11/03 15:38:40 INFO BlockManagerMaster: Registering BlockManager BlockManagerId(driver, hadoop101, 40256, None)</span><br><span class="line">19/11/03 15:38:40 INFO BlockManagerMasterEndpoint: Registering block manager hadoop101:40256 with 366.3 MB RAM, BlockManagerId(driver, hadoop101, 40256, None)</span><br><span class="line">19/11/03 15:38:40 INFO BlockManagerMaster: Registered BlockManager BlockManagerId(driver, hadoop101, 40256, None)</span><br><span class="line">19/11/03 15:38:40 INFO BlockManager: Initialized BlockManager: BlockManagerId(driver, hadoop101, 40256, None)</span><br><span class="line">19/11/03 15:38:40 INFO EventLoggingListener: Logging events to hdfs://hadoop101:8020/spark_directory/local-1572766719940</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.NoClassDefFoundError: org/apache/kafka/common/serialization/StringDeserializer</span><br><span class="line">        at com.ruozedata.spark.ss04.StreamingKakfaDirectYarnApp$.main(StreamingKakfaDirectYarnApp.scala:36)</span><br><span class="line">        at com.ruozedata.spark.ss04.StreamingKakfaDirectYarnApp.main(StreamingKakfaDirectYarnApp.scala)</span><br><span class="line">        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">        at java.lang.reflect.Method.invoke(Method.java:497)</span><br><span class="line">        at org.apache.spark.deploy.JavaMainApplication.start(SparkApplication.scala:52)</span><br><span class="line">        at org.apache.spark.deploy.SparkSubmit.org$apache$spark$deploy$SparkSubmit$$runMain(SparkSubmit.scala:845)</span><br><span class="line">        at org.apache.spark.deploy.SparkSubmit.doRunMain$1(SparkSubmit.scala:161)</span><br><span class="line">        at org.apache.spark.deploy.SparkSubmit.submit(SparkSubmit.scala:184)</span><br><span class="line">        at org.apache.spark.deploy.SparkSubmit.doSubmit(SparkSubmit.scala:86)</span><br><span class="line">        at org.apache.spark.deploy.SparkSubmit$$anon$2.doSubmit(SparkSubmit.scala:920)</span><br><span class="line">        at org.apache.spark.deploy.SparkSubmit$.main(SparkSubmit.scala:929)</span><br><span class="line">        at org.apache.spark.deploy.SparkSubmit.main(SparkSubmit.scala)</span><br><span class="line">Caused by: java.lang.ClassNotFoundException: org.apache.kafka.common.serialization.StringDeserializer</span><br><span class="line">        at java.net.URLClassLoader.findClass(URLClassLoader.java:381)</span><br><span class="line">        at java.lang.ClassLoader.loadClass(ClassLoader.java:424)</span><br><span class="line">        at java.lang.ClassLoader.loadClass(ClassLoader.java:357)</span><br><span class="line">        ... 14 more</span><br><span class="line">19/11/03 15:38:41 INFO SparkContext: Invoking stop() from shutdown hook</span><br><span class="line">19/11/03 15:38:41 INFO SparkUI: Stopped Spark web UI at http://hadoop101:4040</span><br><span class="line">19/11/03 15:38:41 INFO MapOutputTrackerMasterEndpoint: MapOutputTrackerMasterEndpoint stopped!</span><br><span class="line">19/11/03 15:38:41 INFO MemoryStore: MemoryStore cleared</span><br><span class="line">19/11/03 15:38:41 INFO BlockManager: BlockManager stopped</span><br><span class="line">19/11/03 15:38:41 INFO BlockManagerMaster: BlockManagerMaster stopped</span><br><span class="line">19/11/03 15:38:41 INFO OutputCommitCoordinator$OutputCommitCoordinatorEndpoint: OutputCommitCoordinator stopped!</span><br><span class="line">19/11/03 15:38:41 INFO SparkContext: Successfully stopped SparkContext</span><br><span class="line">19/11/03 15:38:41 INFO ShutdownHookManager: Shutdown hook called</span><br><span class="line">19/11/03 15:38:41 INFO ShutdownHookManager: Deleting directory /tmp/spark-7780e105-fa8c-4592-ac12-7d27fc631ccd</span><br><span class="line">19/11/03 15:38:41 INFO ShutdownHookManager: Deleting directory /tmp/spark-58bc8e97-e4ea-4708-9819-b98f98cb2212</span><br><span class="line">[double_happy@hadoop101 bin]$</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">注意：</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.NoClassDefFoundError: org/apache/kafka/common/serialization/StringDeserializer</span><br><span class="line"></span><br><span class="line">这个东西和上面一样 因为这个东西是在哪？</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191103154351394.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">因为sparkStreaming-kafka包里面包含kafka-client </span><br><span class="line">你idea里pom 配置一个ss-kafka是可以的 但是到服务器上 是需要kafka-client这个jar包的</span><br><span class="line">所以把它 也上传到服务器上</span><br><span class="line"></span><br><span class="line">./spark-submit \</span><br><span class="line">--master local[2] \</span><br><span class="line">--name StreamingKakfaDirectYarnApp \</span><br><span class="line">--jars /home/double_happy/lib/spark-streaming-kafka-0-10_2.11-2.4.4.jar,/home/double_happy/lib/kafka-clients-2.0.0.jar \</span><br><span class="line">--class com.ruozedata.spark.ss04.StreamingKakfaDirectYarnApp \</span><br><span class="line">/home/double_happy/lib/spark-core-1.0.jar \</span><br><span class="line">hadoop101:9092,hadoop101:9093,hadoop101:9094 double_happy_offset double_happy_group3</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line">[double_happy@hadoop101 bin]$ ./spark-submit --master local[2] --name StreamingKakfaDirectYarnApp --jars /home/double_happy/lib/spark-streaming-kafka-0-10_2.11-2.4.4.jar,/home/double_happy/lib/kafka-clients-2.0.0.jar --class com.ruozedata.spark.ss04.StreamingKakfaDirectYarnApp /home/double_happy/lib/spark-core-1.0.jar hadoop101:9092,hadoop101:9093,hadoop101:9094 double_happy_offset double_happy_group3</span><br><span class="line">19/11/03 15:51:12 WARN NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicable</span><br><span class="line">19/11/03 15:51:12 INFO SparkContext: Running Spark version 2.4.4</span><br><span class="line">19/11/03 15:51:12 INFO SparkContext: Submitted application: StreamingKakfaDirectYarnApp</span><br><span class="line">19/11/03 15:51:12 INFO SecurityManager: Changing view acls to: double_happy</span><br><span class="line">19/11/03 15:51:12 INFO SecurityManager: Changing modify acls to: double_happy</span><br><span class="line">19/11/03 15:51:12 INFO SecurityManager: Changing view acls groups to: </span><br><span class="line">19/11/03 15:51:12 INFO SecurityManager: Changing modify acls groups to: </span><br><span class="line">19/11/03 15:51:12 INFO SecurityManager: SecurityManager: authentication disabled; ui acls disabled; users  with view permissions: Set(double_happy); groups with view permissions: Set(); users  with modify permissions: Set(double_happy); groups with modify permissions: Set()</span><br><span class="line">19/11/03 15:51:13 INFO Utils: Successfully started service &apos;sparkDriver&apos; on port 44185.</span><br><span class="line">19/11/03 15:51:13 INFO SparkEnv: Registering MapOutputTracker</span><br><span class="line">19/11/03 15:51:13 INFO SparkEnv: Registering BlockManagerMaster</span><br><span class="line">19/11/03 15:51:13 INFO BlockManagerMasterEndpoint: Using org.apache.spark.storage.DefaultTopologyMapper for getting topology information</span><br><span class="line">19/11/03 15:51:13 INFO BlockManagerMasterEndpoint: BlockManagerMasterEndpoint up</span><br><span class="line">19/11/03 15:51:13 INFO DiskBlockManager: Created local directory at /tmp/blockmgr-d86d96f2-228c-4046-b62b-bbc683c696e8</span><br><span class="line">19/11/03 15:51:13 INFO MemoryStore: MemoryStore started with capacity 366.3 MB</span><br><span class="line">19/11/03 15:51:13 INFO SparkEnv: Registering OutputCommitCoordinator</span><br><span class="line">19/11/03 15:51:13 INFO Utils: Successfully started service &apos;SparkUI&apos; on port 4040.</span><br><span class="line">19/11/03 15:51:13 INFO SparkUI: Bound SparkUI to 0.0.0.0, and started at http://hadoop101:4040</span><br><span class="line">19/11/03 15:51:13 INFO SparkContext: Added JAR file:///home/double_happy/lib/spark-streaming-kafka-0-10_2.11-2.4.4.jar at spark://hadoop101:44185/jars/spark-streaming-kafka-0-10_2.11-2.4.4.jar with timestamp 1572767473466</span><br><span class="line">19/11/03 15:51:13 INFO SparkContext: Added JAR file:///home/double_happy/lib/kafka-clients-2.0.0.jar at spark://hadoop101:44185/jars/kafka-clients-2.0.0.jar with timestamp 1572767473467</span><br><span class="line">19/11/03 15:51:13 INFO SparkContext: Added JAR file:/home/double_happy/lib/spark-core-1.0.jar at spark://hadoop101:44185/jars/spark-core-1.0.jar with timestamp 1572767473467</span><br><span class="line">19/11/03 15:51:13 INFO Executor: Starting executor ID driver on host localhost</span><br><span class="line">19/11/03 15:51:13 INFO Utils: Successfully started service &apos;org.apache.spark.network.netty.NettyBlockTransferService&apos; on port 34854.</span><br><span class="line">19/11/03 15:51:13 INFO NettyBlockTransferService: Server created on hadoop101:34854</span><br><span class="line">19/11/03 15:51:13 INFO BlockManager: Using org.apache.spark.storage.RandomBlockReplicationPolicy for block replication policy</span><br><span class="line">19/11/03 15:51:13 INFO BlockManagerMaster: Registering BlockManager BlockManagerId(driver, hadoop101, 34854, None)</span><br><span class="line">19/11/03 15:51:13 INFO BlockManagerMasterEndpoint: Registering block manager hadoop101:34854 with 366.3 MB RAM, BlockManagerId(driver, hadoop101, 34854, None)</span><br><span class="line">19/11/03 15:51:13 INFO BlockManagerMaster: Registered BlockManager BlockManagerId(driver, hadoop101, 34854, None)</span><br><span class="line">19/11/03 15:51:13 INFO BlockManager: Initialized BlockManager: BlockManagerId(driver, hadoop101, 34854, None)</span><br><span class="line">19/11/03 15:51:14 INFO EventLoggingListener: Logging events to hdfs://hadoop101:8020/spark_directory/local-1572767473528</span><br><span class="line">19/11/03 15:51:14 WARN KafkaUtils: overriding enable.auto.commit to false for executor</span><br><span class="line">19/11/03 15:51:14 WARN KafkaUtils: overriding auto.offset.reset to none for executor</span><br><span class="line">19/11/03 15:51:14 WARN KafkaUtils: overriding executor group.id to spark-executor-double_happy_group3</span><br><span class="line">19/11/03 15:51:14 WARN KafkaUtils: overriding receive.buffer.bytes to 65536 see KAFKA-3135</span><br><span class="line">19/11/03 15:51:14 INFO DirectKafkaInputDStream: Slide time = 10000 ms</span><br><span class="line">19/11/03 15:51:14 INFO DirectKafkaInputDStream: Storage level = Serialized 1x Replicated</span><br><span class="line">19/11/03 15:51:14 INFO DirectKafkaInputDStream: Checkpoint interval = null</span><br><span class="line">19/11/03 15:51:14 INFO DirectKafkaInputDStream: Remember interval = 10000 ms</span><br><span class="line">19/11/03 15:51:14 INFO DirectKafkaInputDStream: Initialized and validated org.apache.spark.streaming.kafka010.DirectKafkaInputDStream@5427abd</span><br><span class="line">19/11/03 15:51:14 INFO MappedDStream: Slide time = 10000 ms</span><br><span class="line">19/11/03 15:51:14 INFO MappedDStream: Storage level = Serialized 1x Replicated</span><br><span class="line">19/11/03 15:51:14 INFO MappedDStream: Checkpoint interval = null</span><br><span class="line">19/11/03 15:51:14 INFO MappedDStream: Remember interval = 10000 ms</span><br><span class="line">19/11/03 15:51:14 INFO MappedDStream: Initialized and validated org.apache.spark.streaming.dstream.MappedDStream@7fbff13b</span><br><span class="line">19/11/03 15:51:14 INFO FlatMappedDStream: Slide time = 10000 ms</span><br><span class="line">19/11/03 15:51:14 INFO FlatMappedDStream: Storage level = Serialized 1x Replicated</span><br><span class="line">19/11/03 15:51:14 INFO FlatMappedDStream: Checkpoint interval = null</span><br><span class="line">19/11/03 15:51:14 INFO FlatMappedDStream: Remember interval = 10000 ms</span><br><span class="line">19/11/03 15:51:14 INFO FlatMappedDStream: Initialized and validated org.apache.spark.streaming.dstream.FlatMappedDStream@57b2814e</span><br><span class="line">19/11/03 15:51:14 INFO MappedDStream: Slide time = 10000 ms</span><br><span class="line">19/11/03 15:51:14 INFO MappedDStream: Storage level = Serialized 1x Replicated</span><br><span class="line">19/11/03 15:51:14 INFO MappedDStream: Checkpoint interval = null</span><br><span class="line">19/11/03 15:51:14 INFO MappedDStream: Remember interval = 10000 ms</span><br><span class="line">19/11/03 15:51:14 INFO MappedDStream: Initialized and validated org.apache.spark.streaming.dstream.MappedDStream@4b876f31</span><br><span class="line">19/11/03 15:51:14 INFO ShuffledDStream: Slide time = 10000 ms</span><br><span class="line">19/11/03 15:51:14 INFO ShuffledDStream: Storage level = Serialized 1x Replicated</span><br><span class="line">19/11/03 15:51:14 INFO ShuffledDStream: Checkpoint interval = null</span><br><span class="line">19/11/03 15:51:14 INFO ShuffledDStream: Remember interval = 10000 ms</span><br><span class="line">19/11/03 15:51:14 INFO ShuffledDStream: Initialized and validated org.apache.spark.streaming.dstream.ShuffledDStream@5d06636e</span><br><span class="line">19/11/03 15:51:14 INFO ForEachDStream: Slide time = 10000 ms</span><br><span class="line">19/11/03 15:51:14 INFO ForEachDStream: Storage level = Serialized 1x Replicated</span><br><span class="line">19/11/03 15:51:14 INFO ForEachDStream: Checkpoint interval = null</span><br><span class="line">19/11/03 15:51:14 INFO ForEachDStream: Remember interval = 10000 ms</span><br><span class="line">19/11/03 15:51:14 INFO ForEachDStream: Initialized and validated org.apache.spark.streaming.dstream.ForEachDStream@5db077dc</span><br><span class="line">19/11/03 15:51:15 INFO ConsumerConfig: ConsumerConfig values: </span><br><span class="line">        auto.commit.interval.ms = 5000</span><br><span class="line">        auto.offset.reset = earliest</span><br><span class="line">        bootstrap.servers = [hadoop101:9092, hadoop101:9093, hadoop101:9094]</span><br><span class="line">        check.crcs = true</span><br><span class="line">        client.id = </span><br><span class="line">        connections.max.idle.ms = 540000</span><br><span class="line">        default.api.timeout.ms = 60000</span><br><span class="line">        enable.auto.commit = false</span><br><span class="line">        exclude.internal.topics = true</span><br><span class="line">        fetch.max.bytes = 52428800</span><br><span class="line">        fetch.max.wait.ms = 500</span><br><span class="line">        fetch.min.bytes = 1</span><br><span class="line">        group.id = double_happy_group3</span><br><span class="line">        heartbeat.interval.ms = 3000</span><br><span class="line">        interceptor.classes = []</span><br><span class="line">        internal.leave.group.on.close = true</span><br><span class="line">        isolation.level = read_uncommitted</span><br><span class="line">        key.deserializer = class org.apache.kafka.common.serialization.StringDeserializer</span><br><span class="line">        max.partition.fetch.bytes = 1048576</span><br><span class="line">        max.poll.interval.ms = 300000</span><br><span class="line">        max.poll.records = 500</span><br><span class="line">        metadata.max.age.ms = 300000</span><br><span class="line">        metric.reporters = []</span><br><span class="line">        metrics.num.samples = 2</span><br><span class="line">        metrics.recording.level = INFO</span><br><span class="line">        metrics.sample.window.ms = 30000</span><br><span class="line">        partition.assignment.strategy = [class org.apache.kafka.clients.consumer.RangeAssignor]</span><br><span class="line">        receive.buffer.bytes = 65536</span><br><span class="line">        reconnect.backoff.max.ms = 1000</span><br><span class="line">        reconnect.backoff.ms = 50</span><br><span class="line">        request.timeout.ms = 30000</span><br><span class="line">        retry.backoff.ms = 100</span><br><span class="line">        sasl.client.callback.handler.class = null</span><br><span class="line">        sasl.jaas.config = null</span><br><span class="line">        sasl.kerberos.kinit.cmd = /usr/bin/kinit</span><br><span class="line">        sasl.kerberos.min.time.before.relogin = 60000</span><br><span class="line">        sasl.kerberos.service.name = null</span><br><span class="line">        sasl.kerberos.ticket.renew.jitter = 0.05</span><br><span class="line">        sasl.kerberos.ticket.renew.window.factor = 0.8</span><br><span class="line">        sasl.login.callback.handler.class = null</span><br><span class="line">        sasl.login.class = null</span><br><span class="line">        sasl.login.refresh.buffer.seconds = 300</span><br><span class="line">        sasl.login.refresh.min.period.seconds = 60</span><br><span class="line">        sasl.login.refresh.window.factor = 0.8</span><br><span class="line">        sasl.login.refresh.window.jitter = 0.05</span><br><span class="line">        sasl.mechanism = GSSAPI</span><br><span class="line">        security.protocol = PLAINTEXT</span><br><span class="line">        send.buffer.bytes = 131072</span><br><span class="line">        session.timeout.ms = 10000</span><br><span class="line">        ssl.cipher.suites = null</span><br><span class="line">        ssl.enabled.protocols = [TLSv1.2, TLSv1.1, TLSv1]</span><br><span class="line">        ssl.endpoint.identification.algorithm = https</span><br><span class="line">        ssl.key.password = null</span><br><span class="line">        ssl.keymanager.algorithm = SunX509</span><br><span class="line">        ssl.keystore.location = null</span><br><span class="line">        ssl.keystore.password = null</span><br><span class="line">        ssl.keystore.type = JKS</span><br><span class="line">        ssl.protocol = TLS</span><br><span class="line">        ssl.provider = null</span><br><span class="line">        ssl.secure.random.implementation = null</span><br><span class="line">        ssl.trustmanager.algorithm = PKIX</span><br><span class="line">        ssl.truststore.location = null</span><br><span class="line">        ssl.truststore.password = null</span><br><span class="line">        ssl.truststore.type = JKS</span><br><span class="line">        value.deserializer = class org.apache.kafka.common.serialization.StringDeserializer</span><br><span class="line"></span><br><span class="line">19/11/03 15:51:15 INFO AppInfoParser: Kafka version : 2.0.0</span><br><span class="line">19/11/03 15:51:15 INFO AppInfoParser: Kafka commitId : 3402a8361b734732</span><br><span class="line">19/11/03 15:51:15 INFO Metadata: Cluster ID: QW2v3GZOQYCYmgUBgDaicA</span><br><span class="line">19/11/03 15:51:15 INFO AbstractCoordinator: [Consumer clientId=consumer-1, groupId=double_happy_group3] Discovered group coordinator hadoop101:9092 (id: 2147483647 rack: null)</span><br><span class="line">19/11/03 15:51:15 INFO ConsumerCoordinator: [Consumer clientId=consumer-1, groupId=double_happy_group3] Revoking previously assigned partitions []</span><br><span class="line">19/11/03 15:51:15 INFO AbstractCoordinator: [Consumer clientId=consumer-1, groupId=double_happy_group3] (Re-)joining group</span><br><span class="line">19/11/03 15:51:15 INFO AbstractCoordinator: [Consumer clientId=consumer-1, groupId=double_happy_group3] Successfully joined group with generation 7</span><br><span class="line">19/11/03 15:51:15 INFO ConsumerCoordinator: [Consumer clientId=consumer-1, groupId=double_happy_group3] Setting newly assigned partitions [double_happy_offset-0, double_happy_offset-1, double_happy_offset-2]</span><br><span class="line">19/11/03 15:51:15 INFO Fetcher: [Consumer clientId=consumer-1, groupId=double_happy_group3] Resetting offset for partition double_happy_offset-1 to offset 0.</span><br><span class="line">19/11/03 15:51:15 INFO Fetcher: [Consumer clientId=consumer-1, groupId=double_happy_group3] Resetting offset for partition double_happy_offset-2 to offset 0.</span><br><span class="line">19/11/03 15:51:15 INFO Fetcher: [Consumer clientId=consumer-1, groupId=double_happy_group3] Resetting offset for partition double_happy_offset-0 to offset 0.</span><br><span class="line">19/11/03 15:51:15 INFO RecurringTimer: Started timer for JobGenerator at time 1572767480000</span><br><span class="line">19/11/03 15:51:15 INFO JobGenerator: Started JobGenerator at 1572767480000 ms</span><br><span class="line">19/11/03 15:51:15 INFO JobScheduler: Started JobScheduler</span><br><span class="line">19/11/03 15:51:15 INFO StreamingContext: StreamingContext started</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">StreamingContext started    ok没有问题</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">这样做 只需要把你需要的依赖包拿过来就可以了 </span><br><span class="line"></span><br><span class="line">如果你需要额外的依赖包很多怎么办？</span><br><span class="line"></span><br><span class="line">虽然 --packages  不能去中央仓库去下载 但是你公司应该有一个 maven私服 那么你直接用私服里的就可以  </span><br><span class="line"></span><br><span class="line"> 这样做的好处 就是你spark代码包很小的</span><br><span class="line"></span><br><span class="line">[double_happy@hadoop101 lib]$ ll -lh</span><br><span class="line">total 2.4M</span><br><span class="line">-rw-r--r-- 1 double_happy double_happy 1.9M Nov  3 14:16 kafka-clients-2.0.0.jar</span><br><span class="line">-rw-r--r-- 1 double_happy double_happy  48K Oct 24 23:24 local-1571929727692</span><br><span class="line">-rw-r--r-- 1 double_happy double_happy 1.1K Sep 25 19:45 site.log</span><br><span class="line">-rw-r--r-- 1 double_happy double_happy 225K Nov  3 15:05 spark-core-1.0.jar</span><br><span class="line">-rw-r--r-- 1 double_happy double_happy 212K Nov  3 14:16 spark-streaming-kafka-0-10_2.11-2.4.4.jar</span><br><span class="line">-rw-r--r-- 1 double_happy double_happy  37K Sep 23 18:32 udf.jar</span><br><span class="line">-rw-r--r-- 1 double_happy double_happy  36K Sep 23 11:21 wc.jar</span><br><span class="line">[double_happy@hadoop101 lib]$ </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">其实还有一种方式 ：</span><br><span class="line">我们开发的的都是 瘦包 ：仅仅只包含你自己开发的代码 不包括其他的依赖</span><br><span class="line"> </span><br><span class="line"> 瘦包 ：仅仅只包含你自己开发的代码 不包括其他的依赖</span><br><span class="line"> 		包小</span><br><span class="line"> 		需要的依赖的包自己来挑选</span><br><span class="line">胖包：不仅仅会把你自己开发的打包 还会把你的指定的依赖包一起打进去 </span><br><span class="line">		包大</span><br><span class="line">		所有的东西(Hadoop/Spark 除外 )都在里面 运行起来方便</span><br><span class="line">那么胖包怎么使用呢？就是我上面不推荐的链接    因为我之前就用这个方式 修改代码的时候 还得把 那个选项打开 我不喜欢</span><br><span class="line"></span><br><span class="line">瘦包还有一个好处就是 ： 方便升级   胖包真的不好</span><br></pre></td></tr></table></figure></div>


<p><strong>transformation</strong></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">之前写的算子 都是按照每一个批次来处理的 或者是可以累计的等</span><br><span class="line"></span><br><span class="line">新需求：</span><br><span class="line">每隔5秒钟统计前10s钟的数据 </span><br><span class="line">每隔1分钟统计前5分钟的数据</span><br><span class="line"></span><br><span class="line">就是每隔多久统计前多久的数据  那么</span><br><span class="line">这类需求 就是 Window</span><br></pre></td></tr></table></figure></div>
<p><a href="http://spark.apache.org/docs/latest/streaming-programming-guide.html#window-operations" target="_blank" rel="noopener">Window Operations</a><br>As shown in the figure, every time the window slides over a source DStream, the source RDDs that fall within the window are combined and operated upon to produce the RDDs of the windowed DStream. In this specific case, the operation is applied over the last 3 time units of data, and slides by 2 time units. This shows that any window operation needs to specify two parameters.</p>
<p>window length - The duration of the window (3 in the figure).<br>sliding interval - The interval at which the window operation is performed (2 in the figure).<br>These two parameters must be multiples of the batch interval of the source DStream (1 in the figure).<br><img src="https://img-blog.csdnimg.cn/20191103162228877.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>案列</strong></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  /**</span><br><span class="line">   * Return a new DStream by applying `reduceByKey` over a sliding window. This is similar to</span><br><span class="line">   * `DStream.reduceByKey()` but applies it over a sliding window. Hash partitioning is used to</span><br><span class="line">   * generate the RDDs with Spark&apos;s default number of partitions.</span><br><span class="line">   * @param reduceFunc associative and commutative reduce function</span><br><span class="line">   * @param windowDuration width of the window; must be a multiple of this DStream&apos;s</span><br><span class="line">   *                       batching interval</span><br><span class="line">   * @param slideDuration  sliding interval of the window (i.e., the interval after which</span><br><span class="line">   *                       the new DStream will generate RDDs); must be a multiple of this</span><br><span class="line">   *                       DStream&apos;s batching interval</span><br><span class="line">   */</span><br><span class="line">  def reduceByKeyAndWindow(</span><br><span class="line">      reduceFunc: (V, V) =&gt; V,</span><br><span class="line">      windowDuration: Duration,</span><br><span class="line">      slideDuration: Duration</span><br><span class="line">    ): DStream[(K, V)] = ssc.withScope &#123;</span><br><span class="line">    reduceByKeyAndWindow(reduceFunc, windowDuration, slideDuration, defaultPartitioner())</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">只要你见Window  参数里一定带 窗口大小 和 滑动大小的</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">5秒的批次 每隔5秒统计前10秒</span><br><span class="line"></span><br><span class="line">object StreamingKakfaWindowApp &#123;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    val ssc = ContextUtils.getStreamingContext(this.getClass.getSimpleName, 5)</span><br><span class="line">    </span><br><span class="line">    val groupId = &quot;double_happy_group&quot;</span><br><span class="line">    val topic = &quot;double_happy_offset&quot;</span><br><span class="line"></span><br><span class="line">    val kafkaParams = Map[String, Object](</span><br><span class="line">      &quot;bootstrap.servers&quot; -&gt; &quot;hadoop101:9092,hadoop101:9093,hadoop101:9094&quot;, //Kafka地址</span><br><span class="line">      &quot;key.deserializer&quot; -&gt; classOf[StringDeserializer], //反序列化  接收端是反序列化   数据发送是要序列化</span><br><span class="line">      &quot;value.deserializer&quot; -&gt; classOf[StringDeserializer],</span><br><span class="line">      &quot;group.id&quot; -&gt; groupId,</span><br><span class="line">      &quot;auto.offset.reset&quot; -&gt; &quot;earliest&quot;, //偏移量 从哪开始</span><br><span class="line">      &quot;enable.auto.commit&quot; -&gt; (false: java.lang.Boolean) //自动提交么？ 选择不自动提交  手工来管理</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    val topics = Array(topic)</span><br><span class="line">    val stream = KafkaUtils.createDirectStream[String, String](</span><br><span class="line">      ssc,</span><br><span class="line">      PreferConsistent, //数据尽量均匀分布到各个executor上去</span><br><span class="line">      Subscribe[String, String](topics, kafkaParams) //固定写法</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    //TODO...业务逻辑</span><br><span class="line">    val result: DStream[(String, Int)] = stream.map(_.value()).</span><br><span class="line">      flatMap(_.split(&quot;,&quot;))</span><br><span class="line">      .map((_, 1))</span><br><span class="line">      .reduceByKeyAndWindow((a:Int,b:Int) =&gt;</span><br><span class="line">      (a + b),  //窗口内统计两辆相加    业务</span><br><span class="line">      Seconds(10),  //窗口大小</span><br><span class="line">      Seconds(5)) //滑动大小</span><br><span class="line"></span><br><span class="line">    result.print()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ssc.start()</span><br><span class="line">    ssc.awaitTermination()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">-------------------------------------------</span><br><span class="line">Time: 1572770060000 ms</span><br><span class="line">-------------------------------------------</span><br><span class="line">(d,2)</span><br><span class="line">(b,1)</span><br><span class="line">(f,3)</span><br><span class="line">(e,2)</span><br><span class="line">(a,1)</span><br><span class="line">(c,1)</span><br><span class="line"></span><br><span class="line">-------------------------------------------</span><br><span class="line">Time: 1572770065000 ms</span><br><span class="line">-------------------------------------------</span><br><span class="line">(d,2)</span><br><span class="line">(b,1)</span><br><span class="line">(f,3)</span><br><span class="line">(e,2)</span><br><span class="line">(a,1)</span><br><span class="line">(c,1)</span><br><span class="line"></span><br><span class="line">-------------------------------------------</span><br><span class="line">Time: 1572770070000 ms</span><br><span class="line">-------------------------------------------</span><br><span class="line"></span><br><span class="line">-------------------------------------------</span><br><span class="line">Time: 1572770075000 ms</span><br><span class="line">-------------------------------------------</span><br><span class="line"></span><br><span class="line">业务理解即可  这是最基本的统计</span><br><span class="line"></span><br><span class="line">问题：下图</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191103164705730.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>DataFrame and SQL Operations</strong><br><a href="http://spark.apache.org/docs/latest/streaming-programming-guide.html#dataframe-and-sql-operations" target="_blank" rel="noopener">DataFrame and SQL Operations</a></p>
<p>这是批流一体带来的非常大的好处</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">object StreamingSqlApp &#123;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    val ssc = ContextUtils.getStreamingContext(this.getClass.getSimpleName, 5)</span><br><span class="line"></span><br><span class="line">    val groupId = &quot;double_happy_group&quot;</span><br><span class="line"></span><br><span class="line">    val topic = &quot;double_happy_offset&quot;</span><br><span class="line"></span><br><span class="line">    val kafkaParams = Map[String, Object](</span><br><span class="line">      &quot;bootstrap.servers&quot; -&gt; &quot;hadoop101:9092,hadoop101:9093,hadoop101:9094&quot;, //Kafka地址</span><br><span class="line">      &quot;key.deserializer&quot; -&gt; classOf[StringDeserializer], //反序列化  接收端是反序列化   数据发送是要序列化</span><br><span class="line">      &quot;value.deserializer&quot; -&gt; classOf[StringDeserializer],</span><br><span class="line">      &quot;group.id&quot; -&gt; groupId,</span><br><span class="line">      &quot;auto.offset.reset&quot; -&gt; &quot;earliest&quot;, //偏移量 从哪开始</span><br><span class="line">      &quot;enable.auto.commit&quot; -&gt; (false: java.lang.Boolean) //自动提交么？ 选择不自动提交  手工来管理</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    val topics = Array(topic)</span><br><span class="line">    val stream = KafkaUtils.createDirectStream[String, String](</span><br><span class="line">      ssc,</span><br><span class="line">      PreferConsistent, //数据尽量均匀分布到各个executor上去</span><br><span class="line">      Subscribe[String, String](topics, kafkaParams) //固定写法</span><br><span class="line">    ).map(_.value())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //TODO...业务逻辑</span><br><span class="line"></span><br><span class="line">    stream.foreachRDD(rdd =&gt; &#123;   //注意 stream 前面把 value取出来</span><br><span class="line"></span><br><span class="line">      // Get the singleton instance of SparkSession</span><br><span class="line">      val spark = SparkSession.builder.config(rdd.sparkContext.getConf).getOrCreate()</span><br><span class="line">      import spark.implicits._</span><br><span class="line"></span><br><span class="line">      // Convert RDD[String] to DataFrame</span><br><span class="line">      val wordsDataFrame = rdd.toDF(&quot;word&quot;)</span><br><span class="line"></span><br><span class="line">      wordsDataFrame.groupBy(&quot;word&quot;).count().show(false)</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ssc.start()</span><br><span class="line">    ssc.awaitTermination()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">19/11/03 16:55:35 WARN SparkContext: Using an existing SparkContext; some configuration may not take effect.</span><br><span class="line">+----+-----+</span><br><span class="line">|word|count|</span><br><span class="line">+----+-----+</span><br><span class="line">|f   |25   |</span><br><span class="line">|e   |20   |</span><br><span class="line">|d   |25   |</span><br><span class="line">|c   |23   |</span><br><span class="line">|b   |21   |</span><br><span class="line">|a   |26   |</span><br><span class="line">+----+-----+</span><br><span class="line"></span><br><span class="line">19/11/03 16:55:40 WARN SparkSession$Builder: Using an existing SparkSession; some configuration may not take effect.</span><br><span class="line">+----+-----+</span><br><span class="line">|word|count|</span><br><span class="line">+----+-----+</span><br><span class="line">+----+-----+</span><br><span class="line"></span><br><span class="line">19/11/03 16:55:45 WARN SparkSession$Builder: Using an existing SparkSession; some configuration may not take effect.</span><br><span class="line">+----+-----+</span><br><span class="line">|word|count|</span><br><span class="line">+----+-----+</span><br><span class="line">+----+-----+</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">那么这个地方我们使用DF的方式 也可以按sql写 </span><br><span class="line"></span><br><span class="line">官网也有些累加器广播变量在ss里面的使用 和RDD都是一样的  看官网学习</span><br></pre></td></tr></table></figure></div>

<p><strong>消费语义****</strong><br><a href="http://spark.apache.org/docs/latest/streaming-programming-guide.html#definitions" target="_blank" rel="noopener">Definitions</a><br>The semantics of streaming systems are often captured in terms of <strong>how many times each record can be processed by the system</strong>. There are three types of guarantees that a system can provide under all possible operating conditions (despite failures, etc.)</p>
<p>1.<strong>At most once</strong>: Each record will be <strong>either processed once or not processed at all.</strong><br>2.<strong>At least once</strong>: Each record will be processed one or more times. This is stronger than at-most once as it ensure that <strong>no data will be lost</strong>.                      <strong>But there may be duplicates</strong>.<br>3.<strong>Exactly once</strong>: Each record will be processed exactly once - <strong>no data will be lost and no data will be processed multiple times</strong>. This is obviously the strongest guarantee of the three.</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1.流系统中 你的数据被处理了多少次  根据处理多少次 分为三大类</span><br><span class="line">	At most once  </span><br><span class="line">		 最多一次</span><br><span class="line">		 数据可能有丢失</span><br><span class="line">   At least once    </span><br><span class="line">   		至少一次</span><br><span class="line">   		数据不会丢失 但是数据可能会重复</span><br><span class="line">   Exactly once</span><br><span class="line">   		仅一次</span><br><span class="line">   		数据不丢失 数据不会重复 数据也不会被处理多次</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">At most once  ：</span><br><span class="line">	如果ss 消费kafka的数据 先保存offset 再处理结果 (我之前演示的代码 都是最后提交offset) </span><br><span class="line">	但是结果处理挂了 由于offset已经保存了 再处理结果 数据就丢失了 </span><br><span class="line">	所以 一定要先处理结果再保存offset</span><br><span class="line">	</span><br><span class="line"> At least once ：按着上面的方式提交offset</span><br><span class="line"> 	就是结果处理挂了 offset没有提交 再处理结果 数据就重复了 </span><br><span class="line"></span><br><span class="line"> Exactly once：</span><br><span class="line"> 	这个是最完美的 但是***</span><br><span class="line"> 	你要保证它还是有难度的   看官网</span><br></pre></td></tr></table></figure></div>
<p><a href="http://spark.apache.org/docs/latest/streaming-programming-guide.html#semantics-of-output-operations" target="_blank" rel="noopener">Semantics of output operations</a><br><strong>Output operations (like foreachRDD) have at-least once semantics</strong>, that is, the <strong>transformed data may get written to an external entity more than once in the event of a worker failure.</strong> While this is acceptable for saving to file systems using the saveAs<strong><em>Files operations (as the file will simply get overwritten with the same data), *</em>additional effort may be necessary to achieve exactly-once semantics.</strong> There are two approaches.<br>1.<strong>Idempotent updates</strong>: Multiple attempts always write the same data. For example, <strong>saveAs*</strong>Files** always writes the same data to the generated files.<br>2.<strong>Transactional updates</strong>: All updates are made transactionally so that updates are made exactly once atomically. One way to do this would be the following.</p>
<p>Use the batch time (available in foreachRDD) and the partition index of the RDD to create an identifier. This identifier uniquely identifies a blob data in the streaming application.<br>Update external system with this blob transactionally (that is, exactly once, atomically) using the identifier. That is, if the identifier is not already committed, commit the partition data and the identifier atomically. Else, if this was already committed, skip the update.</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">	dstream.foreachRDD &#123; (rdd, time) =&gt;   //time就是你当前批次的时间</span><br><span class="line">  rdd.foreachPartition &#123; partitionIterator =&gt;</span><br><span class="line">    val partitionId = TaskContext.get.partitionId()    //task id </span><br><span class="line">    val uniqueId = generateUniqueId(time.milliseconds, partitionId)   //根据你 的批次的时间 和 task ID 来组成  唯一的一个key (这个key 你每次的操作基于这个key)</span><br><span class="line">    // use this uniqueId to transactionally commit the data in partitionIterator</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Output operations (like foreachRDD) have at-least once semantics</span><br><span class="line"></span><br><span class="line">foreachRDD是保证 at-least onc 这个级别的奥   并不是保证 仅一次的语义</span><br><span class="line"></span><br><span class="line"> two approaches:</span><br><span class="line"> 	1.Idempotent updates  幂等    幂等可以通过主键来控制  主键设计不好等于0</span><br><span class="line">	2.Transactional updates</span><br><span class="line">   3.自己实现  把我们数据和offset绑定  </span><br><span class="line"></span><br><span class="line">也就是说 spark 默认是达到 At least once  </span><br><span class="line"></span><br><span class="line">需要借助At least once 去自己实现 Exactly once</span><br><span class="line"></span><br><span class="line">Exactly once：其实挺简单的 </span><br><span class="line">1.一个是offset提交</span><br><span class="line">2.第二个是 业务数据写出去 </span><br><span class="line">这个两个东西只要有offset能够关联的上  是没有问题的</span><br></pre></td></tr></table></figure></div>

<h2 id="调优"><a href="#调优" class="headerlink" title="调优 ****"></a>调优 ****</h2><p><a href="http://spark.apache.org/docs/latest/streaming-programming-guide.html#performance-tuning" target="_blank" rel="noopener">Performance Tuning</a></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.减少每隔批次处理的时间</span><br><span class="line">2.设置合理的批次大小  也就是说  你多久跑一个批次</span><br><span class="line"></span><br><span class="line">那么通过案例结合UI讲解</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">object StreamingTuningApp &#123;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    val ssc = ContextUtils.getStreamingContext(this.getClass.getSimpleName, 5)</span><br><span class="line"></span><br><span class="line">    val groupId = &quot;double_happy_group&quot;</span><br><span class="line"></span><br><span class="line">    val topic = &quot;double_happy_offset&quot;</span><br><span class="line"></span><br><span class="line">    val kafkaParams = Map[String, Object](</span><br><span class="line">      &quot;bootstrap.servers&quot; -&gt; &quot;hadoop101:9092,hadoop101:9093,hadoop101:9094&quot;, //Kafka地址</span><br><span class="line">      &quot;key.deserializer&quot; -&gt; classOf[StringDeserializer], //反序列化  接收端是反序列化   数据发送是要序列化</span><br><span class="line">      &quot;value.deserializer&quot; -&gt; classOf[StringDeserializer],</span><br><span class="line">      &quot;group.id&quot; -&gt; groupId,</span><br><span class="line">      &quot;auto.offset.reset&quot; -&gt; &quot;earliest&quot;, //偏移量 从哪开始</span><br><span class="line">      &quot;enable.auto.commit&quot; -&gt; (false: java.lang.Boolean) //自动提交么？ 选择不自动提交  手工来管理</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    val topics = Array(topic)</span><br><span class="line">    val stream = KafkaUtils.createDirectStream[String, String](</span><br><span class="line">      ssc,</span><br><span class="line">      PreferConsistent, //数据尽量均匀分布到各个executor上去</span><br><span class="line">      Subscribe[String, String](topics, kafkaParams) //固定写法</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    //TODO...业务逻辑</span><br><span class="line">    val result: DStream[(String, Int)] = stream.map(_.value()).</span><br><span class="line">      flatMap(_.split(&quot;,&quot;))</span><br><span class="line">      .map((_, 1)).reduceByKey(_ + _)</span><br><span class="line"></span><br><span class="line">    result.print()</span><br><span class="line"></span><br><span class="line">    ssc.start()</span><br><span class="line">    ssc.awaitTermination()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">查看UI：</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191103175129217.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>华丽——————————————————————————————————</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ok 我们往kafka写10条数据</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191103175538708.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>华丽——————————————————————————————————<br><img src="https://img-blog.csdnimg.cn/20191103175830927.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>华丽——————————————————————————————————<br><img src="https://img-blog.csdnimg.cn/20191103180027441.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input Rate：数据输入的速率</span><br><span class="line">Scheduling Delay：每个批次启动任务等待了多少时间被调度  叫 调度的延迟</span><br><span class="line">Processing Time：每个批次处理花费了多少时间</span><br><span class="line">Total Delay：调度延迟 + 处理时间</span><br><span class="line"></span><br><span class="line">这些在ui最下面都能看到</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/2019110318053852.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">最佳实践：</span><br><span class="line">	在下一个批次启动任务之前，一定要运行完前一个批次的数据处理     </span><br><span class="line"></span><br><span class="line">如果你当前批次数据都没有处理完 下一个批次数据进来 也就意味着 你的数据逐渐逐渐堆积的 </span><br><span class="line">你的数据在堆积 也就意味着 后面的作业肯定 对于Scheduling Delay 要花一些时间的 </span><br><span class="line">整个作业运行时间也就越来越长的</span><br><span class="line"></span><br><span class="line">这个就符合官网的两点 ：</span><br><span class="line">	1.合适的batch size  也就是你的这一个批次 尽快的 处理完 不然你这个一个批次 接受数据以后 都不能很快的处理完</span><br><span class="line">		后面的作业逐渐的堆积的 越堆积越多 那么越到后面你的应用程序会完蛋</span><br><span class="line">   那么 batch time 设置多少合适？是根据需求来定的 </span><br><span class="line"></span><br><span class="line">影响任务运行时长的要素有哪些？</span><br><span class="line">	1.数据规模       </span><br><span class="line">			数据量大 一定要多放core （多放core 不一定有用 为什么？ 因为你topic的partition 和RDD的partition是一一对应的）</span><br><span class="line">			可以调整topic的分区数  分区数越多 也就意味着RDD的分区越多   RDD的分区越多task也就越多  task多 并行度就上去了</span><br><span class="line">	2.batch time  </span><br><span class="line">			time越长表示 一个批次的数据越多  数据越多你相同的资源下面 处理数据的时长肯定要多一点</span><br><span class="line">	3.业务复杂度</span><br><span class="line">			如果你的算子用的不好 也就意味着整个 带着大量的shuffle 你的性能会差很多很多  </span><br><span class="line">所以这些东西一定要先测</span><br><span class="line">	batch time 设置 需求来定是一方面  另一个一定到环境上测试 测试得到满意的结果 不是像sb产品经理拍脑袋那样 设置的</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191103182702262.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">这个地方kafka是有一个限速的</span><br><span class="line"></span><br><span class="line">为了ss程序7*24小时高性能稳定的跑 所以尽可能的 你的批次处理时间和调度间隔 有一个什么关系呢？ 你的批次处理处理时间 要比调度间隔小</span><br><span class="line"></span><br><span class="line">Kafka限速：</span><br><span class="line">  	配置一个参数 </span><br><span class="line">  		 spark.streaming.kafka.maxRatePerPartition  ： </span><br><span class="line">  		 	Maximum rate (number of records per second) read from kafka</span><br><span class="line">  		 	 when using the new Kafka direct stream API</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">修改代码：</span><br><span class="line">  def getStreamingContext(appname:String,batch:Int,defalut:String = &quot;local[2]&quot;) =&#123;</span><br><span class="line"></span><br><span class="line">    val sparkConf: SparkConf = new SparkConf().setAppName(appname).setMaster(defalut)</span><br><span class="line">    </span><br><span class="line">    //</span><br><span class="line">    sparkConf.set(&quot;spark.streaming.kafka.maxRatePerPartition&quot;,&quot;10&quot;)</span><br><span class="line"></span><br><span class="line">    new StreamingContext(sparkConf,Seconds(batch))</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">先测试没有修改前的：</span><br><span class="line"> 同时我写入kafka一些数据   查看结果</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191103183912458.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">测试修改后的</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191103184011115.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">说明这个参数没有生效 emm </span><br><span class="line">我的问题 因为 我们每次往kafka写的数据才10条 我调大一下在测试   改为1000条  我写了两次往kafka里 查看结果</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191103184757992.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">看 说面限速成功了  这样第一次处理就很好的限制你能处理的范围内</span><br><span class="line"></span><br><span class="line">但是 300 怎么来的？</span><br><span class="line">	而 这个参数 sparkConf.set(&quot;spark.streaming.kafka.maxRatePerPartition&quot;,&quot;10&quot;)</span><br><span class="line">	我们设置的是 10 </span><br><span class="line">	为什么ui上面看到的是300呢？</span><br><span class="line"></span><br><span class="line">有个计算公式的 </span><br><span class="line">	10s一个批次 </span><br><span class="line">	topic 3 个分区   ==》数据量 = 10 *3*10 =300 	</span><br><span class="line">	topic 1个分区   ===》 数据量 = 10 *1 *10 =100</span><br><span class="line"></span><br><span class="line">maxRatePerPartition 指的是每一个分区10条	  那么一个topic就是30条  10s就是 300条</span><br><span class="line"></span><br><span class="line">这个参数只适合 direct api  </span><br><span class="line"></span><br><span class="line">限速的地方：</span><br><span class="line">	1.当你topic里有大量没有处理的数据的时候 并且  &quot;auto.offset.reset&quot; -&gt; &quot;earliest&quot; 选择earliest （就是从最早消费）</span><br><span class="line">		为了防止第一个批次数据量过大 要设置限速</span><br><span class="line">    2.你的业务高峰期和低峰期的时候数据量是不一样的       高峰期是低峰期数据量的很多倍的</span><br><span class="line">    你不限速 很多作业都会处在等待状态 因为你前面批次的那一点时间已经处理不过来这一批次的数据了</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">但是有一个问题哟？</span><br><span class="line"> 我们把消费进来的最大数据量是控制住了 但是这个值是个静态的值  </span><br><span class="line"> </span><br><span class="line"> 假设你的集群吞吐量可以 你的这个值设置小了 怎么办？</span><br><span class="line"> 	随着业务的数据量增长，那么这个东西在生产环境上运行一段时间以后 kafka 消费进来的数据最大的量 应该也</span><br><span class="line"> 	要随着 业务变化而变化就好了 引出一个东西   背压机制</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">背压机制  ： backpressure  1.5版本引进来的</span><br><span class="line">什么是背压呢？</span><br><span class="line">	可以在运行时根据前一个批次数据的运行情况，动态调整后续批次读入的数据量</span><br><span class="line">	这样可以很长从容的面对数据量 突增 和波动的情况 </span><br><span class="line"></span><br><span class="line">这个东西就是一个参数控制一下就ok了 </span><br><span class="line"></span><br><span class="line">spark.streaming.backpressure.enabled</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">背压：它是根据当前批次决定后一个批次 </span><br><span class="line">	</span><br><span class="line">	如果offset 从头开始消费 而且数据量很多的时候   我们启动的时候是从第一个批次启动的</span><br><span class="line">	但是第一个批次 依据谁呢？  没有的</span><br><span class="line">	所以你第一次处理 没有很好的办法评估读取的量  所以还有一个参数 初始化的一个东西</span><br><span class="line">spark.streaming.backpressure.initialRate  用来控制背压初始化读取的数据量</span><br><span class="line">	但是：看下图</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191103191627790.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">如果按照官方这个描述 数据是从receiver过来的  </span><br><span class="line">而我们是没有receiver 这个东西的  direct是没有receiver的</span><br><span class="line"></span><br><span class="line">这个参数能起作用么？测试一下</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">我设置为150</span><br><span class="line"> def getStreamingContext(appname:String,batch:Int,defalut:String = &quot;local[2]&quot;) =&#123;</span><br><span class="line"></span><br><span class="line">    val sparkConf: SparkConf = new SparkConf().setAppName(appname).setMaster(defalut)</span><br><span class="line"></span><br><span class="line">    //</span><br><span class="line">    sparkConf.set(&quot;spark.streaming.kafka.maxRatePerPartition&quot;,&quot;10&quot;)</span><br><span class="line">    sparkConf.set(&quot;spark.streaming.backpressure.enabled&quot;,&quot;true&quot;)</span><br><span class="line">    sparkConf.set(&quot;spark.streaming.backpressure.initialRate&quot;,&quot;150&quot;)</span><br><span class="line"></span><br><span class="line">    new StreamingContext(sparkConf,Seconds(batch))</span><br><span class="line">  &#125;</span><br><span class="line">  查看ui：</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191103192244253.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>不能使用</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">那么该怎么办呢？  自己找找答案</span><br></pre></td></tr></table></figure></div>

<h2 id="优雅的关闭JVM"><a href="#优雅的关闭JVM" class="headerlink" title="优雅的关闭JVM"></a>优雅的关闭JVM</h2><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spark.streaming.stopGracefullyOnShutdown  </span><br><span class="line">	If true, Spark shuts down the StreamingContext gracefully on JVM shutdown rather than immediately.</span><br><span class="line">	会缓慢的关闭 而不是直接关闭</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def getStreamingContext(appname: String, batch: Int, defalut: String = &quot;local[2]&quot;) = &#123;</span><br><span class="line"></span><br><span class="line">  val sparkConf: SparkConf = new SparkConf().setAppName(appname).setMaster(defalut)</span><br><span class="line"></span><br><span class="line">  //</span><br><span class="line">  sparkConf.set(&quot;spark.streaming.kafka.maxRatePerPartition&quot;, &quot;10&quot;)</span><br><span class="line">  sparkConf.set(&quot;spark.streaming.backpressure.enabled&quot;, &quot;true&quot;)</span><br><span class="line">  sparkConf.set(&quot;spark.streaming.stopGracefullyOnShutdown &quot;, &quot;true&quot;)</span><br><span class="line">  new StreamingContext(sparkConf, Seconds(batch))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-SS03" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/21/SS03/">SS03</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2018/02/21/SS03/" class="article-date">
  <time datetime="2018-02-21T12:12:09.000Z" itemprop="datePublished">2018-02-21</time>
</a>
    
    
  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">批流一体：未来的发展趋势</span><br><span class="line">    Spark</span><br><span class="line">    Flink</span><br><span class="line">   他们可以做到 </span><br><span class="line"></span><br><span class="line">MR/Spark/Flink on YARN：是现在是主流方式 </span><br><span class="line"></span><br><span class="line">但是 k8s是未来的主流  等学到容器 用这个</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Spark Streaming provides two categories of built-in streaming sources.</span><br><span class="line"></span><br><span class="line">Basic sources: Sources directly available in the StreamingContext API. Examples: file systems, and socket connections.</span><br><span class="line">Advanced sources: Sources like Kafka, Flume, Kinesis, etc. are available through extra utility classes. These require linking against extra dependencies as discussed in the linking section.</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Some of these advanced sources are as follows.</span><br><span class="line"></span><br><span class="line">Kafka: Spark Streaming 2.4.4 is compatible with Kafka broker versions 0.8.2.1 or higher. See the Kafka Integration Guide for more details.</span><br><span class="line"></span><br><span class="line">Flume: Spark Streaming 2.4.4 is compatible with Flume 1.6.0. See the Flume Integration Guide for more details.</span><br><span class="line"></span><br><span class="line">Kinesis: Spark Streaming 2.4.4 is compatible with Kinesis Client Library 1.2.1. See the Kinesis Integration Guide for more details.</span><br></pre></td></tr></table></figure></div>
<p><strong>Kafka整合</strong></p>
<p><a href="http://spark.apache.org/docs/latest/streaming-kafka-integration.html#spark-streaming-kafka-integration-guide" target="_blank" rel="noopener">Spark Streaming + Kafka Integration Guide</a></p>
<p>The Kafka project introduced <strong>a new consumer API between versions 0.8 and 0.10,</strong> so there are 2 separate corresponding Spark Streaming packages available. Please choose the correct package for your brokers and desired features; note that the 0.8 integration is compatible with later 0.9 and 0.10 brokers, but the 0.10 integration is not compatible with earlier brokers.</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.高阶Api</span><br><span class="line">2.低阶Api  </span><br><span class="line">	就是offset需要我们自己维护</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191101105050468.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一定要用这个：</span><br><span class="line">		spark-streaming-kafka-0-10   和0.8的差别 </span><br><span class="line">		主要在Receiver DStream</span><br></pre></td></tr></table></figure></div>

<p><strong>区别</strong><br><a href="http://spark.apache.org/docs/latest/streaming-kafka-0-8-integration.html#spark-streaming-kafka-integration-guide-kafka-broker-version-082" target="_blank" rel="noopener">spark-streaming-kafka-0-8</a></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spark-streaming-kafka-0-8：</span><br><span class="line"> 第一种方式：Receiver-based Approach</span><br><span class="line"> 	1.uses a Receiver to receive the data</span><br><span class="line"> 		那么Receiver是跑在哪里的？executor里面的 </span><br><span class="line"> 	2.using the Kafka high-level consumer API.</span><br><span class="line"> 	3. received from Kafka through a Receiver is stored in Spark executors</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191101115349607.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>华丽的分割线———————————————————————————————————————-</p>
<p>However, under <strong>default configuration</strong>, this approach can <strong>lose data</strong> under failures (see receiver reliability. <strong>To ensure zero-data loss</strong>, you have to additionally <strong>enable Write-Ahead Logs</strong> in Spark Streaming (introduced in Spark 1.2). This synchronously saves all the <strong>received Kafka data into write-ahead logs on a distributed file system</strong> (e.g HDFS), so that all the data can be recovered on failure. See Deploying section in the streaming programming guide for more details on Write-Ahead Logs.</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WAL机制：先把日志记录下来 这里就是数据</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">注意：Kafka的整合只有一个工具类 叫KafkaUtils</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Create an input stream that pulls messages from Kafka Brokers.</span><br><span class="line">   * @param ssc       StreamingContext object</span><br><span class="line">   * @param zkQuorum  Zookeeper quorum (hostname:port,hostname:port,..)</span><br><span class="line">   * @param groupId   The group id for this consumer</span><br><span class="line">   * @param topics    Map of (topic_name to numPartitions) to consume. Each partition is consumed</span><br><span class="line">   *                  in its own thread</span><br><span class="line">   * @param storageLevel  Storage level to use for storing the received objects</span><br><span class="line">   *                      (default: StorageLevel.MEMORY_AND_DISK_SER_2)</span><br><span class="line">   * @return DStream of (Kafka message key, Kafka message value)</span><br><span class="line">   */</span><br><span class="line">  def createStream(</span><br><span class="line">      ssc: StreamingContext,</span><br><span class="line">      zkQuorum: String,</span><br><span class="line">      groupId: String,</span><br><span class="line">      topics: Map[String, Int],</span><br><span class="line">      storageLevel: StorageLevel = StorageLevel.MEMORY_AND_DISK_SER_2</span><br><span class="line">    ): ReceiverInputDStream[(String, String)] = &#123;</span><br><span class="line">    val kafkaParams = Map[String, String](</span><br><span class="line">      &quot;zookeeper.connect&quot; -&gt; zkQuorum, &quot;group.id&quot; -&gt; groupId,</span><br><span class="line">      &quot;zookeeper.connection.timeout.ms&quot; -&gt; &quot;10000&quot;)</span><br><span class="line">    createStream[String, String, StringDecoder, StringDecoder](</span><br><span class="line">      ssc, kafkaParams, topics, storageLevel)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">Receiver这个方式：</span><br><span class="line">注意：</span><br><span class="line">    storageLevel  ==MEMORY_AND_DISK_SER_2</span><br><span class="line">    1）数据丢失</span><br><span class="line">    2）WAL ==&gt; 数据延迟</span><br><span class="line">    3）offset我们不care</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">为什么MEMORY_AND_DISK_SER_2设计为 2 ？</span><br><span class="line">	2的原因就是防止数据丢失 但是 问题是 即使是2 也不能保证数据 不丢 </span><br><span class="line"></span><br><span class="line">如果数据是通过WAL机制 写到HDFS上去  那么这个storageLevel 还有必要是 2 么？</span><br><span class="line">	一定是没有必要的    官网有写  你想想哈 如果是2  再加上hdfs本身的副本数  数据量是不是太大了 </span><br><span class="line"></span><br><span class="line">虽然WAL解决数据丢失问题 但是带来了一个问题？</span><br><span class="line">     就是数据写到HDFS上之后 更新zk 里的offset  </span><br><span class="line">     那么整体的时效性一定是下降的    你的实时跟HDFS挂钩了  实时性降低 数据延迟</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/2019110111454712.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>Points to remember:</p>
<p><strong>Topic partitions in Kafka do not correlate to partitions of RDDs generated in Spark Streaming</strong>. So increasing the number of topic-specific partitions in the KafkaUtils.createStream() only increases the number of threads using which topics that <strong>are consumed within a single receiver</strong>. <strong>It does not increase the parallelism of Spark in processing the data</strong>. Refer to the main document for more information on that.</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Topic是有partition的 </span><br><span class="line">假设 一个Topic 对应3个partition</span><br><span class="line">   Kafka 里的partition 和 SS产生的RDD里面的partition 不是一个概念 </span><br><span class="line">   即：</span><br><span class="line">   	1 Topic ==》 3 parititions    RDD的并行度 并不是3  </span><br><span class="line">2.所以你增加Topic的分区 仅仅增加 使用的线程数 去处理topic的 还是a single receiver</span><br><span class="line"> 根本不会增加spark处理数据的并行度</span><br></pre></td></tr></table></figure></div>

<p>Multiple Kafka input DStreams can be created with different groups and topics for parallel receiving of data using multiple receivers.</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">总结：</span><br><span class="line">	也就是 spark-streaming-kafka-0-8 问题很多 别用了  要了解原理</span><br></pre></td></tr></table></figure></div>

<p><strong>spark-streaming-kafka-0-10  重点</strong><br><a href="http://spark.apache.org/docs/latest/streaming-kafka-0-10-integration.html" target="_blank" rel="noopener">    spark-streaming-kafka-0-10</a></p>
<p>The Spark Streaming integration for Kafka 0.10 is similar in design to the 0.8 Direct Stream approach. It provides simple parallelism, <strong>1:1 correspondence between Kafka partitions and Spark partitions</strong>, and <strong>access to offsets and metadata</strong>. However, <strong>because the newer integration uses the new Kafka consumer API instead of the simple API, there are notable differences in usage.</strong> This version of the integration is marked as experimental, so the API is potentially subject to change.</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Offset管理的时候不同</span><br></pre></td></tr></table></figure></div>
<p><a href="http://spark.apache.org/docs/latest/streaming-kafka-0-10-integration.html#creating-a-direct-stream" target="_blank" rel="noopener">Creating a Direct Stream</a></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Direct</span><br><span class="line">    不需要Receiver</span><br><span class="line">    Topic的partition和RDD的partition是1:1</span><br><span class="line">    自己手工维护offset   (那么默认offset存在哪？知道么）</span><br></pre></td></tr></table></figure></div>
<p><strong>案例</strong></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line">Producer:  console  （测试的时候 ） 就是使用KafkaApi代码实现</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * A Kafka client that publishes records to the Kafka cluster.</span><br><span class="line"> * &lt;P&gt;</span><br><span class="line"> * The producer is &lt;i&gt;thread safe&lt;/i&gt; and sharing a single producer instance across threads will generally be faster than</span><br><span class="line"> * having multiple instances.</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * Here is a simple example of using the producer to send records with strings containing sequential numbers as the key/value</span><br><span class="line"> * pairs.</span><br><span class="line"> * &lt;pre&gt;</span><br><span class="line"> * &#123;@code</span><br><span class="line"> * Properties props = new Properties();</span><br><span class="line"> * props.put(&quot;bootstrap.servers&quot;, &quot;localhost:9092&quot;);</span><br><span class="line"> * props.put(&quot;acks&quot;, &quot;all&quot;);</span><br><span class="line"> * props.put(&quot;retries&quot;, 0);</span><br><span class="line"> * props.put(&quot;batch.size&quot;, 16384);</span><br><span class="line"> * props.put(&quot;linger.ms&quot;, 1);</span><br><span class="line"> * props.put(&quot;buffer.memory&quot;, 33554432);</span><br><span class="line"> * props.put(&quot;key.serializer&quot;, &quot;org.apache.kafka.common.serialization.StringSerializer&quot;);</span><br><span class="line"> * props.put(&quot;value.serializer&quot;, &quot;org.apache.kafka.common.serialization.StringSerializer&quot;);</span><br><span class="line"> *</span><br><span class="line"> * Producer&lt;String, String&gt; producer = new KafkaProducer&lt;&gt;(props);</span><br><span class="line"> * for (int i = 0; i &lt; 100; i++)</span><br><span class="line"> *     producer.send(new ProducerRecord&lt;String, String&gt;(&quot;my-topic&quot;, Integer.toString(i), Integer.toString(i)));</span><br><span class="line"> *</span><br><span class="line"> * producer.close();</span><br><span class="line"> * &#125;&lt;/pre&gt;</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * The producer consists of a pool of buffer space that holds records that haven&apos;t yet been transmitted to the server</span><br><span class="line"> * as well as a background I/O thread that is responsible for turning these records into requests and transmitting them</span><br><span class="line"> * to the cluster. Failure to close the producer after use will leak these resources.</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * The &#123;@link #send(ProducerRecord) send()&#125; method is asynchronous. When called it adds the record to a buffer of pending record sends</span><br><span class="line"> * and immediately returns. This allows the producer to batch together individual records for efficiency.</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * The &lt;code&gt;acks&lt;/code&gt; config controls the criteria under which requests are considered complete. The &quot;all&quot; setting</span><br><span class="line"> * we have specified will result in blocking on the full commit of the record, the slowest but most durable setting.</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * If the request fails, the producer can automatically retry, though since we have specified &lt;code&gt;retries&lt;/code&gt;</span><br><span class="line"> * as 0 it won&apos;t. Enabling retries also opens up the possibility of duplicates (see the documentation on</span><br><span class="line"> * &lt;a href=&quot;http://kafka.apache.org/documentation.html#semantics&quot;&gt;message delivery semantics&lt;/a&gt; for details).</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * The producer maintains buffers of unsent records for each partition. These buffers are of a size specified by</span><br><span class="line"> * the &lt;code&gt;batch.size&lt;/code&gt; config. Making this larger can result in more batching, but requires more memory (since we will</span><br><span class="line"> * generally have one of these buffers for each active partition).</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * By default a buffer is available to send immediately even if there is additional unused space in the buffer. However if you</span><br><span class="line"> * want to reduce the number of requests you can set &lt;code&gt;linger.ms&lt;/code&gt; to something greater than 0. This will</span><br><span class="line"> * instruct the producer to wait up to that number of milliseconds before sending a request in hope that more records will</span><br><span class="line"> * arrive to fill up the same batch. This is analogous to Nagle&apos;s algorithm in TCP. For example, in the code snippet above,</span><br><span class="line"> * likely all 100 records would be sent in a single request since we set our linger time to 1 millisecond. However this setting</span><br><span class="line"> * would add 1 millisecond of latency to our request waiting for more records to arrive if we didn&apos;t fill up the buffer. Note that</span><br><span class="line"> * records that arrive close together in time will generally batch together even with &lt;code&gt;linger.ms=0&lt;/code&gt; so under heavy load</span><br><span class="line"> * batching will occur regardless of the linger configuration; however setting this to something larger than 0 can lead to fewer, more</span><br><span class="line"> * efficient requests when not under maximal load at the cost of a small amount of latency.</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * The &lt;code&gt;buffer.memory&lt;/code&gt; controls the total amount of memory available to the producer for buffering. If records</span><br><span class="line"> * are sent faster than they can be transmitted to the server then this buffer space will be exhausted. When the buffer space is</span><br><span class="line"> * exhausted additional send calls will block. The threshold for time to block is determined by &lt;code&gt;max.block.ms&lt;/code&gt; after which it throws</span><br><span class="line"> * a TimeoutException.</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * The &lt;code&gt;key.serializer&lt;/code&gt; and &lt;code&gt;value.serializer&lt;/code&gt; instruct how to turn the key and value objects the user provides with</span><br><span class="line"> * their &lt;code&gt;ProducerRecord&lt;/code&gt; into bytes. You can use the included &#123;@link org.apache.kafka.common.serialization.ByteArraySerializer&#125; or</span><br><span class="line"> * &#123;@link org.apache.kafka.common.serialization.StringSerializer&#125; for simple string or byte types.</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * From Kafka 0.11, the KafkaProducer supports two additional modes: the idempotent producer and the transactional producer.</span><br><span class="line"> * The idempotent producer strengthens Kafka&apos;s delivery semantics from at least once to exactly once delivery. In particular</span><br><span class="line"> * producer retries will no longer introduce duplicates. The transactional producer allows an application to send messages</span><br><span class="line"> * to multiple partitions (and topics!) atomically.</span><br><span class="line"> * &lt;/p&gt;</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * To enable idempotence, the &lt;code&gt;enable.idempotence&lt;/code&gt; configuration must be set to true. If set, the</span><br><span class="line"> * &lt;code&gt;retries&lt;/code&gt; config will default to &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt; and the &lt;code&gt;acks&lt;/code&gt; config will</span><br><span class="line"> * default to &lt;code&gt;all&lt;/code&gt;. There are no API changes for the idempotent producer, so existing applications will</span><br><span class="line"> * not need to be modified to take advantage of this feature.</span><br><span class="line"> * &lt;/p&gt;</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * To take advantage of the idempotent producer, it is imperative to avoid application level re-sends since these cannot</span><br><span class="line"> * be de-duplicated. As such, if an application enables idempotence, it is recommended to leave the &lt;code&gt;retries&lt;/code&gt;</span><br><span class="line"> * config unset, as it will be defaulted to &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;. Additionally, if a &#123;@link #send(ProducerRecord)&#125;</span><br><span class="line"> * returns an error even with infinite retries (for instance if the message expires in the buffer before being sent),</span><br><span class="line"> * then it is recommended to shut down the producer and check the contents of the last produced message to ensure that</span><br><span class="line"> * it is not duplicated. Finally, the producer can only guarantee idempotence for messages sent within a single session.</span><br><span class="line"> * &lt;/p&gt;</span><br><span class="line"> * &lt;p&gt;To use the transactional producer and the attendant APIs, you must set the &lt;code&gt;transactional.id&lt;/code&gt;</span><br><span class="line"> * configuration property. If the &lt;code&gt;transactional.id&lt;/code&gt; is set, idempotence is automatically enabled along with</span><br><span class="line"> * the producer configs which idempotence depends on. Further, topics which are included in transactions should be configured</span><br><span class="line"> * for durability. In particular, the &lt;code&gt;replication.factor&lt;/code&gt; should be at least &lt;code&gt;3&lt;/code&gt;, and the</span><br><span class="line"> * &lt;code&gt;min.insync.replicas&lt;/code&gt; for these topics should be set to 2. Finally, in order for transactional guarantees</span><br><span class="line"> * to be realized from end-to-end, the consumers must be configured to read only committed messages as well.</span><br><span class="line"> * &lt;/p&gt;</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * The purpose of the &lt;code&gt;transactional.id&lt;/code&gt; is to enable transaction recovery across multiple sessions of a</span><br><span class="line"> * single producer instance. It would typically be derived from the shard identifier in a partitioned, stateful, application.</span><br><span class="line"> * As such, it should be unique to each producer instance running within a partitioned application.</span><br><span class="line"> * &lt;/p&gt;</span><br><span class="line"> * &lt;p&gt;All the new transactional APIs are blocking and will throw exceptions on failure. The example</span><br><span class="line"> * below illustrates how the new APIs are meant to be used. It is similar to the example above, except that all</span><br><span class="line"> * 100 messages are part of a single transaction.</span><br><span class="line"> * &lt;/p&gt;</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * &lt;pre&gt;</span><br><span class="line"> * &#123;@code</span><br><span class="line"> * Properties props = new Properties();</span><br><span class="line"> * props.put(&quot;bootstrap.servers&quot;, &quot;localhost:9092&quot;);</span><br><span class="line"> * props.put(&quot;transactional.id&quot;, &quot;my-transactional-id&quot;);</span><br><span class="line"> * Producer&lt;String, String&gt; producer = new KafkaProducer&lt;&gt;(props, new StringSerializer(), new StringSerializer());</span><br><span class="line"> *</span><br><span class="line"> * producer.initTransactions();</span><br><span class="line"> *</span><br><span class="line"> * try &#123;</span><br><span class="line"> *     producer.beginTransaction();</span><br><span class="line"> *     for (int i = 0; i &lt; 100; i++)</span><br><span class="line"> *         producer.send(new ProducerRecord&lt;&gt;(&quot;my-topic&quot;, Integer.toString(i), Integer.toString(i)));</span><br><span class="line"> *     producer.commitTransaction();</span><br><span class="line"> * &#125; catch (ProducerFencedException | OutOfOrderSequenceException | AuthorizationException e) &#123;</span><br><span class="line"> *     // We can&apos;t recover from these exceptions, so our only option is to close the producer and exit.</span><br><span class="line"> *     producer.close();</span><br><span class="line"> * &#125; catch (KafkaException e) &#123;</span><br><span class="line"> *     // For all other exceptions, just abort the transaction and try again.</span><br><span class="line"> *     producer.abortTransaction();</span><br><span class="line"> * &#125;</span><br><span class="line"> * producer.close();</span><br><span class="line"> * &#125; &lt;/pre&gt;</span><br><span class="line"> * &lt;/p&gt;</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * As is hinted at in the example, there can be only one open transaction per producer. All messages sent between the</span><br><span class="line"> * &#123;@link #beginTransaction()&#125; and &#123;@link #commitTransaction()&#125; calls will be part of a single transaction. When the</span><br><span class="line"> * &lt;code&gt;transactional.id&lt;/code&gt; is specified, all messages sent by the producer must be part of a transaction.</span><br><span class="line"> * &lt;/p&gt;</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * The transactional producer uses exceptions to communicate error states. In particular, it is not required</span><br><span class="line"> * to specify callbacks for &lt;code&gt;producer.send()&lt;/code&gt; or to call &lt;code&gt;.get()&lt;/code&gt; on the returned Future: a</span><br><span class="line"> * &lt;code&gt;KafkaException&lt;/code&gt; would be thrown if any of the</span><br><span class="line"> * &lt;code&gt;producer.send()&lt;/code&gt; or transactional calls hit an irrecoverable error during a transaction. See the &#123;@link #send(ProducerRecord)&#125;</span><br><span class="line"> * documentation for more details about detecting errors from a transactional send.</span><br><span class="line"> * &lt;/p&gt;</span><br><span class="line"> * &lt;/p&gt;By calling</span><br><span class="line"> * &lt;code&gt;producer.abortTransaction()&lt;/code&gt; upon receiving a &lt;code&gt;KafkaException&lt;/code&gt; we can ensure that any</span><br><span class="line"> * successful writes are marked as aborted, hence keeping the transactional guarantees.</span><br><span class="line"> * &lt;/p&gt;</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * This client can communicate with brokers that are version 0.10.0 or newer. Older or newer brokers may not support</span><br><span class="line"> * certain client features.  For instance, the transactional APIs need broker versions 0.11.0 or later. You will receive an</span><br><span class="line"> * &lt;code&gt;UnsupportedVersionException&lt;/code&gt; when invoking an API that is not available in the running broker version.</span><br><span class="line"> * &lt;/p&gt;</span><br><span class="line"> */</span><br><span class="line">public class KafkaProducer&lt;K, V&gt; implements Producer&lt;K, V&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line">KafkaProducer源码里都介绍了怎么使用  之后讲解略过</span><br><span class="line"></span><br><span class="line">Consumer:console  （测试的时候 ）</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">KafkaProducer：</span><br><span class="line"></span><br><span class="line">先测试 ：发送abcdef </span><br><span class="line">object DataGenerator &#123;</span><br><span class="line">  private val logger: Logger = LoggerFactory.getLogger(DataGenerator.getClass)</span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line"></span><br><span class="line">    val props = new Properties()</span><br><span class="line">    props.put(&quot;bootstrap.servers&quot;, &quot;hadoop101:9092,hadoop101:9093,hadoop101:9094&quot;)</span><br><span class="line">    props.put(&quot;acks&quot;, &quot;all&quot;)</span><br><span class="line">    props.put(&quot;key.serializer&quot;, &quot;org.apache.kafka.common.serialization.StringSerializer&quot;)</span><br><span class="line">    props.put(&quot;value.serializer&quot;, &quot;org.apache.kafka.common.serialization.StringSerializer&quot;)</span><br><span class="line"></span><br><span class="line">    val producer = new KafkaProducer[String, String](props)</span><br><span class="line"></span><br><span class="line">    for (i &lt;- 1 to 10) &#123;</span><br><span class="line">      Thread.sleep(100)</span><br><span class="line">      //拿一个abcdef</span><br><span class="line">      val word: String = String.valueOf((new Random().nextInt(6) + &apos;a&apos;).toChar)</span><br><span class="line">      val part = i % 3   //发到哪个分区 因为是三个分区</span><br><span class="line"></span><br><span class="line">      logger.error(&quot;word : &#123;&#125;&quot;,word)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果： 注意这代码 全是源码注释里有 你不需要记住 </span><br><span class="line">你只需要记住：</span><br><span class="line">	1.KafkaProducer 创建   </span><br><span class="line">	2.发送数据 要序列化</span><br><span class="line">	3.怎么发   </span><br><span class="line">	这三个东西 源码注释里全都是写好的 </span><br><span class="line"></span><br><span class="line">19/11/01 13:23:18 ERROR DataGenerator$: word : f</span><br><span class="line">19/11/01 13:23:18 ERROR DataGenerator$: word : d</span><br><span class="line">19/11/01 13:23:18 ERROR DataGenerator$: word : f</span><br><span class="line">19/11/01 13:23:18 ERROR DataGenerator$: word : d</span><br><span class="line">19/11/01 13:23:18 ERROR DataGenerator$: word : c</span><br><span class="line">19/11/01 13:23:19 ERROR DataGenerator$: word : c</span><br><span class="line">19/11/01 13:23:19 ERROR DataGenerator$: word : e</span><br><span class="line">19/11/01 13:23:19 ERROR DataGenerator$: word : c</span><br><span class="line">19/11/01 13:23:19 ERROR DataGenerator$: word : a</span><br><span class="line">19/11/01 13:23:19 ERROR DataGenerator$: word : a</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">怎么发送呢？</span><br><span class="line"> /**</span><br><span class="line">     * Creates a record to be sent to a specified topic and partition</span><br><span class="line">     *</span><br><span class="line">     * @param topic The topic the record will be appended to</span><br><span class="line">     * @param partition The partition to which the record should be sent</span><br><span class="line">     * @param key The key that will be included in the record</span><br><span class="line">     * @param value The record contents</span><br><span class="line">     */</span><br><span class="line">    public ProducerRecord(String topic, Integer partition, K key, V value) &#123;</span><br><span class="line">        this(topic, partition, null, key, value, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">object DataGenerator &#123;</span><br><span class="line"></span><br><span class="line">  private val logger: Logger = LoggerFactory.getLogger(DataGenerator.getClass)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line"></span><br><span class="line">    val props = new Properties()</span><br><span class="line">    props.put(&quot;bootstrap.servers&quot;, &quot;hadoop101:9092,hadoop101:9093,hadoop101:9094&quot;)</span><br><span class="line">    props.put(&quot;acks&quot;, &quot;all&quot;)</span><br><span class="line">    props.put(&quot;key.serializer&quot;, &quot;org.apache.kafka.common.serialization.StringSerializer&quot;)</span><br><span class="line">    props.put(&quot;value.serializer&quot;, &quot;org.apache.kafka.common.serialization.StringSerializer&quot;)</span><br><span class="line">    val producer = new KafkaProducer[String, String](props)</span><br><span class="line"></span><br><span class="line">    for (i &lt;- 1 to 10) &#123;</span><br><span class="line">      Thread.sleep(100)</span><br><span class="line"></span><br><span class="line">      //拿一个abcdef</span><br><span class="line">      val word: String = String.valueOf((new Random().nextInt(6) + &apos;a&apos;).toChar)</span><br><span class="line">      val part = i % 3 //发到哪个分区 因为是三个分区</span><br><span class="line"></span><br><span class="line">      logger.error(&quot;word : &#123;&#125;&quot;, word)</span><br><span class="line"></span><br><span class="line">      val record = producer.send(new ProducerRecord[String, String](&quot;double_happy_offset&quot;, part, &quot;&quot;,word))</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    producer.close()</span><br><span class="line">    println(&quot;double_happy 数据产生完毕..........&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ok进行测试</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">[double_happy@hadoop101 kafka]$ bin/kafka-console-consumer.sh \</span><br><span class="line">&gt; --bootstrap-server hadoop101:9092,hadoop101:9093,hadoop101:9094 \</span><br><span class="line">&gt; --topic double_happy_offset \</span><br><span class="line">&gt; --from-beginning</span><br><span class="line"></span><br><span class="line">运行idea代码结果：</span><br><span class="line">19/11/01 13:33:56 ERROR DataGenerator$: word : a</span><br><span class="line">19/11/01 13:33:57 ERROR DataGenerator$: word : e</span><br><span class="line">19/11/01 13:33:57 ERROR DataGenerator$: word : f</span><br><span class="line">19/11/01 13:33:57 ERROR DataGenerator$: word : a</span><br><span class="line">19/11/01 13:33:57 ERROR DataGenerator$: word : f</span><br><span class="line">19/11/01 13:33:57 ERROR DataGenerator$: word : c</span><br><span class="line">19/11/01 13:33:57 ERROR DataGenerator$: word : c</span><br><span class="line">19/11/01 13:33:57 ERROR DataGenerator$: word : f</span><br><span class="line">19/11/01 13:33:57 ERROR DataGenerator$: word : e</span><br><span class="line">19/11/01 13:33:58 ERROR DataGenerator$: word : a</span><br><span class="line">double_happy 数据产生完毕..........</span><br><span class="line"></span><br><span class="line">kafka控制台结果：</span><br><span class="line">[double_happy@hadoop101 kafka]$ bin/kafka-console-consumer.sh \</span><br><span class="line">&gt; --bootstrap-server hadoop101:9092,hadoop101:9093,hadoop101:9094 \</span><br><span class="line">&gt; --topic double_happy_offset \</span><br><span class="line">&gt; --from-beginning</span><br><span class="line">a</span><br><span class="line">e</span><br><span class="line">f</span><br><span class="line">a</span><br><span class="line">f</span><br><span class="line">c</span><br><span class="line">c</span><br><span class="line">f</span><br><span class="line">e</span><br><span class="line">a</span><br><span class="line"></span><br><span class="line">对接kafka + ss前期准备工作ok</span><br></pre></td></tr></table></figure></div>
<p><strong>对接</strong></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * :: Experimental ::</span><br><span class="line">   * Scala constructor for a DStream where</span><br><span class="line">   * each given Kafka topic/partition corresponds to an RDD partition.</span><br><span class="line">   * The spark configuration spark.streaming.kafka.maxRatePerPartition gives the maximum number</span><br><span class="line">   *  of messages</span><br><span class="line">   * per second that each &apos;&apos;&apos;partition&apos;&apos;&apos; will accept.</span><br><span class="line">   * @param locationStrategy In most cases, pass in [[LocationStrategies.PreferConsistent]],</span><br><span class="line">   *   see [[LocationStrategies]] for more details.</span><br><span class="line">   * @param consumerStrategy In most cases, pass in [[ConsumerStrategies.Subscribe]],</span><br><span class="line">   *   see [[ConsumerStrategies]] for more details</span><br><span class="line">   * @tparam K type of Kafka message key</span><br><span class="line">   * @tparam V type of Kafka message value</span><br><span class="line">   */</span><br><span class="line">  @Experimental</span><br><span class="line">  def createDirectStream[K, V](</span><br><span class="line">      ssc: StreamingContext,</span><br><span class="line">      locationStrategy: LocationStrategy,</span><br><span class="line">      consumerStrategy: ConsumerStrategy[K, V]</span><br><span class="line">    ): InputDStream[ConsumerRecord[K, V]] = &#123;</span><br><span class="line">    val ppc = new DefaultPerPartitionConfig(ssc.sparkContext.getConf)</span><br><span class="line">    createDirectStream[K, V](ssc, locationStrategy, consumerStrategy, ppc)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">locationStrategy 策略什么意思呢？官网有  一会代码里我写了解释</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">object StreamingKakfaDirectApp &#123;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line"></span><br><span class="line">    val ssc = ContextUtils.getStreamingContext(this.getClass.getSimpleName, 10)</span><br><span class="line"></span><br><span class="line">    val kafkaParams = Map[String, Object](</span><br><span class="line">      &quot;bootstrap.servers&quot; -&gt; &quot;hadoop101:9092,hadoop101:9093,hadoop101:9094&quot;,   //Kafka地址</span><br><span class="line">      &quot;key.deserializer&quot; -&gt; classOf[StringDeserializer],      //反序列化  接收端是反序列化   数据发送是要序列化</span><br><span class="line">      &quot;value.deserializer&quot; -&gt; classOf[StringDeserializer],</span><br><span class="line">      &quot;group.id&quot; -&gt; &quot;use_a_separate_group_id_for_each_stream&quot;,</span><br><span class="line">      &quot;auto.offset.reset&quot; -&gt; &quot;earliest&quot;,    //偏移量 从哪开始</span><br><span class="line">      &quot;enable.auto.commit&quot; -&gt; (false: java.lang.Boolean)  //自动提交么？ 选择不自动提交  手工来管理</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    val topics = Array(&quot;double_happy_offset&quot;)</span><br><span class="line">    val stream = KafkaUtils.createDirectStream[String, String](</span><br><span class="line">      ssc,</span><br><span class="line">      PreferConsistent,  //数据尽量均匀分布到各个executor上去</span><br><span class="line">      Subscribe[String, String](topics, kafkaParams)  //固定写法</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    stream.map(record =&gt; (record.key, record.value))  </span><br><span class="line">      .map(_._2).print()   //因为我们key就没有设置  只取value</span><br><span class="line"></span><br><span class="line">    ssc.start()</span><br><span class="line">    ssc.awaitTermination()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">-------------------------------------------</span><br><span class="line">Time: 1572587100000 ms</span><br><span class="line">-------------------------------------------</span><br><span class="line">a</span><br><span class="line">a</span><br><span class="line">c</span><br><span class="line">a</span><br><span class="line">f</span><br><span class="line">c</span><br><span class="line">e</span><br><span class="line">e</span><br><span class="line">f</span><br><span class="line">f</span><br><span class="line"></span><br><span class="line">-------------------------------------------</span><br><span class="line">Time: 1572587110000 ms</span><br><span class="line">-------------------------------------------</span><br><span class="line"></span><br><span class="line">-------------------------------------------</span><br><span class="line">Time: 1572587120000 ms</span><br><span class="line">-------------------------------------------</span><br><span class="line"></span><br><span class="line">-------------------------------------------</span><br><span class="line">Time: 1572587130000 ms</span><br><span class="line">-------------------------------------------     这块 我们kafka又发了一次数据 ssc接收到了</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line"></span><br><span class="line">-------------------------------------------</span><br><span class="line">Time: 1572587140000 ms</span><br><span class="line">-------------------------------------------</span><br><span class="line">c</span><br><span class="line">a</span><br><span class="line">e</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">d</span><br><span class="line">a</span><br><span class="line">b</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">object StreamingKakfaDirectApp &#123;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line"></span><br><span class="line">    val ssc = ContextUtils.getStreamingContext(this.getClass.getSimpleName, 10)</span><br><span class="line"></span><br><span class="line">    val kafkaParams = Map[String, Object](</span><br><span class="line">      &quot;bootstrap.servers&quot; -&gt; &quot;hadoop101:9092,hadoop101:9093,hadoop101:9094&quot;,   //Kafka地址</span><br><span class="line">      &quot;key.deserializer&quot; -&gt; classOf[StringDeserializer],      //反序列化  接收端是反序列化   数据发送是要序列化</span><br><span class="line">      &quot;value.deserializer&quot; -&gt; classOf[StringDeserializer],</span><br><span class="line">      &quot;group.id&quot; -&gt; &quot;use_a_separate_group_id_for_each_stream&quot;,</span><br><span class="line">      &quot;auto.offset.reset&quot; -&gt; &quot;earliest&quot;,    //偏移量 从哪开始</span><br><span class="line">      &quot;enable.auto.commit&quot; -&gt; (false: java.lang.Boolean)  //自动提交么？ 选择不自动提交  手工来管理</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    val topics = Array(&quot;double_happy_offset&quot;)</span><br><span class="line">    val stream = KafkaUtils.createDirectStream[String, String](</span><br><span class="line">      ssc,</span><br><span class="line">      PreferConsistent,  //数据尽量均匀分布到各个executor上去</span><br><span class="line">      Subscribe[String, String](topics, kafkaParams)  //固定写法</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">   //TODO...业务逻辑</span><br><span class="line">    val result: DStream[(String, Int)] = stream.map(_.value()).</span><br><span class="line">      flatMap(_.split(&quot;,&quot;))</span><br><span class="line">      .map((_, 1)).reduceByKey(_ + _)</span><br><span class="line"></span><br><span class="line">    //结果入库 写到redis里</span><br><span class="line">    result.foreachRDD(rdd =&gt;&#123;</span><br><span class="line">      rdd.foreachPartition(paritition =&gt;&#123;</span><br><span class="line">        val jedis: Jedis = RedisUtils.getJedis</span><br><span class="line"></span><br><span class="line">        paritition.foreach(pair =&gt;&#123;</span><br><span class="line">          jedis.hincrBy(&quot;kafka_ss_redis_wc&quot;,pair._1,pair._2)</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        jedis.close()</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    ssc.start()</span><br><span class="line">    ssc.awaitTermination()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">hadoop101:6379&gt; keys *</span><br><span class="line">1) &quot;name&quot;</span><br><span class="line">2) &quot;kafka_ss_redis_wc&quot;</span><br><span class="line">3) &quot;doublehappy_redis_wc&quot;</span><br><span class="line">hadoop101:6379&gt; HGETALL kafka_ss_redis_wc</span><br><span class="line"> 1) &quot;e&quot;</span><br><span class="line"> 2) &quot;3&quot;</span><br><span class="line"> 3) &quot;d&quot;</span><br><span class="line"> 4) &quot;2&quot;</span><br><span class="line"> 5) &quot;a&quot;</span><br><span class="line"> 6) &quot;6&quot;</span><br><span class="line"> 7) &quot;b&quot;</span><br><span class="line"> 8) &quot;2&quot;</span><br><span class="line"> 9) &quot;c&quot;</span><br><span class="line">10) &quot;4&quot;</span><br><span class="line">11) &quot;f&quot;</span><br><span class="line">12) &quot;3&quot;</span><br><span class="line">hadoop101:6379&gt;</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/2019110114001642.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">这个时候 把实时代码关掉 ：</span><br><span class="line"></span><br><span class="line">redis里的数据翻倍了 因为又写了一次嘛  </span><br><span class="line">但是这样是不行的  </span><br><span class="line">	因为代码里 这个控制的 </span><br><span class="line">		&quot;auto.offset.reset&quot; -&gt; &quot;earliest&quot;,    //偏移量 从哪开始</span><br><span class="line">      &quot;enable.auto.commit&quot; -&gt; (false: java.lang.Boolean)  //自动提交么？ 选择不自动提交  手工来管理</span><br><span class="line">  </span><br><span class="line">那么接下来 看看offset 怎么获取呢？怎么提交offset呢？</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191101140557306.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><a href="http://spark.apache.org/docs/latest/streaming-kafka-0-10-integration.html#obtaining-offsets" target="_blank" rel="noopener">Obtaining Offsets</a></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">trait HasOffsetRanges &#123;</span><br><span class="line">  def offsetRanges: Array[OffsetRange]    //拿到offset的范围  返回值是数组 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Represents a range of offsets from a single Kafka TopicPartition. Instances of this class</span><br><span class="line"> * can be created with `OffsetRange.create()`.</span><br><span class="line"> * @param topic Kafka topic name</span><br><span class="line"> * @param partition Kafka partition id</span><br><span class="line"> * @param fromOffset Inclusive starting offset</span><br><span class="line"> * @param untilOffset Exclusive ending offset</span><br><span class="line"> */</span><br><span class="line">final class OffsetRange private(</span><br><span class="line">    val topic: String,    </span><br><span class="line">    val partition: Int,</span><br><span class="line">    val fromOffset: Long,</span><br><span class="line">    val untilOffset: Long) extends Serializable &#123;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">获取offset：</span><br><span class="line">object StreamingKakfaDirectApp &#123;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line"></span><br><span class="line">    val ssc = ContextUtils.getStreamingContext(this.getClass.getSimpleName, 10)</span><br><span class="line"></span><br><span class="line">    val kafkaParams = Map[String, Object](</span><br><span class="line">      &quot;bootstrap.servers&quot; -&gt; &quot;hadoop101:9092,hadoop101:9093,hadoop101:9094&quot;,   //Kafka地址</span><br><span class="line">      &quot;key.deserializer&quot; -&gt; classOf[StringDeserializer],      //反序列化  接收端是反序列化   数据发送是要序列化</span><br><span class="line">      &quot;value.deserializer&quot; -&gt; classOf[StringDeserializer],</span><br><span class="line">      &quot;group.id&quot; -&gt; &quot;use_a_separate_group_id_for_each_stream&quot;,</span><br><span class="line">      &quot;auto.offset.reset&quot; -&gt; &quot;earliest&quot;,    //偏移量 从哪开始</span><br><span class="line">      &quot;enable.auto.commit&quot; -&gt; (false: java.lang.Boolean)  //自动提交么？ 选择不自动提交  手工来管理</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    val topics = Array(&quot;double_happy_offset&quot;)</span><br><span class="line">    val stream = KafkaUtils.createDirectStream[String, String](</span><br><span class="line">      ssc,</span><br><span class="line">      PreferConsistent,  //数据尽量均匀分布到各个executor上去</span><br><span class="line">      Subscribe[String, String](topics, kafkaParams)  //固定写法</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">   //TODO...业务逻辑</span><br><span class="line">    val result: DStream[(String, Int)] = stream.map(_.value()).</span><br><span class="line">      flatMap(_.split(&quot;,&quot;))</span><br><span class="line">      .map((_, 1)).reduceByKey(_ + _)</span><br><span class="line"></span><br><span class="line">    //结果</span><br><span class="line">    result.foreachRDD(rdd =&gt;&#123;   //这块的rdd一定要注意的  </span><br><span class="line"></span><br><span class="line">      //获取分区数</span><br><span class="line">      println(&quot;---------&quot;+rdd.partitions.size)   //这个值应该是3</span><br><span class="line"></span><br><span class="line">      //获取当前批次的offset数据</span><br><span class="line">      val offsetRanges = rdd.asInstanceOf[HasOffsetRanges].offsetRanges</span><br><span class="line">      offsetRanges.foreach(x=&gt;&#123;</span><br><span class="line">        println(s&quot;$&#123;x.topic&#125; $&#123;x.partition&#125; $&#123;x.fromOffset&#125; $&#123;x.untilOffset&#125;&quot;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    ssc.start()</span><br><span class="line">    ssc.awaitTermination()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">19/11/01 14:18:18 WARN KafkaUtils: overriding enable.auto.commit to false for executor</span><br><span class="line">19/11/01 14:18:18 WARN KafkaUtils: overriding auto.offset.reset to none for executor</span><br><span class="line">19/11/01 14:18:18 WARN KafkaUtils: overriding executor group.id to spark-executor-use_a_separate_group_id_for_each_stream</span><br><span class="line">19/11/01 14:18:18 WARN KafkaUtils: overriding receive.buffer.bytes to 65536 see KAFKA-3135</span><br><span class="line">19/11/01 14:18:20 ERROR JobScheduler: Error running job streaming job 1572589100000 ms.0</span><br><span class="line">---------2</span><br><span class="line">java.lang.ClassCastException: org.apache.spark.rdd.ShuffledRDD cannot be cast to org.apache.spark.streaming.kafka010.HasOffsetRanges</span><br><span class="line">	at com.ruozedata.spark.ss03.StreamingKakfaDirectApp$$anonfun$main$1.apply(StreamingKakfaDirectApp.scala:48)</span><br><span class="line">	at com.ruozedata.spark.ss03.StreamingKakfaDirectApp$$anonfun$main$1.apply(StreamingKakfaDirectApp.scala:42)</span><br><span class="line">	at org.apache.spark.streaming.dstream.DStream$$anonfun$foreachRDD$1$$anonfun$apply$mcV$sp$3.apply(DStream.scala:628)</span><br><span class="line">	at org.apache.spark.streaming.dstream.DStream$$anonfun$foreachRDD$1$$anonfun$apply$mcV$sp$3.apply(DStream.scala:628)</span><br><span class="line">	at org.apache.spark.streaming.dstream.ForEachDStream$$anonfun$1$$anonfun$apply$mcV$sp$1.apply$mcV$sp(ForEachDStream.scala:51)</span><br><span class="line">	at org.apache.spark.streaming.dstream.ForEachDStream$$anonfun$1$$anonfun$apply$mcV$sp$1.apply(ForEachDStream.scala:51)</span><br><span class="line">	at org.apache.spark.streaming.dstream.ForEachDStream$$anonfun$1$$anonfun$apply$mcV$sp$1.apply(ForEachDStream.scala:51)</span><br><span class="line">	at org.apache.spark.streaming.dstream.DStream.createRDDWithLocalProperties(DStream.scala:416)</span><br><span class="line">	at org.apache.spark.streaming.dstream.ForEachDStream$$anonfun$1.apply$mcV$sp(ForEachDStream.scala:50)</span><br><span class="line">	at org.apache.spark.streaming.dstream.ForEachDStream$$anonfun$1.apply(ForEachDStream.scala:50)</span><br><span class="line">	at org.apache.spark.streaming.dstream.ForEachDStream$$anonfun$1.apply(ForEachDStream.scala:50)</span><br><span class="line">	at scala.util.Try$.apply(Try.scala:192)</span><br><span class="line">	at org.apache.spark.streaming.scheduler.Job.run(Job.scala:39)</span><br><span class="line">	at org.apache.spark.streaming.scheduler.JobScheduler$JobHandler$$anonfun$run$1.apply$mcV$sp(JobScheduler.scala:257)</span><br><span class="line">	at org.apache.spark.streaming.scheduler.JobScheduler$JobHandler$$anonfun$run$1.apply(JobScheduler.scala:257)</span><br><span class="line">	at org.apache.spark.streaming.scheduler.JobScheduler$JobHandler$$anonfun$run$1.apply(JobScheduler.scala:257)</span><br><span class="line">	at scala.util.DynamicVariable.withValue(DynamicVariable.scala:58)</span><br><span class="line">	at org.apache.spark.streaming.scheduler.JobScheduler$JobHandler.run(JobScheduler.scala:256)</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.ClassCastException: org.apache.spark.rdd.ShuffledRDD cannot be cast to org.apache.spark.streaming.kafka010.HasOffsetRanges</span><br><span class="line">	at com.ruozedata.spark.ss03.StreamingKakfaDirectApp$$anonfun$main$1.apply(StreamingKakfaDirectApp.scala:48)</span><br><span class="line">	at com.ruozedata.spark.ss03.StreamingKakfaDirectApp$$anonfun$main$1.apply(StreamingKakfaDirectApp.scala:42)</span><br><span class="line">	at org.apache.spark.streaming.dstream.DStream$$anonfun$foreachRDD$1$$anonfun$apply$mcV$sp$3.apply(DStream.scala:628)</span><br><span class="line">	at org.apache.spark.streaming.dstream.DStream$$anonfun$foreachRDD$1$$anonfun$apply$mcV$sp$3.apply(DStream.scala:628)</span><br><span class="line">	at org.apache.spark.streaming.dstream.ForEachDStream$$anonfun$1$$anonfun$apply$mcV$sp$1.apply$mcV$sp(ForEachDStream.scala:51)</span><br><span class="line">	at org.apache.spark.streaming.dstream.ForEachDStream$$anonfun$1$$anonfun$apply$mcV$sp$1.apply(ForEachDStream.scala:51)</span><br><span class="line">	at org.apache.spark.streaming.dstream.ForEachDStream$$anonfun$1$$anonfun$apply$mcV$sp$1.apply(ForEachDStream.scala:51)</span><br><span class="line">	at org.apache.spark.streaming.dstream.DStream.createRDDWithLocalProperties(DStream.scala:416)</span><br><span class="line">	at org.apache.spark.streaming.dstream.ForEachDStream$$anonfun$1.apply$mcV$sp(ForEachDStream.scala:50)</span><br><span class="line">	at org.apache.spark.streaming.dstream.ForEachDStream$$anonfun$1.apply(ForEachDStream.scala:50)</span><br><span class="line">	at org.apache.spark.streaming.dstream.ForEachDStream$$anonfun$1.apply(ForEachDStream.scala:50)</span><br><span class="line">	at scala.util.Try$.apply(Try.scala:192)</span><br><span class="line">	at org.apache.spark.streaming.scheduler.Job.run(Job.scala:39)</span><br><span class="line">	at org.apache.spark.streaming.scheduler.JobScheduler$JobHandler$$anonfun$run$1.apply$mcV$sp(JobScheduler.scala:257)</span><br><span class="line">	at org.apache.spark.streaming.scheduler.JobScheduler$JobHandler$$anonfun$run$1.apply(JobScheduler.scala:257)</span><br><span class="line">	at org.apache.spark.streaming.scheduler.JobScheduler$JobHandler$$anonfun$run$1.apply(JobScheduler.scala:257)</span><br><span class="line">	at scala.util.DynamicVariable.withValue(DynamicVariable.scala:58)</span><br><span class="line">	at org.apache.spark.streaming.scheduler.JobScheduler$JobHandler.run(JobScheduler.scala:256)</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:748)</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191101142414924.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">为什么报错呢？  *****  而且分区数还是2  说明不对</span><br><span class="line">java.lang.ClassCastException: org.apache.spark.rdd.ShuffledRDD cannot be cast to org.apache.spark.streaming.kafka010.HasOffsetRanges</span><br><span class="line"></span><br><span class="line">ShuffledRDD 不能转成 HasOffsetRanges 上面图片解释了 </span><br><span class="line"></span><br><span class="line">为什么是ShuffledRDD 呢？ </span><br><span class="line">	因为reduceBykey之后的流里面 的rdd   就是ShuffledRDD 类型的   主要是经过了reduceBykey 明白吗</span><br><span class="line"></span><br><span class="line">所以上面的代码 不对 </span><br><span class="line">业务逻辑的代码是要放在里面写  而不是在前面做   ***</span><br><span class="line">所以直接用stream + foreachRDD   (业务逻辑在foreachRDD 里面写)</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191101143014894.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">获取offset：</span><br><span class="line">object StreamingKakfaDirectApp &#123;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line"></span><br><span class="line">    val ssc = ContextUtils.getStreamingContext(this.getClass.getSimpleName, 10)</span><br><span class="line"></span><br><span class="line">    val kafkaParams = Map[String, Object](</span><br><span class="line">      &quot;bootstrap.servers&quot; -&gt; &quot;hadoop101:9092,hadoop101:9093,hadoop101:9094&quot;,   //Kafka地址</span><br><span class="line">      &quot;key.deserializer&quot; -&gt; classOf[StringDeserializer],      //反序列化  接收端是反序列化   数据发送是要序列化</span><br><span class="line">      &quot;value.deserializer&quot; -&gt; classOf[StringDeserializer],</span><br><span class="line">      &quot;group.id&quot; -&gt; &quot;use_a_separate_group_id_for_each_stream&quot;,</span><br><span class="line">      &quot;auto.offset.reset&quot; -&gt; &quot;earliest&quot;,    //偏移量 从哪开始</span><br><span class="line">      &quot;enable.auto.commit&quot; -&gt; (false: java.lang.Boolean)  //自动提交么？ 选择不自动提交  手工来管理</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    val topics = Array(&quot;double_happy_offset&quot;)</span><br><span class="line">    val stream = KafkaUtils.createDirectStream[String, String](</span><br><span class="line">      ssc,</span><br><span class="line">      PreferConsistent,  //数据尽量均匀分布到各个executor上去</span><br><span class="line">      Subscribe[String, String](topics, kafkaParams)  //固定写法</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    //结果</span><br><span class="line">    stream.foreachRDD(rdd =&gt;&#123;   //这块的rdd一定要注意的  </span><br><span class="line"></span><br><span class="line">      //获取分区数</span><br><span class="line">      println(&quot;---------&quot;+rdd.partitions.size)   //这个值应该是3</span><br><span class="line"></span><br><span class="line">      //获取当前批次的offset数据</span><br><span class="line">      val offsetRanges = rdd.asInstanceOf[HasOffsetRanges].offsetRanges</span><br><span class="line">      offsetRanges.foreach(x=&gt;&#123;</span><br><span class="line">        println(s&quot;$&#123;x.topic&#125; $&#123;x.partition&#125; $&#123;x.fromOffset&#125; $&#123;x.untilOffset&#125;&quot;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    ssc.start()</span><br><span class="line">    ssc.awaitTermination()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：他是一直在跑的哈</span><br><span class="line">---------3</span><br><span class="line">double_happy_offset 1 0 8</span><br><span class="line">double_happy_offset 2 0 6</span><br><span class="line">double_happy_offset 0 0 6</span><br><span class="line">---------3</span><br><span class="line">double_happy_offset 1 8 8</span><br><span class="line">double_happy_offset 2 6 6</span><br><span class="line">double_happy_offset 0 6 6</span><br><span class="line">---------3</span><br><span class="line">double_happy_offset 1 8 8</span><br><span class="line">double_happy_offset 2 6 6</span><br><span class="line">double_happy_offset 0 6 6</span><br><span class="line"></span><br><span class="line">看sparkUI   解释 结果</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191101143701991.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">$&#123;x.topic&#125; $&#123;x.partition&#125; $&#123;x.fromOffset&#125; $&#123;x.untilOffset&#125;</span><br><span class="line">---------3</span><br><span class="line">double_happy_offset 1 0 8</span><br><span class="line">double_happy_offset 2 0 6</span><br><span class="line">double_happy_offset 0 0 6</span><br><span class="line">---------3</span><br><span class="line">double_happy_offset 1 8 8         从8 开始   因为没有数据进来了 </span><br><span class="line">double_happy_offset 2 6 6</span><br><span class="line">double_happy_offset 0 6 6</span><br><span class="line">---------3</span><br><span class="line">double_happy_offset 1 8 8</span><br><span class="line">double_happy_offset 2 6 6</span><br><span class="line">double_happy_offset 0 6 6</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">20哪里来的？  8 +6+6 = 20</span><br><span class="line"></span><br><span class="line">由于数据过来 第一个批次全部处理完了  </span><br><span class="line">所以第二个批次 结果 是从8开始  </span><br><span class="line"></span><br><span class="line">那么我再生产10条数据 看结果</span><br><span class="line"></span><br><span class="line">---------3</span><br><span class="line">double_happy_offset 1 8 8</span><br><span class="line">double_happy_offset 2 6 6</span><br><span class="line">double_happy_offset 0 6 6</span><br><span class="line">---------3</span><br><span class="line">double_happy_offset 2 6 9          也就是说 这个拿了3条数据</span><br><span class="line">double_happy_offset 1 8 12        拿了4条数据</span><br><span class="line">double_happy_offset 0 6 9          拿了3条数据</span><br><span class="line">---------3</span><br><span class="line"></span><br><span class="line">那么 我把程序关掉 结果一定是这样的：</span><br><span class="line">---------3</span><br><span class="line">double_happy_offset 1 0 9</span><br><span class="line">double_happy_offset 2 0 12</span><br><span class="line">double_happy_offset 0 0 9</span><br><span class="line"></span><br><span class="line">你获得到了偏移量  由于你没有提交 没有保存偏移量 </span><br><span class="line">所以重启之后都是从头开始跑的  就意味着 第一批数据 会很多 </span><br><span class="line"></span><br><span class="line">接下来就是提交offset</span><br></pre></td></tr></table></figure></div>
<p><a href="http://spark.apache.org/docs/latest/streaming-kafka-0-10-integration.html#storing-offsets" target="_blank" rel="noopener">Storing Offsets</a></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">很多方式 ：</span><br><span class="line">1.Checkpoints   别用了 不好用 </span><br><span class="line">2.Kafka itself    </span><br><span class="line">	Kafka has an offset commit API that stores offsets in a special Kafka topic.</span><br><span class="line">3.Your own data store</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">2.Kafka itself    ：</span><br><span class="line"></span><br><span class="line">object StreamingKakfaDirectApp &#123;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line"></span><br><span class="line">    val ssc = ContextUtils.getStreamingContext(this.getClass.getSimpleName, 10)</span><br><span class="line"></span><br><span class="line">    val kafkaParams = Map[String, Object](</span><br><span class="line">      &quot;bootstrap.servers&quot; -&gt; &quot;hadoop101:9092,hadoop101:9093,hadoop101:9094&quot;,   //Kafka地址</span><br><span class="line">      &quot;key.deserializer&quot; -&gt; classOf[StringDeserializer],      //反序列化  接收端是反序列化   数据发送是要序列化</span><br><span class="line">      &quot;value.deserializer&quot; -&gt; classOf[StringDeserializer],</span><br><span class="line">      &quot;group.id&quot; -&gt; &quot;use_a_separate_group_id_for_each_stream&quot;,</span><br><span class="line">      &quot;auto.offset.reset&quot; -&gt; &quot;earliest&quot;,    //偏移量 从哪开始</span><br><span class="line">      &quot;enable.auto.commit&quot; -&gt; (false: java.lang.Boolean)  //自动提交么？ 选择不自动提交  手工来管理</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    val topics = Array(&quot;double_happy_offset&quot;)</span><br><span class="line">    val stream = KafkaUtils.createDirectStream[String, String](</span><br><span class="line">      ssc,</span><br><span class="line">      PreferConsistent,  //数据尽量均匀分布到各个executor上去</span><br><span class="line">      Subscribe[String, String](topics, kafkaParams)  //固定写法</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    //结果</span><br><span class="line">    stream.foreachRDD(rdd =&gt;&#123;   //这块的rdd一定要注意的  因为</span><br><span class="line"></span><br><span class="line">      //获取分区数</span><br><span class="line">      println(&quot;---------&quot;+rdd.partitions.size)   //这个值应该是3</span><br><span class="line"></span><br><span class="line">      //获取当前批次的offset数据</span><br><span class="line">      val offsetRanges = rdd.asInstanceOf[HasOffsetRanges].offsetRanges</span><br><span class="line">      offsetRanges.foreach(x=&gt;&#123;</span><br><span class="line">        println(s&quot;$&#123;x.topic&#125; $&#123;x.partition&#125; $&#123;x.fromOffset&#125; $&#123;x.untilOffset&#125;&quot;)</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      //kafka自身的方式  提交 更新的offset</span><br><span class="line">      stream.asInstanceOf[CanCommitOffsets].commitAsync(offsetRanges)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    ssc.start()</span><br><span class="line">    ssc.awaitTermination()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">---------3</span><br><span class="line">double_happy_offset 2 0 9</span><br><span class="line">double_happy_offset 1 0 12</span><br><span class="line">double_happy_offset 0 0 9</span><br><span class="line">---------3</span><br><span class="line">double_happy_offset 2 9 9</span><br><span class="line">double_happy_offset 1 12 12</span><br><span class="line">double_happy_offset 0 9 9</span><br><span class="line">---------3</span><br><span class="line"></span><br><span class="line">关闭重启 之后结果：</span><br><span class="line">---------3</span><br><span class="line">double_happy_offset 2 9 9</span><br><span class="line">double_happy_offset 1 12 12</span><br><span class="line">double_happy_offset 0 9 9</span><br><span class="line">---------3</span><br><span class="line">double_happy_offset 2 9 9</span><br><span class="line">double_happy_offset 1 12 12</span><br><span class="line">double_happy_offset 0 9 9</span><br><span class="line"></span><br><span class="line">说明offset 提交ok了 </span><br><span class="line"></span><br><span class="line">而且两次操作sparkUi也证实了</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191101145733172.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="第一次"><br>第二次 重启之后<br><img src="https://img-blog.csdnimg.cn/2019110114582759.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">数据是0 对吧  因为数据已经提交过了 </span><br><span class="line">通过 kafka 命令可以查到offset </span><br><span class="line"></span><br><span class="line">[double_happy@hadoop101 bin]$ ./kafka-run-class.sh kafka.tools.GetOffsetShell --broker-list hadoop101:9092,hadoop101:9093,hadoop101:9094 --topic double_happy_offset</span><br><span class="line">double_happy_offset:0:9</span><br><span class="line">double_happy_offset:1:12</span><br><span class="line">double_happy_offset:2:9</span><br><span class="line">[double_happy@hadoop101 bin]$ </span><br><span class="line"></span><br><span class="line">那么kafka自身维护的offset存在哪里呢？</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191101150455299.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>However, you can <strong>commit offsets to Kafka after you know your output has been stored,</strong> using the commitAsync API. The benefit as compared to checkpoints is that Kafka is a durable store regardless of changes to your application code. However, <strong>Kafka is not transactional, so your outputs must still be idempotent.</strong></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1.你的业务逻辑完成之后再提交offset</span><br><span class="line">2.kafka并不是事务性的 所以你的输出 必须保证幂等性</span><br><span class="line"></span><br><span class="line">假设 </span><br><span class="line">double_happy_offset:0:9</span><br><span class="line">double_happy_offset:1:12</span><br><span class="line">double_happy_offset:2:9</span><br><span class="line"></span><br><span class="line">你第一次处理完了 结果也写到redis里了  </span><br><span class="line">因为种种原因我们可以手工指定 kafka的偏移量的  </span><br><span class="line"></span><br><span class="line">假设 第一个批次 5 接下来是 5-9   这里 5-9 已经消费了对吧 </span><br><span class="line"></span><br><span class="line">那么 我们手工指定 5-9 这个批次再消费一次 也就是说 </span><br><span class="line">redis 里面的结果又是错的  因为结果又重复了呀  这就是上面刚开始的 演示  </span><br><span class="line"></span><br><span class="line">这就是说你输出的代码 也要有幂等性  不管你输出跑多少次  即使重复消费 也要保证结果是具有幂等性的</span><br></pre></td></tr></table></figure></div>

<p><strong>3.Your own data store</strong></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">这里我使用redis  你选择MySQL也是可以的    为了测试换一个groupid  让他重新消费</span><br><span class="line">注意：这种方式 提交offset</span><br><span class="line">手动提交offset的时候  要与groupid 对应 </span><br><span class="line"></span><br><span class="line">key： Topic + groupid </span><br><span class="line"></span><br><span class="line">object StreamingKakfaDirectApp &#123;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line"></span><br><span class="line">    val ssc = ContextUtils.getStreamingContext(this.getClass.getSimpleName, 10)</span><br><span class="line"></span><br><span class="line">    val groupId = &quot;double_happy_group&quot;</span><br><span class="line"></span><br><span class="line">    val topic = &quot;double_happy_offset&quot;</span><br><span class="line"></span><br><span class="line">    val kafkaParams = Map[String, Object](</span><br><span class="line">      &quot;bootstrap.servers&quot; -&gt; &quot;hadoop101:9092,hadoop101:9093,hadoop101:9094&quot;,   //Kafka地址</span><br><span class="line">      &quot;key.deserializer&quot; -&gt; classOf[StringDeserializer],      //反序列化  接收端是反序列化   数据发送是要序列化</span><br><span class="line">      &quot;value.deserializer&quot; -&gt; classOf[StringDeserializer],</span><br><span class="line">      &quot;group.id&quot; -&gt; groupId,</span><br><span class="line">      &quot;auto.offset.reset&quot; -&gt; &quot;earliest&quot;,    //偏移量 从哪开始</span><br><span class="line">      &quot;enable.auto.commit&quot; -&gt; (false: java.lang.Boolean)  //自动提交么？ 选择不自动提交  手工来管理</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    val topics = Array(topic)</span><br><span class="line">    val stream = KafkaUtils.createDirectStream[String, String](</span><br><span class="line">      ssc,</span><br><span class="line">      PreferConsistent,  //数据尽量均匀分布到各个executor上去</span><br><span class="line">      Subscribe[String, String](topics, kafkaParams)  //固定写法</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    //结果</span><br><span class="line">    stream.foreachRDD(rdd =&gt;&#123;   //这块的rdd一定要注意的  因为</span><br><span class="line"></span><br><span class="line">      if(!rdd.isEmpty())&#123;</span><br><span class="line"></span><br><span class="line">        //获取分区数</span><br><span class="line">        println(&quot;---------&quot;+rdd.partitions.size)   //这个值应该是3</span><br><span class="line"></span><br><span class="line">        //获取当前批次的offset数据</span><br><span class="line">        val offsetRanges = rdd.asInstanceOf[HasOffsetRanges].offsetRanges</span><br><span class="line">        offsetRanges.foreach(x=&gt;&#123;</span><br><span class="line">          println(s&quot;$&#123;x.topic&#125; $&#123;x.partition&#125; $&#123;x.fromOffset&#125; $&#123;x.untilOffset&#125;&quot;)</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //TODO ... 处理业务逻辑 wc</span><br><span class="line"></span><br><span class="line">        //ToDO ... 提交Offset到Redis  使用第三种方式</span><br><span class="line">        val jedis: Jedis = RedisUtils.getJedis</span><br><span class="line"></span><br><span class="line">        offsetRanges.foreach(x=&gt;&#123;</span><br><span class="line">          val topicGroupId = x.topic + &quot;_&quot;+ groupId    //key = topic + groupId    </span><br><span class="line">          jedis.hset(topicGroupId,x.partition+&quot;&quot;,x.untilOffset+&quot;&quot;)</span><br><span class="line">        &#125;)</span><br><span class="line">        jedis.close()</span><br><span class="line"></span><br><span class="line">      &#125;else&#123;</span><br><span class="line">        println(&quot;当前批次没有数据.....&quot;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    ssc.start()</span><br><span class="line">    ssc.awaitTermination()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">---------3</span><br><span class="line">double_happy_offset 2 0 9</span><br><span class="line">double_happy_offset 1 0 12</span><br><span class="line">double_happy_offset 0 0 9</span><br><span class="line">当前批次没有数据.....</span><br><span class="line">当前批次没有数据.....</span><br><span class="line">当前批次没有数据.....</span><br><span class="line">当前批次没有数据.....</span><br><span class="line"></span><br><span class="line">hadoop101:6379&gt; keys *</span><br><span class="line">1) &quot;name&quot;</span><br><span class="line">2) &quot;kafka_ss_redis_wc&quot;</span><br><span class="line">3) &quot;doublehappy_redis_wc&quot;</span><br><span class="line">4) &quot;double_happy_offset_double_happy_group&quot;</span><br><span class="line">hadoop101:6379&gt; HGETALL double_happy_offset_double_happy_group</span><br><span class="line">1) &quot;2&quot;</span><br><span class="line">2) &quot;9&quot;</span><br><span class="line">3) &quot;1&quot;</span><br><span class="line">4) &quot;12&quot;</span><br><span class="line">5) &quot;0&quot;</span><br><span class="line">6) &quot;9&quot;</span><br><span class="line">hadoop101:6379&gt; </span><br><span class="line">结果是没有问题 的 </span><br><span class="line">key = topic + groupId      </span><br><span class="line"> jedis.hset(topicGroupId,x.partition+&quot;&quot;,x.untilOffset+&quot;&quot;)</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191101162513463.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">再生产一批数据 查看结果：</span><br><span class="line">---------3</span><br><span class="line">double_happy_offset 2 0 9</span><br><span class="line">double_happy_offset 1 0 12</span><br><span class="line">double_happy_offset 0 0 9</span><br><span class="line">当前批次没有数据.....</span><br><span class="line">当前批次没有数据.....</span><br><span class="line">当前批次没有数据.....</span><br><span class="line">---------3</span><br><span class="line">double_happy_offset 1 12 16</span><br><span class="line">double_happy_offset 2 9 12</span><br><span class="line">double_happy_offset 0 9 12</span><br><span class="line">当前批次没有数据.....</span><br><span class="line">当前批次没有数据.....</span><br><span class="line">当前批次没有数据.....</span><br><span class="line">当前批次没有数据.....</span><br><span class="line"></span><br><span class="line">hadoop101:6379&gt; HGETALL double_happy_offset_double_happy_group</span><br><span class="line">1) &quot;2&quot;</span><br><span class="line">2) &quot;9&quot;</span><br><span class="line">3) &quot;1&quot;</span><br><span class="line">4) &quot;12&quot;</span><br><span class="line">5) &quot;0&quot;</span><br><span class="line">6) &quot;9&quot;</span><br><span class="line">hadoop101:6379&gt; HGETALL double_happy_offset_double_happy_group</span><br><span class="line">1) &quot;2&quot;</span><br><span class="line">2) &quot;12&quot;</span><br><span class="line">3) &quot;1&quot;</span><br><span class="line">4) &quot;16&quot;</span><br><span class="line">5) &quot;0&quot;</span><br><span class="line">6) &quot;12&quot;</span><br><span class="line">hadoop101:6379&gt;</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191101162924889.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">我把程序关掉 先生成两个批次的数据  再把程序打开  查看结果</span><br><span class="line"></span><br><span class="line">---------3</span><br><span class="line">double_happy_offset 0 0 18</span><br><span class="line">double_happy_offset 2 0 18</span><br><span class="line">double_happy_offset 1 0 24</span><br><span class="line">当前批次没有数据.....</span><br><span class="line">当前批次没有数据.....</span><br><span class="line"></span><br><span class="line">为什么从0开始消费？？</span><br><span class="line">因为 </span><br><span class="line">&quot;auto.offset.reset&quot; -&gt; &quot;earliest&quot;   控制的 </span><br><span class="line">应该是 你offset保存在哪里  下次启动的时候去哪里取</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">测试：取出 offset 从redis</span><br><span class="line"></span><br><span class="line">object RedisOffsetApp &#123;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line"></span><br><span class="line">    val groupId = &quot;double_happy_group&quot;</span><br><span class="line"></span><br><span class="line">    val topic = &quot;double_happy_offset&quot;</span><br><span class="line"></span><br><span class="line">    val topics = Array(topic)</span><br><span class="line"></span><br><span class="line">    //TODO...从保存offset的地方 eg：redis 去获取已经提交的offset的记录信息</span><br><span class="line"></span><br><span class="line">    val jedis: Jedis = RedisUtils.getJedis</span><br><span class="line">    val offsets: util.Map[String, String] = jedis.hgetAll(topics(0)+&quot;_&quot;+groupId)</span><br><span class="line"></span><br><span class="line">    import  scala.collection.JavaConversions._   //offsets 想使用  scala 里集合的map方法 要进行隐式转换 java-&gt; scala</span><br><span class="line"></span><br><span class="line">    offsets.map(x=&gt; &#123;</span><br><span class="line"></span><br><span class="line">      //  offsets map后要获取一种什么样的数据结构呢？ </span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">//  offsets map后要获取一种什么样的数据结构呢？ 之前KafkaUtils.createDirectStream 里面的消费策略</span><br><span class="line">Subscribe 传入 topics 和 kafkaParams  查看源码发现 </span><br><span class="line"></span><br><span class="line">  def Subscribe[K, V](</span><br><span class="line">      topics: Iterable[jl.String],</span><br><span class="line">      kafkaParams: collection.Map[String, Object],</span><br><span class="line">      offsets: collection.Map[TopicPartition, Long]): ConsumerStrategy[K, V] = &#123;</span><br><span class="line">    new Subscribe[K, V](</span><br><span class="line">      new ju.ArrayList(topics.asJavaCollection),</span><br><span class="line">      new ju.HashMap[String, Object](kafkaParams.asJava),</span><br><span class="line">      new ju.HashMap[TopicPartition, jl.Long](offsets.mapValues(l =&gt; new jl.Long(l)).asJava))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> offsets: collection.Map[TopicPartition, Long])    即  TopicPartition 和 偏移量  组成的这样的格式  Map[TopicPartition, Long]</span><br><span class="line"></span><br><span class="line">    public TopicPartition(String topic, int partition) &#123;</span><br><span class="line">        this.partition = partition;</span><br><span class="line">        this.topic = topic;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">所以取出 offset 从redis  取出的数据结构设计要符合 </span><br><span class="line">createDirectStream  里的 Subscribe 参数的数据结构</span><br><span class="line"></span><br><span class="line">(因为 取出 offset 从redis  是在  createDirectStream之前执行的 )</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">object RedisOffsetApp &#123;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line"></span><br><span class="line">    val groupId = &quot;double_happy_group&quot;</span><br><span class="line">    val topic = &quot;double_happy_offset&quot;</span><br><span class="line">    val topics = Array(topic)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //TODO...从保存offset的地方 eg：redis 去获取已经提交的offset的记录信息</span><br><span class="line"></span><br><span class="line">    val jedis: Jedis = RedisUtils.getJedis</span><br><span class="line">    val offsets: util.Map[String, String] = jedis.hgetAll(topics(0) + &quot;_&quot; + groupId)</span><br><span class="line"></span><br><span class="line">    var fromOffsets: Map[TopicPartition, Long] = Map[TopicPartition, Long]()</span><br><span class="line"></span><br><span class="line">    import scala.collection.JavaConversions._ //offsets 想使用  scala 里集合的map方法 要进行隐式转换 java-&gt; scala</span><br><span class="line">    offsets.map(x =&gt; &#123;</span><br><span class="line"></span><br><span class="line">      //  offsets map后要获取一种什么样的数据结构呢？ offsets  Map[TopicPartition, Long]()</span><br><span class="line">      fromOffsets += new TopicPartition(topics(0), x._1.toInt) -&gt; x._2.toLong</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    fromOffsets.foreach(println)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">(double_happy_offset-0,18)</span><br><span class="line">(double_happy_offset-1,24)</span><br><span class="line">(double_happy_offset-2,18)</span><br><span class="line"></span><br><span class="line">取出 offset 从redis</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">所以我们再测试实时的代码  ：</span><br><span class="line">	我们先不提交 看看控制台 </span><br><span class="line">object StreamingKakfaDirectApp &#123;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line"></span><br><span class="line">    val ssc = ContextUtils.getStreamingContext(this.getClass.getSimpleName, 10)</span><br><span class="line"></span><br><span class="line">    val groupId = &quot;double_happy_group&quot;</span><br><span class="line"></span><br><span class="line">    val topic = &quot;double_happy_offset&quot;</span><br><span class="line"></span><br><span class="line">    val kafkaParams = Map[String, Object](</span><br><span class="line">      &quot;bootstrap.servers&quot; -&gt; &quot;hadoop101:9092,hadoop101:9093,hadoop101:9094&quot;,   //Kafka地址</span><br><span class="line">      &quot;key.deserializer&quot; -&gt; classOf[StringDeserializer],      //反序列化  接收端是反序列化   数据发送是要序列化</span><br><span class="line">      &quot;value.deserializer&quot; -&gt; classOf[StringDeserializer],</span><br><span class="line">      &quot;group.id&quot; -&gt; groupId,</span><br><span class="line">      &quot;auto.offset.reset&quot; -&gt; &quot;earliest&quot;,    //偏移量 从哪开始</span><br><span class="line">      &quot;enable.auto.commit&quot; -&gt; (false: java.lang.Boolean)  //自动提交么？ 选择不自动提交  手工来管理</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    val topics = Array(topic)</span><br><span class="line">    var fromOffsets: Map[TopicPartition, Long] = Map[TopicPartition, Long]()</span><br><span class="line"></span><br><span class="line">    //TODO...从保存offset的地方 eg：redis 去获取已经提交的offset的记录信息</span><br><span class="line">    val jedis: Jedis = RedisUtils.getJedis</span><br><span class="line">    val offsets: util.Map[String, String] = jedis.hgetAll(topics(0)+&quot;_&quot;+groupId)</span><br><span class="line"></span><br><span class="line">     //offsets 想使用  scala 里集合的map方法 要进行隐式转换 java-&gt; scala</span><br><span class="line">    import scala.collection.JavaConversions._</span><br><span class="line">    offsets.map(x =&gt; &#123;</span><br><span class="line">      //offsets map后要获取一种什么样的数据结构呢？ offsets  Map[TopicPartition, Long]()</span><br><span class="line">      fromOffsets += new TopicPartition(topics(0), x._1.toInt) -&gt; x._2.toLong</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    val stream = KafkaUtils.createDirectStream[String, String](</span><br><span class="line">      ssc,</span><br><span class="line">      PreferConsistent,  //数据尽量均匀分布到各个executor上去</span><br><span class="line">      Subscribe[String, String](topics, kafkaParams,fromOffsets)  //从已有的offset里读取数据 开始消费</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    //结果</span><br><span class="line">    stream.foreachRDD(rdd =&gt;&#123;   //这块的rdd一定要注意的  因为</span><br><span class="line"></span><br><span class="line">      if(!rdd.isEmpty())&#123;</span><br><span class="line"></span><br><span class="line">        //获取分区数</span><br><span class="line">        println(&quot;---------&quot;+rdd.partitions.size)   //这个值应该是3</span><br><span class="line"></span><br><span class="line">        //获取当前批次的offset数据</span><br><span class="line">        val offsetRanges = rdd.asInstanceOf[HasOffsetRanges].offsetRanges</span><br><span class="line">        offsetRanges.foreach(x=&gt;&#123;</span><br><span class="line">          println(s&quot;$&#123;x.topic&#125; $&#123;x.partition&#125; $&#123;x.fromOffset&#125; $&#123;x.untilOffset&#125;&quot;)</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        //TODO ... 处理业务逻辑 wc</span><br><span class="line"></span><br><span class="line">/*        //ToDO ... 提交Offset到Redis  使用第三种方式</span><br><span class="line">        val jedis: Jedis = RedisUtils.getJedis</span><br><span class="line"></span><br><span class="line">        offsetRanges.foreach(x=&gt;&#123;</span><br><span class="line">          val topicGroupId = x.topic + &quot;_&quot;+ groupId</span><br><span class="line">          jedis.hset(topicGroupId,x.partition+&quot;&quot;,x.untilOffset+&quot;&quot;)</span><br><span class="line">        &#125;)</span><br><span class="line">        jedis.close()*/</span><br><span class="line"></span><br><span class="line">      &#125;else&#123;</span><br><span class="line"></span><br><span class="line">        println(&quot;当前批次没有数据.....&quot;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    ssc.start()</span><br><span class="line">    ssc.awaitTermination()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">19/11/01 17:14:51 WARN KafkaUtils: overriding receive.buffer.bytes to 65536 see KAFKA-3135</span><br><span class="line">当前批次没有数据.....</span><br><span class="line">当前批次没有数据.....</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">说明ok  没有重新消费 </span><br><span class="line"></span><br><span class="line">那么我们再写一批数据 查看结果：</span><br><span class="line"></span><br><span class="line">当前批次没有数据.....</span><br><span class="line">当前批次没有数据.....</span><br><span class="line">当前批次没有数据.....</span><br><span class="line">当前批次没有数据.....</span><br><span class="line">当前批次没有数据.....</span><br><span class="line">---------3</span><br><span class="line">double_happy_offset 0 18 21</span><br><span class="line">double_happy_offset 1 24 28</span><br><span class="line">double_happy_offset 2 18 21</span><br><span class="line">当前批次没有数据.....</span><br><span class="line"></span><br><span class="line">说明程序ok</span><br><span class="line"></span><br><span class="line">那么我们把实时程序停掉 再产生两次数据 再重启实时程序  对比最初的那次测试：</span><br><span class="line"></span><br><span class="line">还记得么？最初那次 是从0 开始消费的  那么这次测试结果呢？</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">---------3</span><br><span class="line">double_happy_offset 1 24 36</span><br><span class="line">double_happy_offset 0 18 27</span><br><span class="line">double_happy_offset 2 18 27</span><br><span class="line">当前批次没有数据.....</span><br><span class="line"></span><br><span class="line">终于ok了 (这是打印在控制台)</span><br><span class="line"></span><br><span class="line">那么写入redis offset 测试也是ok的</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">总结：</span><br><span class="line">虽然上面的东西一大坨 实际上思路很清晰 很简单 主要是几行破代码 </span><br><span class="line"></span><br><span class="line">而且大部分演示的都是不能用的 但是目的是让你知道 这些坑 而不是直接拿代码直接用 (了解原理之后可以 要不然之后出错了你都不知道怎么维护)</span><br></pre></td></tr></table></figure></div>
<p><strong>总结</strong></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.  &quot;auto.offset.reset&quot; -&gt; &quot;earliest&quot;  </span><br><span class="line">  最终成品 这个参数设置选别的还是 这个 都无所谓的 </span><br><span class="line">  因为你的offsets 是走的 fromOffsets 你自己定义的那个 </span><br><span class="line">  	(就是把你们保存的offset 拿出来丢到 fromOffsets  这里(格式是重点)   创建流的时候 把fromOffsets 丢到消费策略那个参数里)</span><br><span class="line"></span><br><span class="line">2.业务处理前的第一件事是把偏移量拿到 (就是foreachRDD里面第一件事)</span><br></pre></td></tr></table></figure></div>
      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-SS02" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/20/SS02/">SS02</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2018/02/20/SS02/" class="article-date">
  <time datetime="2018-02-20T12:11:27.000Z" itemprop="datePublished">2018-02-20</time>
</a>
    
    
  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <p><a href="https://spark.apache.org/docs/latest/streaming-programming-guide.html#transformations-on-dstreams" target="_blank" rel="noopener">Transformations on DStreams</a></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">updateStateByKey：</span><br><span class="line"></span><br><span class="line">先看一个案例</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[double_happy@hadoop101 ~]$ nc -lk 9999</span><br><span class="line">a,a,a,d,d</span><br><span class="line">a,a,a,d,d</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">object StreamingWCApp01 &#123;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line"></span><br><span class="line">    val ssc = ContextUtils.getStreamingContext(this.getClass.getSimpleName, 10)</span><br><span class="line"></span><br><span class="line">    val lines = ssc.socketTextStream(&quot;hadoop101&quot;,9999)</span><br><span class="line"></span><br><span class="line">    val result = lines.flatMap(_.split(&quot;,&quot;))</span><br><span class="line">      .map((_,1))</span><br><span class="line">      .reduceByKey(_+_)</span><br><span class="line"></span><br><span class="line">    result.print()</span><br><span class="line"></span><br><span class="line">    ssc.start()</span><br><span class="line">    ssc.awaitTermination()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果是：</span><br><span class="line">-------------------------------------------</span><br><span class="line">Time: 1572519050000 ms</span><br><span class="line">-------------------------------------------</span><br><span class="line">(d,4)</span><br><span class="line">(a,6)</span><br><span class="line"></span><br><span class="line">-------------------------------------------</span><br><span class="line">Time: 1572519060000 ms</span><br><span class="line">-------------------------------------------</span><br><span class="line"></span><br><span class="line">-------------------------------------------</span><br><span class="line">Time: 1572519070000 ms</span><br><span class="line">-------------------------------------------</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">这个计算 只计算当前批次的 之后批次 没有数据 </span><br><span class="line"></span><br><span class="line">需求：</span><br><span class="line">	统计 从现在时间点 到 10分钟之后的 a出现的次数  ？对于</span><br><span class="line">	上面的代码是无法满足 的    (也可以满足 存起来 再加 也可以)</span><br><span class="line"></span><br><span class="line">对于累计的需求该这么办呢？</span><br><span class="line"></span><br><span class="line">这就引出一个有没有状态的问题。</span><br><span class="line"></span><br><span class="line">状态：State</span><br><span class="line">    无状态的        只与当前批次有关的 叫无状态</span><br><span class="line">    有状态的        前后批次是有关系的   eg：需要把之前的历史到当前的时间点 需要累计起来</span><br><span class="line"></span><br><span class="line">实现有状态的 需求 使用updateStateByKey算子***</span><br><span class="line"></span><br><span class="line">updateStateByKey ：更新你的状态 通过key 来更新   怎么更新 传入一个function 即可 eg:累加 还是别的 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">updateStateByKey(func)	：</span><br><span class="line">	Return a new &quot;state&quot; DStream where the state for each key is updated </span><br><span class="line">	by applying the given function on the previous state of the key </span><br><span class="line">	and the new values for the key. </span><br><span class="line">	This can be used to maintain arbitrary state data for each key.</span><br></pre></td></tr></table></figure></div>
<p><a href="https://spark.apache.org/docs/latest/streaming-programming-guide.html#updatestatebykey-operation" target="_blank" rel="noopener">UpdateStateByKey Operation</a></p>
<p>The updateStateByKey operation allows you to maintain arbitrary state while continuously updating it with new information. To use this, you will have to do two steps.</p>
<p>   1.Define the state - The state can be an arbitrary data type.</p>
<p>   2.Define the state update function - Specify with a function how to update the state<br>     using the <strong>previous state and the new values from an input stream.</strong></p>
<p>In every batch, Spark will apply the state update function for all existing keys, regardless of whether they have new data in a batch or not. If the update function returns None then the key-value pair will be eliminated.</p>
<p>Let’s illustrate this with an example. Say you want to maintain a running count of each word seen in a text data stream. Here, the running count is the state and it is an integer. We define the update function as:</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">updateStateByKey operation ：</span><br><span class="line">	1.Define the state</span><br><span class="line">	2.Define the state update function</span><br><span class="line"></span><br><span class="line">对于上面给的wc例子 ：</span><br><span class="line">哪个东西是state    应该是 value </span><br><span class="line"></span><br><span class="line">updateStateByKey  通过key 来更新谁 ( 你可以这么理解)</span><br></pre></td></tr></table></figure></div>
<p>案例：</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. </span><br><span class="line"> val result = lines.flatMap(_.split(&quot;,&quot;))</span><br><span class="line">      .map((_,1))</span><br><span class="line">      .reduceByKey(_+_)</span><br><span class="line">      </span><br><span class="line">reduceByKey(_+_)  是对当前批次的累计 所以这里不能这么写</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">object StreamingWCApp01 &#123;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line"></span><br><span class="line">    val ssc = ContextUtils.getStreamingContext(this.getClass.getSimpleName, 10)</span><br><span class="line"></span><br><span class="line">    val lines = ssc.socketTextStream(&quot;hadoop101&quot;,9999)</span><br><span class="line"></span><br><span class="line">    val result = lines.flatMap(_.split(&quot;,&quot;))</span><br><span class="line">      .map((_,1))</span><br><span class="line">      .updateStateByKey(updateFunction)</span><br><span class="line"></span><br><span class="line">    result.print()</span><br><span class="line"></span><br><span class="line">    ssc.start()</span><br><span class="line">    ssc.awaitTermination()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">    *</span><br><span class="line">    * 1批次：  a a a d d</span><br><span class="line">    * 2批次：  b b b c c a</span><br><span class="line">    *</span><br><span class="line">    *newValues : 当前批次的值</span><br><span class="line">    *           key对应的新值(或者有新的key)  可能有多个 所以是一个Seq</span><br><span class="line">    * preValues : 以前批次的累加值</span><br><span class="line">    *             key已经存在的值  有可能没有 有可能有  所以定义成Option  有就返回some  没有返回none</span><br><span class="line">    *</span><br><span class="line">    */</span><br><span class="line">  def updateFunction(newValues: Seq[Int], preValues: Option[Int]): Option[Int] = &#123;</span><br><span class="line">    //newValues : (b,1)(b,1)(b,1)(c,1)(c,1) (a,1)</span><br><span class="line"></span><br><span class="line">    val curr = newValues.sum // 当前批次</span><br><span class="line">    val pre = preValues.getOrElse(0)   //老的值   (a,3) (d,2)   拿出值  key没有的  就赋值为0</span><br><span class="line">    Some(curr + pre)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">19/10/31 19:21:07 ERROR StreamingContext: Error starting the context, marking it as stopped</span><br><span class="line">java.lang.IllegalArgumentException: requirement failed: The checkpoint directory has not been set. Please set it by StreamingContext.checkpoint().</span><br><span class="line">	at scala.Predef$.require(Predef.scala:224)</span><br><span class="line">	at org.apache.spark.streaming.dstream.DStream.validateAtStart(DStream.scala:243)</span><br><span class="line">	at org.apache.spark.streaming.dstream.DStream$$anonfun$validateAtStart$8.apply(DStream.scala:276)</span><br><span class="line">	at org.apache.spark.streaming.dstream.DStream$$anonfun$validateAtStart$8.apply(DStream.scala:276)</span><br><span class="line">	at scala.collection.immutable.List.foreach(List.scala:381)</span><br><span class="line">	at org.apache.spark.streaming.dstream.DStream.validateAtStart(DStream.scala:276)</span><br><span class="line">	at org.apache.spark.streaming.DStreamGraph$$anonfun$start$4.apply(DStreamGraph.scala:51)</span><br><span class="line">	at org.apache.spark.streaming.DStreamGraph$$anonfun$start$4.apply(DStreamGraph.scala:51)</span><br><span class="line">	at scala.collection.mutable.ResizableArray$class.foreach(ResizableArray.scala:59)</span><br><span class="line">	at scala.collection.mutable.ArrayBuffer.foreach(ArrayBuffer.scala:48)</span><br><span class="line">	at org.apache.spark.streaming.DStreamGraph.start(DStreamGraph.scala:51)</span><br><span class="line">	at org.apache.spark.streaming.scheduler.JobGenerator.startFirstTime(JobGenerator.scala:194)</span><br><span class="line">	at org.apache.spark.streaming.scheduler.JobGenerator.start(JobGenerator.scala:100)</span><br><span class="line">	at org.apache.spark.streaming.scheduler.JobScheduler.start(JobScheduler.scala:103)</span><br><span class="line">	at org.apache.spark.streaming.StreamingContext$$anonfun$liftedTree1$1$1.apply$mcV$sp(StreamingContext.scala:583)</span><br><span class="line">	at org.apache.spark.streaming.StreamingContext$$anonfun$liftedTree1$1$1.apply(StreamingContext.scala:578)</span><br><span class="line">	at org.apache.spark.streaming.StreamingContext$$anonfun$liftedTree1$1$1.apply(StreamingContext.scala:578)</span><br><span class="line">	at ... run in separate thread using org.apache.spark.util.ThreadUtils ... ()</span><br><span class="line">	at org.apache.spark.streaming.StreamingContext.liftedTree1$1(StreamingContext.scala:578)</span><br><span class="line">	at org.apache.spark.streaming.StreamingContext.start(StreamingContext.scala:572)</span><br><span class="line">	at com.ruozedata.spark.ss02.StreamingWCApp01$.main(StreamingWCApp01.scala:19)</span><br><span class="line">	at com.ruozedata.spark.ss02.StreamingWCApp01.main(StreamingWCApp01.scala)</span><br><span class="line">19/10/31 19:21:08 WARN ReceiverSupervisorImpl: Skip stopping receiver because it has not yet stared</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.IllegalArgumentException: requirement failed: The checkpoint directory has not been set. Please set it by StreamingContext.checkpoint().</span><br><span class="line">	at scala.Predef$.require(Predef.scala:224)</span><br><span class="line">	at org.apache.spark.streaming.dstream.DStream.validateAtStart(DStream.scala:243)</span><br><span class="line">	at org.apache.spark.streaming.dstream.DStream$$anonfun$validateAtStart$8.apply(DStream.scala:276)</span><br><span class="line">	at org.apache.spark.streaming.dstream.DStream$$anonfun$validateAtStart$8.apply(DStream.scala:276)</span><br><span class="line">	at scala.collection.immutable.List.foreach(List.scala:381)</span><br><span class="line">	at org.apache.spark.streaming.dstream.DStream.validateAtStart(DStream.scala:276)</span><br><span class="line">	at org.apache.spark.streaming.DStreamGraph$$anonfun$start$4.apply(DStreamGraph.scala:51)</span><br><span class="line">	at org.apache.spark.streaming.DStreamGraph$$anonfun$start$4.apply(DStreamGraph.scala:51)</span><br><span class="line">	at scala.collection.mutable.ResizableArray$class.foreach(ResizableArray.scala:59)</span><br><span class="line">	at scala.collection.mutable.ArrayBuffer.foreach(ArrayBuffer.scala:48)</span><br><span class="line">	at org.apache.spark.streaming.DStreamGraph.start(DStreamGraph.scala:51)</span><br><span class="line">	at org.apache.spark.streaming.scheduler.JobGenerator.startFirstTime(JobGenerator.scala:194)</span><br><span class="line">	at org.apache.spark.streaming.scheduler.JobGenerator.start(JobGenerator.scala:100)</span><br><span class="line">	at org.apache.spark.streaming.scheduler.JobScheduler.start(JobScheduler.scala:103)</span><br><span class="line">	at org.apache.spark.streaming.StreamingContext$$anonfun$liftedTree1$1$1.apply$mcV$sp(StreamingContext.scala:583)</span><br><span class="line">	at org.apache.spark.streaming.StreamingContext$$anonfun$liftedTree1$1$1.apply(StreamingContext.scala:578)</span><br><span class="line">	at org.apache.spark.streaming.StreamingContext$$anonfun$liftedTree1$1$1.apply(StreamingContext.scala:578)</span><br><span class="line">	at ... run in separate thread using org.apache.spark.util.ThreadUtils ... ()</span><br><span class="line">	at org.apache.spark.streaming.StreamingContext.liftedTree1$1(StreamingContext.scala:578)</span><br><span class="line">	at org.apache.spark.streaming.StreamingContext.start(StreamingContext.scala:572)</span><br><span class="line">	at com.ruozedata.spark.ss02.StreamingWCApp01$.main(StreamingWCApp01.scala:19)</span><br><span class="line">	at com.ruozedata.spark.ss02.StreamingWCApp01.main(StreamingWCApp01.scala)</span><br><span class="line"></span><br><span class="line">Process finished with exit code 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">Please set it by StreamingContext.checkpoint().</span><br></pre></td></tr></table></figure></div>
<p>修改代码</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[double_happy@hadoop101 ~]$ nc -lk 9999</span><br><span class="line">a,a,b,b,a         第一次输入</span><br><span class="line"></span><br><span class="line">a,a,b,b,a         第二次输入</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">object StreamingWCApp01 &#123;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line"></span><br><span class="line">    val ssc = ContextUtils.getStreamingContext(this.getClass.getSimpleName, 10)</span><br><span class="line">    </span><br><span class="line">    ssc.checkpoint(&quot;file:///C:/IdeaProjects/spark/checkponit&quot;)</span><br><span class="line"></span><br><span class="line">    val lines = ssc.socketTextStream(&quot;hadoop101&quot;,9999)</span><br><span class="line"></span><br><span class="line">    val result = lines.flatMap(_.split(&quot;,&quot;))</span><br><span class="line">      .map((_,1))</span><br><span class="line">      .updateStateByKey(updateFunction)</span><br><span class="line"></span><br><span class="line">    result.print()</span><br><span class="line"></span><br><span class="line">    ssc.start()</span><br><span class="line">    ssc.awaitTermination()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">    *</span><br><span class="line">    * 1批次：  a a a d d</span><br><span class="line">    * 2批次：  b b b c c a</span><br><span class="line">    *</span><br><span class="line">    *newValues : 当前批次的值</span><br><span class="line">    *           key对应的新值(或者有新的key)  可能有多个 所以是一个Seq</span><br><span class="line">    * preValues : 以前批次的累加值</span><br><span class="line">    *             key已经存在的值  有可能没有 有可能有  所以定义成Option  有就返回some  没有返回none</span><br><span class="line">    *</span><br><span class="line">    */</span><br><span class="line">  def updateFunction(newValues: Seq[Int], preValues: Option[Int]): Option[Int] = &#123;</span><br><span class="line">    //newValues : (b,1)(b,1)(b,1)(c,1)(c,1) (a,1)</span><br><span class="line"></span><br><span class="line">    val curr = newValues.sum // 当前批次</span><br><span class="line">    val pre = preValues.getOrElse(0)   //老的值   (a,3) (d,2)   拿出值  key没有的  就赋值为0</span><br><span class="line">    Some(curr + pre)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">-------------------------------------------</span><br><span class="line">Time: 1572521050000 ms</span><br><span class="line">-------------------------------------------</span><br><span class="line"></span><br><span class="line">19/10/31 19:24:13 WARN RandomBlockReplicationPolicy: Expecting 1 replicas with only 0 peer/s.</span><br><span class="line">19/10/31 19:24:13 WARN BlockManager: Block input-0-1572521053200 replicated to only 0 peer(s) instead of 1 peers</span><br><span class="line">-------------------------------------------</span><br><span class="line">Time: 1572521060000 ms</span><br><span class="line">-------------------------------------------</span><br><span class="line">(b,2)</span><br><span class="line">(a,3)</span><br><span class="line"></span><br><span class="line">19/10/31 19:24:25 WARN RandomBlockReplicationPolicy: Expecting 1 replicas with only 0 peer/s.</span><br><span class="line">19/10/31 19:24:25 WARN BlockManager: Block input-0-1572521064800 replicated to only 0 peer(s) instead of 1 peers</span><br><span class="line">-------------------------------------------</span><br><span class="line">Time: 1572521070000 ms</span><br><span class="line">-------------------------------------------</span><br><span class="line">(b,4)</span><br><span class="line">(a,6)</span><br><span class="line"></span><br><span class="line">-------------------------------------------</span><br><span class="line">Time: 1572521080000 ms</span><br><span class="line">-------------------------------------------</span><br><span class="line">(b,4)</span><br><span class="line">(a,6)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">为什么要checkpoint呢？</span><br><span class="line">之前的代码都是没有设置checkpoint 的 为什么之前不需要设置 呢？</span><br><span class="line">因为之前的是没有状态的 没有状态 就是当前批次处理完就ok了 </span><br><span class="line"></span><br><span class="line">但是现在 需要把当前批次 和 以前批次累加起来的  这个东西在哪里呢？下图</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191031192844428.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ok 现在我把程序关掉 重启以后 是多少呢？  </span><br><span class="line">之前值是：</span><br><span class="line">	(b,4)</span><br><span class="line">    (a,6)</span><br><span class="line">重启之后的值是：空的 </span><br><span class="line"></span><br><span class="line">-------------------------------------------</span><br><span class="line">Time: 1572521460000 ms</span><br><span class="line">-------------------------------------------</span><br><span class="line"></span><br><span class="line">-------------------------------------------</span><br><span class="line">Time: 1572521470000 ms</span><br><span class="line">-------------------------------------------</span><br><span class="line"></span><br><span class="line">也就是说 ：</span><br><span class="line">	如果你的作业 中途挂掉了 重启之后 什么都没有了 </span><br><span class="line">为什么呢？</span><br><span class="line">	因为之前的结果写到 checkponit里了 ，而且当前批次 也没有数据输入进来</span><br><span class="line">那么：</span><br><span class="line">	我们有什么办法 把 checkponit里的数据读取出来呢？</span><br><span class="line">	看官网</span><br></pre></td></tr></table></figure></div>
<p><a href="https://spark.apache.org/docs/latest/streaming-programming-guide.html#checkpointing" target="_blank" rel="noopener">Checkpointing</a></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">最好直接看官网：我只是截取我认为重要的</span><br><span class="line">Spark Streaming needs to checkpoint enough information </span><br><span class="line">to a fault- tolerant storage system such that it can recover from failures.</span><br><span class="line"> There are two types of data that are checkpointed.</span><br><span class="line"></span><br><span class="line">1. a fault- tolerant storage system    可以选用HDFS</span><br><span class="line">2. two types of data that are checkpointed</span><br><span class="line">      1.Metadata checkpointing</span><br><span class="line">      			Configuration     配置文件</span><br><span class="line">      			DStream operations     算子 </span><br><span class="line">      			Incomplete batches    未完成的</span><br><span class="line">      2.Data checkpointing    就是你真正传过来的数据</span><br><span class="line"></span><br><span class="line">When to enable Checkpointing？</span><br><span class="line">   1.Usage of stateful transformations </span><br><span class="line">   2.Recovering from failures of the driver running the application </span><br><span class="line">   		driver挂了 你的作业就挂了 当你作业挂了 从Checkpoint中恢复</span><br><span class="line"></span><br><span class="line">How to configure Checkpointing？</span><br><span class="line">	看代码   就是说什么代码得改动 不能像之前那样写</span><br><span class="line">1.需要定义一个函数 这个函数就是 创建StreamingContext</span><br><span class="line">2.之后 再 val ssc = StreamingContext.getOrCreate(checkpointDirectory, functionToCreateContext _) </span><br><span class="line">才可以解决 重启之后能够拿到之前的值 </span><br><span class="line"></span><br><span class="line">这个就是利用了 ：</span><br><span class="line">	从Checkpoint中恢复 StreamingContext思想(driver 里的 )</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">object StreamingWCApp02 &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  val checkpointDirectory = &quot;file:///C:/IdeaProjects/spark/checkponit&quot;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    // 当作业挂了时，从checkpoint中去获取StreamingContext</span><br><span class="line">    val ssc = StreamingContext.getOrCreate(checkpointDirectory, functionToCreateContext)</span><br><span class="line">    ssc.start()</span><br><span class="line">    ssc.awaitTermination()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  def functionToCreateContext(): StreamingContext = &#123;</span><br><span class="line">    val ssc = ContextUtils.getStreamingContext(this.getClass.getSimpleName, 10)</span><br><span class="line">    ssc.checkpoint(checkpointDirectory)</span><br><span class="line">    val lines = ssc.socketTextStream(&quot;hadoop101&quot;,9999)</span><br><span class="line">    val result = lines.flatMap(_.split(&quot;,&quot;))</span><br><span class="line">      .map((_,1))</span><br><span class="line">      .updateStateByKey(updateFunction)</span><br><span class="line">    result.print()</span><br><span class="line"></span><br><span class="line">    ssc</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">    *</span><br><span class="line">    * 1)  a a a d d</span><br><span class="line">    * 2)  b b b c c a</span><br><span class="line">    *</span><br><span class="line">    * @param newValues  当前批次的值</span><br><span class="line">    *        key对应的新值  可能有多个 所以是一个Seq</span><br><span class="line">    * @param preValues  以前批次的累加值</span><br><span class="line">    *        key已经存在的值  有可能没有 有可能有  所以定义成Option</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">  def updateFunction(newValues: Seq[Int], preValues: Option[Int]): Option[Int] = &#123;</span><br><span class="line">    val curr = newValues.sum // 当前</span><br><span class="line">    val pre = preValues.getOrElse(0)</span><br><span class="line">    Some(curr + pre)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果是：</span><br><span class="line">	-------------------------------------------</span><br><span class="line">Time: 1572521710000 ms</span><br><span class="line">-------------------------------------------</span><br><span class="line"></span><br><span class="line">-------------------------------------------</span><br><span class="line">Time: 1572521720000 ms</span><br><span class="line">-------------------------------------------</span><br><span class="line"></span><br><span class="line">-------------------------------------------</span><br><span class="line">Time: 1572521730000 ms</span><br><span class="line">-------------------------------------------</span><br><span class="line"></span><br><span class="line">-------------------------------------------</span><br><span class="line">Time: 1572521740000 ms</span><br><span class="line">-------------------------------------------</span><br><span class="line"></span><br><span class="line">-------------------------------------------</span><br><span class="line">Time: 1572521750000 ms</span><br><span class="line">-------------------------------------------</span><br><span class="line"></span><br><span class="line">-------------------------------------------</span><br><span class="line">Time: 1572521760000 ms</span><br><span class="line">-------------------------------------------</span><br><span class="line"></span><br><span class="line">为什么呢？因为 我改动代码了 虽然 checkpoint目录没有变 </span><br><span class="line">先把之前的 checkpoint 目录删掉 再测试 (第一次 之后关闭程序 再重启)</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[double_happy@hadoop101 ~]$ nc -lk 9999</span><br><span class="line">a,a,b,b,a    第一次输入 </span><br><span class="line">a,a,b,b,a</span><br><span class="line"></span><br><span class="line">a,a,b,b,a   第二次输入</span><br><span class="line">a,a,b,b,a</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">结果：</span><br><span class="line">-------------------------------------------</span><br><span class="line">Time: 1572523040000 ms</span><br><span class="line">-------------------------------------------</span><br><span class="line">(b,4)</span><br><span class="line">(a,6)</span><br><span class="line"></span><br><span class="line">19/10/31 19:57:25 WARN RandomBlockReplicationPolicy: Expecting 1 replicas with only 0 peer/s.</span><br><span class="line">19/10/31 19:57:25 WARN BlockManager: Block input-0-1572523045400 replicated to only 0 peer(s) instead of 1 peers</span><br><span class="line">19/10/31 19:57:26 WARN RandomBlockReplicationPolicy: Expecting 1 replicas with only 0 peer/s.</span><br><span class="line">19/10/31 19:57:26 WARN BlockManager: Block input-0-1572523046200 replicated to only 0 peer(s) instead of 1 peers</span><br><span class="line">-------------------------------------------</span><br><span class="line">Time: 1572523050000 ms</span><br><span class="line">-------------------------------------------</span><br><span class="line">(b,8)</span><br><span class="line">(a,12)</span><br><span class="line"></span><br><span class="line">-------------------------------------------</span><br><span class="line">Time: 1572523060000 ms</span><br><span class="line">-------------------------------------------</span><br><span class="line">(b,8)</span><br><span class="line">(a,12)</span><br><span class="line"></span><br><span class="line">重启后的结果：</span><br><span class="line">	-------------------------------------------</span><br><span class="line">Time: 1572523070000 ms</span><br><span class="line">-------------------------------------------</span><br><span class="line">(b,8)</span><br><span class="line">(a,12)</span><br><span class="line"></span><br><span class="line">-------------------------------------------</span><br><span class="line">Time: 1572523080000 ms</span><br><span class="line">-------------------------------------------</span><br><span class="line">(b,8)</span><br><span class="line">(a,12)</span><br><span class="line"></span><br><span class="line">-------------------------------------------</span><br><span class="line">Time: 1572523090000 ms</span><br><span class="line">-------------------------------------------</span><br><span class="line">(b,8)</span><br><span class="line">(a,12)</span><br><span class="line"></span><br><span class="line">-------------------------------------------</span><br><span class="line">Time: 1572523100000 ms</span><br><span class="line">-------------------------------------------</span><br><span class="line">(b,8)</span><br><span class="line">(a,12)</span><br><span class="line"></span><br><span class="line">-------------------------------------------</span><br><span class="line">Time: 1572523110000 ms</span><br><span class="line">-------------------------------------------</span><br><span class="line">(b,8)</span><br><span class="line">(a,12)</span><br><span class="line"></span><br><span class="line">-------------------------------------------</span><br><span class="line">Time: 1572523120000 ms</span><br><span class="line">-------------------------------------------</span><br><span class="line">(b,8)</span><br><span class="line">(a,12)</span><br><span class="line"></span><br><span class="line">-------------------------------------------</span><br><span class="line">Time: 1572523130000 ms</span><br><span class="line">-------------------------------------------</span><br><span class="line">(b,8)</span><br><span class="line">(a,12)</span><br><span class="line"></span><br><span class="line">-------------------------------------------</span><br><span class="line">Time: 1572523140000 ms</span><br><span class="line">-------------------------------------------</span><br><span class="line">(b,8)</span><br><span class="line">(a,12)</span><br><span class="line"></span><br><span class="line">-------------------------------------------</span><br><span class="line">Time: 1572523150000 ms</span><br><span class="line">-------------------------------------------</span><br><span class="line">(b,8)</span><br><span class="line">(a,12)</span><br><span class="line"></span><br><span class="line">-------------------------------------------</span><br><span class="line">Time: 1572523160000 ms</span><br><span class="line">-------------------------------------------</span><br><span class="line">(b,8)</span><br><span class="line">(a,12)</span><br><span class="line"></span><br><span class="line">ok啦</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Stream + Kafka == CP</span><br><span class="line">Kafka 的offset肯定是需要手工维护：有哪些呢？很多的 </span><br><span class="line">    1.checkpoint： 就是把offset维护在checkponit里面的    </span><br><span class="line">    	(代码不能发生任何的变化   只要你代码发生了变化 就意味着 checkpoint 的 matadata 发生了变化  )</span><br><span class="line">    2.Kafka     </span><br><span class="line">    3.ZK   </span><br><span class="line">    4.MySQL    </span><br><span class="line">    5.Redis</span><br><span class="line"></span><br><span class="line">所以生产上 checkpoint 根本没法用  (你的代码怎么可能不变呢？或者不修改呢？所以用不了 )</span><br></pre></td></tr></table></figure></div>

<p><strong>把数据写出去： ****</strong></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">foreachRDD：</span><br><span class="line"></span><br><span class="line">foreachRDD(func)：</span><br><span class="line">	The most generic output operator that applies a function, func, to each RDD </span><br><span class="line">	generated from the stream. </span><br><span class="line">	This function should push the data in each RDD to an external system, </span><br><span class="line">	such as saving the RDD to files, </span><br><span class="line">	or writing it over the network to a database. Note that the function func</span><br><span class="line">	 is executed in the driver process running the streaming application,</span><br><span class="line">	 and will usually have RDD actions in it</span><br><span class="line">	  that will force the computation of the streaming RDDs.</span><br><span class="line"></span><br><span class="line">1. such as saving the RDD to files, </span><br><span class="line">	or writing it over the network to a database.</span><br><span class="line">2.闭包  优雅的方式写出去</span><br><span class="line">3.the function func</span><br><span class="line">	 is executed in the driver process </span><br><span class="line">	 running the streaming application</span><br><span class="line">	 func是运行在driver process的</span><br><span class="line"></span><br><span class="line">driver端到executor端 必然涉及到一个序列化的问题</span><br></pre></td></tr></table></figure></div>
<p><strong>把数据写到MySQL</strong></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MySQL底层引擎有几种？各自什么区别？</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/2019103120380049.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>咱们一步一步来 由劣到优</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line">object StreamingWCApp03 &#123;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    val ssc = ContextUtils.getStreamingContext(this.getClass.getSimpleName, 10)</span><br><span class="line"></span><br><span class="line">    //TODO... 填写我们的业务逻辑</span><br><span class="line">    // Input:   socket  Input DStream</span><br><span class="line">    val lines = ssc.socketTextStream(&quot;hadoop101&quot;, 9999)</span><br><span class="line"></span><br><span class="line">    // transformation</span><br><span class="line">    val result = lines.flatMap(_.split(&quot;,&quot;)).map((_, 1)).reduceByKey(_ + _)</span><br><span class="line"></span><br><span class="line">    // output</span><br><span class="line">    result.foreachRDD( rdd =&gt;&#123;</span><br><span class="line">      val connection: Connection = MySQLUtils.getConnection()</span><br><span class="line"></span><br><span class="line">      rdd.foreach(pair =&gt;&#123;</span><br><span class="line">        val sql = s&quot;insert into wc(word,cnt) values(&apos;$&#123;pair._1&#125;&apos;, $&#123;pair._2&#125;)&quot;</span><br><span class="line">        connection.createStatement().execute(sql)</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      MySQLUtils.closeResource(connection)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    ssc.start()</span><br><span class="line">    ssc.awaitTermination()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">19/10/31 20:43:30 ERROR JobScheduler: Error running job streaming job 1572525810000 ms.0</span><br><span class="line">org.apache.spark.SparkException: Task not serializable</span><br><span class="line">	at org.apache.spark.util.ClosureCleaner$.ensureSerializable(ClosureCleaner.scala:403)</span><br><span class="line">	at org.apache.spark.util.ClosureCleaner$.org$apache$spark$util$ClosureCleaner$$clean(ClosureCleaner.scala:393)</span><br><span class="line">	at org.apache.spark.util.ClosureCleaner$.clean(ClosureCleaner.scala:162)</span><br><span class="line">	at org.apache.spark.SparkContext.clean(SparkContext.scala:2326)</span><br><span class="line">	at org.apache.spark.rdd.RDD$$anonfun$foreach$1.apply(RDD.scala:926)</span><br><span class="line">	at org.apache.spark.rdd.RDD$$anonfun$foreach$1.apply(RDD.scala:925)</span><br><span class="line">	at org.apache.spark.rdd.RDDOperationScope$.withScope(RDDOperationScope.scala:151)</span><br><span class="line">	at org.apache.spark.rdd.RDDOperationScope$.withScope(RDDOperationScope.scala:112)</span><br><span class="line">	at org.apache.spark.rdd.RDD.withScope(RDD.scala:363)</span><br><span class="line">	at org.apache.spark.rdd.RDD.foreach(RDD.scala:925)</span><br><span class="line">	at com.ruozedata.spark.ss02.StreamingWCApp03$$anonfun$main$1.apply(StreamingWCApp03.scala:32)</span><br><span class="line">	at com.ruozedata.spark.ss02.StreamingWCApp03$$anonfun$main$1.apply(StreamingWCApp03.scala:29)</span><br><span class="line">	at org.apache.spark.streaming.dstream.DStream$$anonfun$foreachRDD$1$$anonfun$apply$mcV$sp$3.apply(DStream.scala:628)</span><br><span class="line">	at org.apache.spark.streaming.dstream.DStream$$anonfun$foreachRDD$1$$anonfun$apply$mcV$sp$3.apply(DStream.scala:628)</span><br><span class="line">	at org.apache.spark.streaming.dstream.ForEachDStream$$anonfun$1$$anonfun$apply$mcV$sp$1.apply$mcV$sp(ForEachDStream.scala:51)</span><br><span class="line">	at org.apache.spark.streaming.dstream.ForEachDStream$$anonfun$1$$anonfun$apply$mcV$sp$1.apply(ForEachDStream.scala:51)</span><br><span class="line">	at org.apache.spark.streaming.dstream.ForEachDStream$$anonfun$1$$anonfun$apply$mcV$sp$1.apply(ForEachDStream.scala:51)</span><br><span class="line">	at org.apache.spark.streaming.dstream.DStream.createRDDWithLocalProperties(DStream.scala:416)</span><br><span class="line">	at org.apache.spark.streaming.dstream.ForEachDStream$$anonfun$1.apply$mcV$sp(ForEachDStream.scala:50)</span><br><span class="line">	at org.apache.spark.streaming.dstream.ForEachDStream$$anonfun$1.apply(ForEachDStream.scala:50)</span><br><span class="line">	at org.apache.spark.streaming.dstream.ForEachDStream$$anonfun$1.apply(ForEachDStream.scala:50)</span><br><span class="line">	at scala.util.Try$.apply(Try.scala:192)</span><br><span class="line">	at org.apache.spark.streaming.scheduler.Job.run(Job.scala:39)</span><br><span class="line">	at org.apache.spark.streaming.scheduler.JobScheduler$JobHandler$$anonfun$run$1.apply$mcV$sp(JobScheduler.scala:257)</span><br><span class="line">	at org.apache.spark.streaming.scheduler.JobScheduler$JobHandler$$anonfun$run$1.apply(JobScheduler.scala:257)</span><br><span class="line">	at org.apache.spark.streaming.scheduler.JobScheduler$JobHandler$$anonfun$run$1.apply(JobScheduler.scala:257)</span><br><span class="line">	at scala.util.DynamicVariable.withValue(DynamicVariable.scala:58)</span><br><span class="line">	at org.apache.spark.streaming.scheduler.JobScheduler$JobHandler.run(JobScheduler.scala:256)</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">Caused by: java.io.NotSerializableException: java.lang.Object</span><br><span class="line">Serialization stack:</span><br><span class="line">	- object not serializable (class: java.lang.Object, value: java.lang.Object@4ffd7c3f)</span><br><span class="line">	- writeObject data (class: java.util.HashMap)</span><br><span class="line">	- object (class java.util.HashMap, &#123;UTF-8=java.lang.Object@4ffd7c3f, US-ASCII=com.mysql.jdbc.SingleByteCharsetConverter@53c22208, WINDOWS-1252=com.mysql.jdbc.SingleByteCharsetConverter@77cd4c6d&#125;)</span><br><span class="line">	- field (class: com.mysql.jdbc.ConnectionImpl, name: charsetConverterMap, type: interface java.util.Map)</span><br><span class="line">	- object (class com.mysql.jdbc.JDBC4Connection, com.mysql.jdbc.JDBC4Connection@65b0d4df)</span><br><span class="line">	- field (class: com.ruozedata.spark.ss02.StreamingWCApp03$$anonfun$main$1$$anonfun$apply$1, name: connection$1, type: interface java.sql.Connection)</span><br><span class="line">	- object (class com.ruozedata.spark.ss02.StreamingWCApp03$$anonfun$main$1$$anonfun$apply$1, &lt;function1&gt;)</span><br><span class="line">	at org.apache.spark.serializer.SerializationDebugger$.improveException(SerializationDebugger.scala:40)</span><br><span class="line">	at org.apache.spark.serializer.JavaSerializationStream.writeObject(JavaSerializer.scala:46)</span><br><span class="line">	at org.apache.spark.serializer.JavaSerializerInstance.serialize(JavaSerializer.scala:100)</span><br><span class="line">	at org.apache.spark.util.ClosureCleaner$.ensureSerializable(ClosureCleaner.scala:400)</span><br><span class="line">	... 30 more</span><br><span class="line">Exception in thread &quot;main&quot; org.apache.spark.SparkException: Task not serializable</span><br><span class="line">	at org.apache.spark.util.ClosureCleaner$.ensureSerializable(ClosureCleaner.scala:403)</span><br><span class="line">	at org.apache.spark.util.ClosureCleaner$.org$apache$spark$util$ClosureCleaner$$clean(ClosureCleaner.scala:393)</span><br><span class="line">	at org.apache.spark.util.ClosureCleaner$.clean(ClosureCleaner.scala:162)</span><br><span class="line">	at org.apache.spark.SparkContext.clean(SparkContext.scala:2326)</span><br><span class="line">	at org.apache.spark.rdd.RDD$$anonfun$foreach$1.apply(RDD.scala:926)</span><br><span class="line">	at org.apache.spark.rdd.RDD$$anonfun$foreach$1.apply(RDD.scala:925)</span><br><span class="line">	at org.apache.spark.rdd.RDDOperationScope$.withScope(RDDOperationScope.scala:151)</span><br><span class="line">	at org.apache.spark.rdd.RDDOperationScope$.withScope(RDDOperationScope.scala:112)</span><br><span class="line">	at org.apache.spark.rdd.RDD.withScope(RDD.scala:363)</span><br><span class="line">	at org.apache.spark.rdd.RDD.foreach(RDD.scala:925)</span><br><span class="line">	at com.ruozedata.spark.ss02.StreamingWCApp03$$anonfun$main$1.apply(StreamingWCApp03.scala:32)</span><br><span class="line">	at com.ruozedata.spark.ss02.StreamingWCApp03$$anonfun$main$1.apply(StreamingWCApp03.scala:29)</span><br><span class="line">	at org.apache.spark.streaming.dstream.DStream$$anonfun$foreachRDD$1$$anonfun$apply$mcV$sp$3.apply(DStream.scala:628)</span><br><span class="line">	at org.apache.spark.streaming.dstream.DStream$$anonfun$foreachRDD$1$$anonfun$apply$mcV$sp$3.apply(DStream.scala:628)</span><br><span class="line">	at org.apache.spark.streaming.dstream.ForEachDStream$$anonfun$1$$anonfun$apply$mcV$sp$1.apply$mcV$sp(ForEachDStream.scala:51)</span><br><span class="line">	at org.apache.spark.streaming.dstream.ForEachDStream$$anonfun$1$$anonfun$apply$mcV$sp$1.apply(ForEachDStream.scala:51)</span><br><span class="line">	at org.apache.spark.streaming.dstream.ForEachDStream$$anonfun$1$$anonfun$apply$mcV$sp$1.apply(ForEachDStream.scala:51)</span><br><span class="line">	at org.apache.spark.streaming.dstream.DStream.createRDDWithLocalProperties(DStream.scala:416)</span><br><span class="line">	at org.apache.spark.streaming.dstream.ForEachDStream$$anonfun$1.apply$mcV$sp(ForEachDStream.scala:50)</span><br><span class="line">	at org.apache.spark.streaming.dstream.ForEachDStream$$anonfun$1.apply(ForEachDStream.scala:50)</span><br><span class="line">	at org.apache.spark.streaming.dstream.ForEachDStream$$anonfun$1.apply(ForEachDStream.scala:50)</span><br><span class="line">	at scala.util.Try$.apply(Try.scala:192)</span><br><span class="line">	at org.apache.spark.streaming.scheduler.Job.run(Job.scala:39)</span><br><span class="line">	at org.apache.spark.streaming.scheduler.JobScheduler$JobHandler$$anonfun$run$1.apply$mcV$sp(JobScheduler.scala:257)</span><br><span class="line">	at org.apache.spark.streaming.scheduler.JobScheduler$JobHandler$$anonfun$run$1.apply(JobScheduler.scala:257)</span><br><span class="line">	at org.apache.spark.streaming.scheduler.JobScheduler$JobHandler$$anonfun$run$1.apply(JobScheduler.scala:257)</span><br><span class="line">	at scala.util.DynamicVariable.withValue(DynamicVariable.scala:58)</span><br><span class="line">	at org.apache.spark.streaming.scheduler.JobScheduler$JobHandler.run(JobScheduler.scala:256)</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">Caused by: java.io.NotSerializableException: java.lang.Object</span><br><span class="line">Serialization stack:</span><br><span class="line">	- object not serializable (class: java.lang.Object, value: java.lang.Object@4ffd7c3f)</span><br><span class="line">	- writeObject data (class: java.util.HashMap)</span><br><span class="line">	- object (class java.util.HashMap, &#123;UTF-8=java.lang.Object@4ffd7c3f, US-ASCII=com.mysql.jdbc.SingleByteCharsetConverter@53c22208, WINDOWS-1252=com.mysql.jdbc.SingleByteCharsetConverter@77cd4c6d&#125;)</span><br><span class="line">	- field (class: com.mysql.jdbc.ConnectionImpl, name: charsetConverterMap, type: interface java.util.Map)</span><br><span class="line">	- object (class com.mysql.jdbc.JDBC4Connection, com.mysql.jdbc.JDBC4Connection@65b0d4df)</span><br><span class="line">	- field (class: com.ruozedata.spark.ss02.StreamingWCApp03$$anonfun$main$1$$anonfun$apply$1, name: connection$1, type: interface java.sql.Connection)</span><br><span class="line">	- object (class com.ruozedata.spark.ss02.StreamingWCApp03$$anonfun$main$1$$anonfun$apply$1, &lt;function1&gt;)</span><br><span class="line">	at org.apache.spark.serializer.SerializationDebugger$.improveException(SerializationDebugger.scala:40)</span><br><span class="line">	at org.apache.spark.serializer.JavaSerializationStream.writeObject(JavaSerializer.scala:46)</span><br><span class="line">	at org.apache.spark.serializer.JavaSerializerInstance.serialize(JavaSerializer.scala:100)</span><br><span class="line">	at org.apache.spark.util.ClosureCleaner$.ensureSerializable(ClosureCleaner.scala:400)</span><br><span class="line">	... 30 more</span><br><span class="line">19/10/31 20:43:30 WARN SocketReceiver: Error receiving data</span><br><span class="line">java.net.SocketException: Socket closed</span><br><span class="line">	at java.net.SocketInputStream.socketRead0(Native Method)</span><br><span class="line">	at java.net.SocketInputStream.socketRead(SocketInputStream.java:116)</span><br><span class="line">	at java.net.SocketInputStream.read(SocketInputStream.java:171)</span><br><span class="line">	at java.net.SocketInputStream.read(SocketInputStream.java:141)</span><br><span class="line">	at sun.nio.cs.StreamDecoder.readBytes(StreamDecoder.java:284)</span><br><span class="line">	at sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:326)</span><br><span class="line">	at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:178)</span><br><span class="line">	at java.io.InputStreamReader.read(InputStreamReader.java:184)</span><br><span class="line">	at java.io.BufferedReader.fill(BufferedReader.java:161)</span><br><span class="line">	at java.io.BufferedReader.readLine(BufferedReader.java:324)</span><br><span class="line">	at java.io.BufferedReader.readLine(BufferedReader.java:389)</span><br><span class="line">	at org.apache.spark.streaming.dstream.SocketReceiver$$anon$1.getNext(SocketInputDStream.scala:121)</span><br><span class="line">	at org.apache.spark.streaming.dstream.SocketReceiver$$anon$1.getNext(SocketInputDStream.scala:119)</span><br><span class="line">	at org.apache.spark.util.NextIterator.hasNext(NextIterator.scala:73)</span><br><span class="line">	at org.apache.spark.streaming.dstream.SocketReceiver.receive(SocketInputDStream.scala:91)</span><br><span class="line">	at org.apache.spark.streaming.dstream.SocketReceiver$$anon$2.run(SocketInputDStream.scala:72)</span><br><span class="line">19/10/31 20:43:30 WARN ReceiverSupervisorImpl: Restarting receiver with delay 2000 ms: Error receiving data</span><br><span class="line">java.net.SocketException: Socket closed</span><br><span class="line">	at java.net.SocketInputStream.socketRead0(Native Method)</span><br><span class="line">	at java.net.SocketInputStream.socketRead(SocketInputStream.java:116)</span><br><span class="line">	at java.net.SocketInputStream.read(SocketInputStream.java:171)</span><br><span class="line">	at java.net.SocketInputStream.read(SocketInputStream.java:141)</span><br><span class="line">	at sun.nio.cs.StreamDecoder.readBytes(StreamDecoder.java:284)</span><br><span class="line">	at sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:326)</span><br><span class="line">	at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:178)</span><br><span class="line">	at java.io.InputStreamReader.read(InputStreamReader.java:184)</span><br><span class="line">	at java.io.BufferedReader.fill(BufferedReader.java:161)</span><br><span class="line">	at java.io.BufferedReader.readLine(BufferedReader.java:324)</span><br><span class="line">	at java.io.BufferedReader.readLine(BufferedReader.java:389)</span><br><span class="line">	at org.apache.spark.streaming.dstream.SocketReceiver$$anon$1.getNext(SocketInputDStream.scala:121)</span><br><span class="line">	at org.apache.spark.streaming.dstream.SocketReceiver$$anon$1.getNext(SocketInputDStream.scala:119)</span><br><span class="line">	at org.apache.spark.util.NextIterator.hasNext(NextIterator.scala:73)</span><br><span class="line">	at org.apache.spark.streaming.dstream.SocketReceiver.receive(SocketInputDStream.scala:91)</span><br><span class="line">	at org.apache.spark.streaming.dstream.SocketReceiver$$anon$2.run(SocketInputDStream.scala:72)</span><br><span class="line">19/10/31 20:43:30 ERROR ReceiverTracker: Deregistered receiver for stream 0: Stopped by driver</span><br><span class="line">19/10/31 20:43:30 WARN ReceiverSupervisorImpl: Receiver has been stopped</span><br><span class="line">Exception in thread &quot;receiver-supervisor-future-0&quot; java.lang.Error: java.lang.InterruptedException: sleep interrupted</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1155)</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">Caused by: java.lang.InterruptedException: sleep interrupted</span><br><span class="line">	at java.lang.Thread.sleep(Native Method)</span><br><span class="line">	at org.apache.spark.streaming.receiver.ReceiverSupervisor$$anonfun$restartReceiver$1.apply$mcV$sp(ReceiverSupervisor.scala:196)</span><br><span class="line">	at org.apache.spark.streaming.receiver.ReceiverSupervisor$$anonfun$restartReceiver$1.apply(ReceiverSupervisor.scala:189)</span><br><span class="line">	at org.apache.spark.streaming.receiver.ReceiverSupervisor$$anonfun$restartReceiver$1.apply(ReceiverSupervisor.scala:189)</span><br><span class="line">	at scala.concurrent.impl.Future$PromiseCompletingRunnable.liftedTree1$1(Future.scala:24)</span><br><span class="line">	at scala.concurrent.impl.Future$PromiseCompletingRunnable.run(Future.scala:24)</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)</span><br><span class="line">	... 2 more</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">	org.apache.spark.SparkException: Task not serializable</span><br><span class="line">	ClosureCleaner    Closure 闭包的意思</span><br><span class="line">根本原因是：</span><br><span class="line">	Caused by: java.io.NotSerializableException: java.lang.Object</span><br><span class="line">Serialization stack:</span><br><span class="line">	- object not serializable (class: java.lang.Object, value: java.lang.Object@4ffd7c3f)</span><br><span class="line">	- writeObject data (class: java.util.HashMap)</span><br><span class="line">	- object (class java.util.HashMap, &#123;UTF-8=java.lang.Object@4ffd7c3f, US-ASCII=com.mysql.jdbc.SingleByteCharsetConverter@53c22208, WINDOWS-1252=com.mysql.jdbc.SingleByteCharsetConverter@77cd4c6d&#125;)</span><br><span class="line">	- field (class: com.mysql.jdbc.ConnectionImpl, name: charsetConverterMap, type: interface java.util.Map)</span><br><span class="line">	- object (class com.mysql.jdbc.JDBC4Connection, com.mysql.jdbc.JDBC4Connection@65b0d4df)</span><br><span class="line">	- field (class: com.ruozedata.spark.ss02.StreamingWCApp03$$anonfun$main$1$$anonfun$apply$1, name: connection$1, type: interface java.sql.Connection)</span><br><span class="line"></span><br><span class="line">就是 object not serializable ：com.mysql.jdbc.SingleByteCharsetConverter </span><br><span class="line">MySQL的驱动不能序列化    但是事实上 MySQL驱动就是序列化不了 </span><br><span class="line"></span><br><span class="line">该怎么办呢？ 看官网  下图</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191031205307726.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>华丽的分割线————————————————————————————————————</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">上面的错误明白之后 那么什么叫做闭包？</span><br><span class="line">先看一下官网  RDD篇介绍的</span><br></pre></td></tr></table></figure></div>
<p><a href="https://spark.apache.org/docs/latest/rdd-programming-guide.html#understanding-closures-" target="_blank" rel="noopener">Understanding closures</a></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">闭包：在函数内部 引用了一个外部的变量 </span><br><span class="line">eg： 这两行代码</span><br><span class="line"></span><br><span class="line">     val connection: Connection = MySQLUtils.getConnection()</span><br><span class="line">      rdd.foreach(pair =&gt;&#123;</span><br><span class="line">        val sql = s&quot;insert into wc(word,cnt) values(&apos;$&#123;pair._1&#125;&apos;, $&#123;pair._2&#125;)&quot;</span><br><span class="line">        connection.createStatement().execute(sql)</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">foreach 内部使用了 connection  而connection 是在foreach的外部</span><br><span class="line"></span><br><span class="line">如果 假设哈 connection 可以序列化 的  上面这种写法是没有问题的！！！</span><br><span class="line">很不幸 connection objects are rarely transferable across machines</span><br></pre></td></tr></table></figure></div>
<p><strong>修改：</strong></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">    result.foreachRDD( rdd =&gt;&#123;</span><br><span class="line">      rdd.foreach(pair =&gt;&#123;</span><br><span class="line">        val connection: Connection = MySQLUtils.getConnection()</span><br><span class="line">        val sql = s&quot;insert into wc(word,cnt) values(&apos;$&#123;pair._1&#125;&apos;, $&#123;pair._2&#125;)&quot;</span><br><span class="line">        connection.createStatement().execute(sql)</span><br><span class="line">        MySQLUtils.closeResource(connection)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">connection放到里面去  那么还涉及闭包的问题么？</span><br><span class="line">一定没有闭包的问题了 避免了上次测试 出现的闭包问题</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">没有日志的 因为 foreachRDD 是没有返回值的  只能查看MySQL数据了</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------------------------------</span><br><span class="line">[double_happy@hadoop101 ~]$ nc -lk 9999</span><br><span class="line">a,a,b,b,a</span><br><span class="line">a,a,b,b,a</span><br><span class="line">a,a,b,b,a</span><br><span class="line">a,a,b,b,a</span><br><span class="line">--------------------------------------------------------------------------------------------</span><br><span class="line">mysql&gt; select * from wc;</span><br><span class="line">Empty set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from wc;</span><br><span class="line">+------+------+</span><br><span class="line">| word | cnt  |</span><br><span class="line">+------+------+</span><br><span class="line">| b    |    8 |</span><br><span class="line">| a    |   12 |</span><br><span class="line">+------+------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; </span><br><span class="line"></span><br><span class="line">说明写也是ok的 </span><br><span class="line"></span><br><span class="line">但是也有个问题的？</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191031210724578.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>优化</strong></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">object StreamingWCApp03 &#123;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line"></span><br><span class="line">    val ssc = ContextUtils.getStreamingContext(this.getClass.getSimpleName, 10)</span><br><span class="line"></span><br><span class="line">    //TODO... 填写我们的业务逻辑</span><br><span class="line">    // Input:   socket  Input DStream</span><br><span class="line">    val lines = ssc.socketTextStream(&quot;hadoop101&quot;, 9999)</span><br><span class="line"></span><br><span class="line">    // transformation</span><br><span class="line">    val result = lines.flatMap(_.split(&quot;,&quot;)).map((_, 1)).reduceByKey(_ + _)</span><br><span class="line"></span><br><span class="line">    // output</span><br><span class="line">    result.foreachRDD(rdd =&gt; &#123;</span><br><span class="line">      rdd.foreachPartition(partition =&gt; &#123;</span><br><span class="line">        val connection: Connection = MySQLUtils.getConnection()</span><br><span class="line"></span><br><span class="line">        partition.foreach(pair =&gt; &#123;</span><br><span class="line">          val sql = s&quot;insert into wc(word,cnt) values(&apos;$&#123;pair._1&#125;&apos;, $&#123;pair._2&#125;)&quot;</span><br><span class="line">          connection.createStatement().execute(sql)</span><br><span class="line">        &#125;)</span><br><span class="line">        MySQLUtils.closeResource(connection)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    ssc.start()</span><br><span class="line">    ssc.awaitTermination()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果是：</span><br><span class="line">[double_happy@hadoop101 ~]$ nc -lk 9999</span><br><span class="line">a,a,b,b,a</span><br><span class="line">a,a,b,b,a</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from wc;</span><br><span class="line">+------+------+</span><br><span class="line">| word | cnt  |</span><br><span class="line">+------+------+</span><br><span class="line">| b    |    8 |</span><br><span class="line">| a    |   12 |</span><br><span class="line">| b    |    4 |</span><br><span class="line">| a    |    6 |</span><br><span class="line">+------+------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; </span><br><span class="line"></span><br><span class="line">这种方式比前面的好多了 但是也不行 </span><br><span class="line">分区多了  connection也会多  </span><br><span class="line">那么最好的方式是什么呢？拿一个连接池 用完之后返回回去</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191031211641822.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">正确的写法会写了 但是 </span><br><span class="line">mysql&gt; select * from wc;</span><br><span class="line">+------+------+</span><br><span class="line">| word | cnt  |</span><br><span class="line">+------+------+</span><br><span class="line">| b    |    8 |</span><br><span class="line">| a    |   12 |</span><br><span class="line">| b    |    4 |</span><br><span class="line">| a    |    6 |</span><br><span class="line">+------+------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; </span><br><span class="line"></span><br><span class="line">结果咋整 写了两次就这样了  怎么解决呢？这是数据问题</span><br></pre></td></tr></table></figure></div>
<p><strong>还有一种写法  建议使用它</strong></p>
<p>scalikejdbc 自带Connection Pool<br><img src="https://img-blog.csdnimg.cn/20191031213004342.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">object StreamingWCApp03 &#123;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    val ssc = ContextUtils.getStreamingContext(this.getClass.getSimpleName, 10)</span><br><span class="line"></span><br><span class="line">    //TODO... 填写我们的业务逻辑</span><br><span class="line">    // Input:   socket  Input DStream</span><br><span class="line">    val lines = ssc.socketTextStream(&quot;hadoop101&quot;, 9999)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // transformation</span><br><span class="line">    val result = lines.flatMap(_.split(&quot;,&quot;)).map((_, 1)).reduceByKey(_ + _)</span><br><span class="line"></span><br><span class="line">    // output</span><br><span class="line">    </span><br><span class="line">    DBs.setupAll() //这样就把配置文件解析出来了</span><br><span class="line">    result.foreachRDD(rdd =&gt; &#123;</span><br><span class="line"></span><br><span class="line">      rdd.foreachPartition(partition =&gt; &#123;</span><br><span class="line">      </span><br><span class="line">        partition.foreach(pair =&gt; &#123;</span><br><span class="line">          DB.autoCommit &#123; implicit session =&gt; &#123;</span><br><span class="line">            SQL(&quot;insert into wc(word,cnt) values(?, ?)&quot;)</span><br><span class="line">              .bind(pair._1,pair._2)</span><br><span class="line">              .update().apply()</span><br><span class="line">          &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    ssc.start()</span><br><span class="line">    ssc.awaitTermination()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">mysql&gt; select * from wc;</span><br><span class="line">+------+------+</span><br><span class="line">| word | cnt  |</span><br><span class="line">+------+------+</span><br><span class="line">| b    |   20 |</span><br><span class="line">| a    |   30 |</span><br><span class="line">+------+------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">你确定scalikejdbc 默认就使用 连接池么？？？ 留一个坑</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">之前 我们用state 进行累计的  </span><br><span class="line">因为用state累加 会用到checkpoint   checkpoint自己生成小文件一大堆  等等</span><br><span class="line"></span><br><span class="line">那么 不用state 能不能累加？</span><br><span class="line">用redis </span><br><span class="line"> /**</span><br><span class="line">      * WC这种统计维度来说</span><br><span class="line">      * Redis的使用关键点：如何选择合适的数据类型</span><br><span class="line">      */</span><br><span class="line">这里我们选hash</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">object StreamingWCApp03 &#123;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line"></span><br><span class="line">    val ssc = ContextUtils.getStreamingContext(this.getClass.getSimpleName, 10)</span><br><span class="line"></span><br><span class="line">    //TODO... 填写我们的业务逻辑</span><br><span class="line">    // Input:   socket  Input DStream</span><br><span class="line">    val lines = ssc.socketTextStream(&quot;hadoop101&quot;, 9999)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // transformation</span><br><span class="line">    val result = lines.flatMap(_.split(&quot;,&quot;)).map((_, 1)).reduceByKey(_ + _)</span><br><span class="line"></span><br><span class="line">    // output</span><br><span class="line">    /**</span><br><span class="line">      * WC这种统计维度来说</span><br><span class="line">      * Redis的使用关键点：如何选择合适的数据类型</span><br><span class="line">      */</span><br><span class="line">        result.foreachRDD(rdd =&gt; &#123;</span><br><span class="line">          rdd.foreachPartition(partition =&gt; &#123;</span><br><span class="line">            val jedis = RedisUtils.getJedis  // 获取Redis连接</span><br><span class="line">            partition.foreach(pair =&gt; &#123;</span><br><span class="line">              jedis.hincrBy(&quot;doublehappy_redis_wc&quot;, pair._1, pair._2)   //String key, String field, long value</span><br><span class="line">            &#125;)</span><br><span class="line">            jedis.close() // free</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    ssc.start()</span><br><span class="line">    ssc.awaitTermination()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">扩展：</span><br><span class="line">	这里是连接redis  ，那么连接 phoneix 、Cassandra   都一样的 </span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">hadoop101:6379&gt; keys *</span><br><span class="line">1) &quot;name&quot;</span><br><span class="line">2) &quot;doublehappy_redis_wc&quot;</span><br><span class="line">hadoop101:6379&gt;</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191031220146737.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">再放一些数据</span><br><span class="line">[double_happy@hadoop101 ~]$ nc -lk 9999</span><br><span class="line">a,a,b,b,a</span><br><span class="line">a,a,b,b,a</span><br><span class="line">a,a,b,b,a</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191031220239500.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>说明结果ok的哈</p>
<p><strong>transform</strong><br><a href="https://spark.apache.org/docs/latest/streaming-programming-guide.html#transform-operation" target="_blank" rel="noopener">transform</a></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">transform(func)	;</span><br><span class="line">Return a new DStream by applying a RDD-to-RDD function </span><br><span class="line">to every RDD of the source DStream.</span><br><span class="line"> This can be used to do arbitrary RDD operations on the DStream.</span><br><span class="line"></span><br><span class="line">之前的编程都是基于DStream</span><br><span class="line">    /**</span><br><span class="line">      * 现在的编程都是基于DStream    生产上绝大多数是DStream</span><br><span class="line">      *</span><br><span class="line">      但是 </span><br><span class="line">      * DStream与RDD互操作咋整？ 使用transform</span><br><span class="line">      */</span><br><span class="line"></span><br><span class="line">好处就是 把DStream  的RDD 跟我们的RDD进行操作</span><br><span class="line"></span><br><span class="line">需求：</span><br><span class="line">     * 流处理的时候，有一个数据来源于文本或者是其他的   这部分数据是 RDD</span><br><span class="line">      * 另外一个数据是来自Kafka、或者其他的数据源 这部分数据是 DStream</span><br><span class="line">      </span><br><span class="line">做这两个关联  你需要用到 transform</span><br></pre></td></tr></table></figure></div>
<p><strong>例子</strong><br>黑名单<br>目的：<br>只要由黑名单里的东西 把黑名单的数据全部过滤掉 </p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">先用core的方式;</span><br><span class="line">object CoreBlackListApp &#123;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line"></span><br><span class="line">    val sc = ContextUtils.getSparkContext(&quot;CoreBlackListApp&quot;)</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">      * 构建黑名单  (xx, true) 或者  (xx, 1)</span><br><span class="line">      */</span><br><span class="line">    val blacks = new ListBuffer[(String,Boolean)]()</span><br><span class="line">    blacks.append((&quot;苍老师&quot;,true))  // 鉴黄</span><br><span class="line">    val blacksRDD = sc.parallelize(blacks)  // 把数据转成RDD</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">      * 构建访问日志</span><br><span class="line">      */</span><br><span class="line">    val input = new ListBuffer[(String,String)]</span><br><span class="line">    input.append((&quot;历史第一人&quot;,&quot;被小卡干了，000000&quot;))</span><br><span class="line">    input.append((&quot;日天&quot;,&quot;也被小卡干了，111111&quot;))</span><br><span class="line">    input.append((&quot;苍老师&quot;,&quot;我们敬爱的老师，111111&quot;))</span><br><span class="line">    val inputRDD = sc.parallelize(input)</span><br><span class="line"></span><br><span class="line">    //TODO... 想从访问日志中过滤掉“苍老师”的数据</span><br><span class="line">    inputRDD.leftOuterJoin(blacksRDD)</span><br><span class="line">      .filter(_._2._2.getOrElse(false) != true)</span><br><span class="line">      .map(x =&gt;(x._1, x._2._1))</span><br><span class="line">      .printInfo()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果是：</span><br><span class="line">(日天,也被小卡干了，111111)</span><br><span class="line">(历史第一人,被小卡干了，000000)</span><br><span class="line">-------------------------</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">ssc：很重要 </span><br><span class="line">生产上用的很多  生产上统计结果有些数据 有些是MySQL里的直接拿的 </span><br><span class="line"></span><br><span class="line">object StreamingWCApp03 &#123;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line"></span><br><span class="line">    val ssc = ContextUtils.getStreamingContext(this.getClass.getSimpleName, 10)</span><br><span class="line"></span><br><span class="line">    //TODO... 填写我们的业务逻辑</span><br><span class="line">    // Input:   socket  Input DStream</span><br><span class="line">    val lines = ssc.socketTextStream(&quot;hadoop101&quot;, 9999)</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">      * 构建黑名单  (xx, true)  (xx, 1)</span><br><span class="line">      */</span><br><span class="line">    val blacks = new ListBuffer[(String,Boolean)]()</span><br><span class="line">    blacks.append((&quot;canglaoshi&quot;,true))  // 鉴黄</span><br><span class="line">    val blacksRDD = ssc.sparkContext.parallelize(blacks)  // 把数据转成RDD</span><br><span class="line"></span><br><span class="line">    // &quot;日天&quot;,&quot;也被小卡干了，111111&quot;</span><br><span class="line">    lines.map(x =&gt; (x.split(&quot;,&quot;)(0), x))</span><br><span class="line">      .transform(rdd =&gt; &#123;</span><br><span class="line">        rdd.leftOuterJoin(blacksRDD)</span><br><span class="line">          .filter(_._2._2.getOrElse(false) != true)</span><br><span class="line">          .map(x=&gt;x._2._1)</span><br><span class="line">      &#125;).print()</span><br><span class="line"></span><br><span class="line">    ssc.start()</span><br><span class="line">    ssc.awaitTermination()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果是：</span><br><span class="line">[double_happy@hadoop101 ~]$ nc -lk 9999</span><br><span class="line">canglaoshi,xxooll</span><br><span class="line">longlaoshi,11oooxxx</span><br><span class="line">james,xxxxx</span><br><span class="line"></span><br><span class="line">-------------------------------------------</span><br><span class="line">Time: 1572533110000 ms</span><br><span class="line">-------------------------------------------</span><br><span class="line"></span><br><span class="line">-------------------------------------------</span><br><span class="line">Time: 1572533120000 ms</span><br><span class="line">-------------------------------------------</span><br><span class="line">james,xxxxx</span><br><span class="line">longlaoshi,11oooxxx</span><br><span class="line"></span><br><span class="line">-------------------------------------------</span><br><span class="line">Time: 1572533130000 ms</span><br><span class="line">-------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">结果正确 过滤掉 canglaoshi的数据</span><br></pre></td></tr></table></figure></div>
      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-SS01" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/17/SS01/">SS01</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2018/02/17/SS01/" class="article-date">
  <time datetime="2018-02-17T12:10:43.000Z" itemprop="datePublished">2018-02-17</time>
</a>
    
    
  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Fault Tolerance：</span><br><span class="line">Stateful exactly-once semantics out of the box.</span><br><span class="line">Spark Streaming recovers both lost work and </span><br><span class="line">operator state (e.g. sliding windows) out of the box, </span><br><span class="line">without any extra code on your part.</span><br><span class="line"></span><br><span class="line">注意：容错机制</span><br><span class="line">1.recovers  lost executor</span><br><span class="line">2.operator state</span><br><span class="line"></span><br><span class="line">Spark Integration：整合</span><br><span class="line">By running on Spark, Spark Streaming lets you reuse the same code </span><br><span class="line">for batch processing, join streams against historical data,</span><br><span class="line"> or run ad-hoc queries on stream state. </span><br><span class="line"> Build powerful interactive applications, not just analytics.</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">流处理</span><br><span class="line">  实时：Storm Flink   event (就是来一条数据处理一个  这是真实时)</span><br><span class="line">   近实时：Spark Streaming   mini-batch  </span><br><span class="line">   		Spark Streaming把过来的数据切割成5s 一个批次  (是小微批次处理 不是真的实时 )</span><br><span class="line">   		Spark Streaming对数据的处理是使用小批处理</span><br><span class="line"></span><br><span class="line">批处理：一次性处理某个批次的数据     数据是有始有终(有开始有结束 有头有尾的)</span><br><span class="line">	eg：处理某个文件夹下面数据 处理完就ok了  不可能跑到别的文件夹下面  (可以这么理解)</span><br><span class="line"></span><br><span class="line">流处理 ： 流氓的流 流是一直不断的 </span><br><span class="line">	eg：水龙头打开了 水一直流     不流水了说明 水龙头坏了 或者 没水了 </span><br><span class="line">	</span><br><span class="line">你们的生产上面的实时性是多高呢？</span><br><span class="line">Spark Streaming 可以做到0.5s  </span><br><span class="line">你要注意 0.5s 能进来多少数据</span><br></pre></td></tr></table></figure></div>
<p><a href="http://spark.apache.org/docs/latest/streaming-programming-guide.html#overview" target="_blank" rel="noopener">官网</a></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1. Spark Streaming is an extension of the core Spark API </span><br><span class="line"></span><br><span class="line">2.Data can be ingested from many sources </span><br><span class="line">like Kafka, Flume, Kinesis, or TCP sockets,</span><br><span class="line"> and can be processed using complex algorithms expressed </span><br><span class="line"> with high-level functions like map, reduce, join and window.</span><br><span class="line"></span><br><span class="line">数据源：</span><br><span class="line"> Kafka *****  流处理引擎+Kafka  CP</span><br><span class="line"> Flume ==&gt; 流处理引擎   可以的用的  但是 没有缓冲 </span><br><span class="line"> HDFS</span><br><span class="line"> TCP sockets ==&gt; 测试  + 电信运营商(他们用 早期的时候 15年)</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191031103920758.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ss：</span><br><span class="line">	Input： Kafka Socket</span><br><span class="line">    Transform：业务逻辑处理</span><br><span class="line">    Output：</span><br><span class="line"></span><br><span class="line">Spark Streaming ：他有几件事情</span><br><span class="line">    1）receives live input data streams   接受数据</span><br><span class="line">    2）divides the data into batches         把接受到的数据 拆分成batches</span><br><span class="line">比如说 ：</span><br><span class="line">	1.Spark Streaming 5秒中处理一次数据   5s时间到了  </span><br><span class="line">	2. 那么会把5s中接受的数据 把它切成 batch </span><br><span class="line">    3. 之后 把batch 交给 sparkEngine 处理  </span><br><span class="line">    4. 处理完的结果也是 batch</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191031104829799.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">Spark Streaming 的编程模型：</span><br><span class="line">	DStream</span><br><span class="line">        which represents a continuous stream of data</span><br><span class="line"></span><br><span class="line">理解不了看源码：</span><br><span class="line">/**</span><br><span class="line"> * A Discretized Stream (DStream), the basic abstraction in Spark Streaming, is a continuous</span><br><span class="line"> * sequence of RDDs (of the same type) representing a continuous stream of data (see</span><br><span class="line"> * org.apache.spark.rdd.RDD in the Spark core documentation for more details on RDDs).</span><br><span class="line"> * DStreams can either be created from live data (such as, data from TCP sockets, Kafka, Flume,</span><br><span class="line"> * etc.) using a [[org.apache.spark.streaming.StreamingContext]] or it can be generated by</span><br><span class="line"> * transforming existing DStreams using operations such as `map`,</span><br><span class="line"> * `window` and `reduceByKeyAndWindow`. While a Spark Streaming program is running, each DStream</span><br><span class="line"> * periodically generates a RDD, either from live data or by transforming the RDD generated by a</span><br><span class="line"> * parent DStream.</span><br><span class="line"> *</span><br><span class="line"> * This class contains the basic operations available on all DStreams, such as `map`, `filter` and</span><br><span class="line"> * `window`. In addition, [[org.apache.spark.streaming.dstream.PairDStreamFunctions]] contains</span><br><span class="line"> * operations available only on DStreams of key-value pairs, such as `groupByKeyAndWindow` and</span><br><span class="line"> * `join`. These operations are automatically available on any DStream of pairs</span><br><span class="line"> * (e.g., DStream[(Int, Int)] through implicit conversions.</span><br><span class="line"> *</span><br><span class="line"> * A DStream internally is characterized by a few basic properties:</span><br><span class="line"> *  - A list of other DStreams that the DStream depends on</span><br><span class="line"> *  - A time interval at which the DStream generates an RDD</span><br><span class="line"> *  - A function that is used to generate an RDD after each time interval</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">abstract class DStream[T: ClassTag] (</span><br><span class="line">    @transient private[streaming] var ssc: StreamingContext</span><br><span class="line">  ) extends Serializable with Logging &#123;</span><br><span class="line"></span><br><span class="line">注意：跟RDD 差不多 </span><br><span class="line">StreamingContext：就是流处理的上下文模型</span><br><span class="line">DStream ： is a continuous sequence of RDDs</span><br><span class="line">  就是一个流进来 按照时间批次(就是几秒一批次) 被拆成一个一个的RDD</span><br><span class="line">  DStream 由一串RDD构成  我们处理的时候 是以 RDD为单位进行处理的 </span><br><span class="line">  底层就是sparkcore </span><br><span class="line"></span><br><span class="line">DStream 这么来的呢？ 跟RDD一样 (看注释)</span><br><span class="line">	1.live data</span><br><span class="line">	2.别的DStream 转换来的 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">This class contains the basic operations available on all DStreams：</span><br><span class="line">看看有多少operations</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191031110110617.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> <img src="https://img-blog.csdnimg.cn/201910311101467.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">所以RDD算子一点要熟练掌握</span><br><span class="line"></span><br><span class="line">特性三个：</span><br><span class="line">	1.A list of other DStreams that the DStream depends on    </span><br><span class="line">		</span><br><span class="line">	2.A time interval at which the DStream generates an RDD</span><br><span class="line">		   时间间隔产生rdd     也就是  每隔多少时间处理一次</span><br><span class="line">	3. A function that is used to generate an RDD after each time interval</span><br><span class="line">	       	因为你一个DStream 由一堆RDD构成 是有顺序的</span><br><span class="line">	       	最终 你对DStream 做操作 其实就是对RDD做操作 </span><br><span class="line">	       	对RDD做操作 就是对 RDD里的每一个元素做操作</span><br></pre></td></tr></table></figure></div>

<p><strong>案列代码准备</strong></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">StreamingContext  有好多附属构造器的 </span><br><span class="line">class StreamingContext private[streaming] (</span><br><span class="line">    _sc: SparkContext,</span><br><span class="line">    _cp: Checkpoint,</span><br><span class="line">    _batchDur: Duration</span><br><span class="line">  ) extends Logging &#123;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Create a StreamingContext using an existing SparkContext.</span><br><span class="line">   * @param sparkContext existing SparkContext</span><br><span class="line">   * @param batchDuration the time interval at which streaming data will be divided into batches</span><br><span class="line">   */</span><br><span class="line">  def this(sparkContext: SparkContext, batchDuration: Duration) = &#123;</span><br><span class="line">    this(sparkContext, null, batchDuration)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Create a StreamingContext by providing the configuration necessary for a new SparkContext.</span><br><span class="line">   * @param conf a org.apache.spark.SparkConf object specifying Spark parameters</span><br><span class="line">   * @param batchDuration the time interval at which streaming data will be divided into batches</span><br><span class="line">   */</span><br><span class="line">  def this(conf: SparkConf, batchDuration: Duration) = &#123;</span><br><span class="line">    this(StreamingContext.createNewSparkContext(conf), null, batchDuration)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">我们选择 this(conf: SparkConf, batchDuration: Duration)   </span><br><span class="line"></span><br><span class="line">case class Duration (private val millis: Long)    单位是millis  </span><br><span class="line"></span><br><span class="line">你传Duration 太死板了想穿个秒数 还得算  看看有没有封装好的 </span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Helper object that creates instance of [[org.apache.spark.streaming.Duration]] representing</span><br><span class="line"> * a given number of seconds.</span><br><span class="line"> */</span><br><span class="line">object Seconds &#123;</span><br><span class="line">  def apply(seconds: Long): Duration = new Duration(seconds * 1000)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">封装一个工具类：</span><br><span class="line">object ContextUtils &#123;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">    * 获取sc</span><br><span class="line">    */</span><br><span class="line">  def getSparkContext(appname:String,defalut:String = &quot;local[2]&quot;): SparkContext = &#123;</span><br><span class="line"></span><br><span class="line">    val sparkConf = new SparkConf().setAppName(appname).setMaster(defalut)</span><br><span class="line"></span><br><span class="line">    new SparkContext(sparkConf)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">    * 获取ssc</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">  def getStreamingContext(appname:String,batch:Int,defalut:String = &quot;local&quot;) =&#123;</span><br><span class="line"></span><br><span class="line">    val sparkConf: SparkConf = new SparkConf().setAppName(appname).setMaster(defalut)</span><br><span class="line"></span><br><span class="line">    new StreamingContext(sparkConf,Seconds(batch))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">object AppName &#123;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line"></span><br><span class="line">    println(this.getClass.getName)    //包名+类名</span><br><span class="line">    println(this.getClass.getSimpleName)    //类名</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果是：</span><br><span class="line">com.ruozedata.spark.ss01.AppName$         </span><br><span class="line">AppName$</span><br></pre></td></tr></table></figure></div>
<p><strong>案例</strong><br>socket：<br><img src="https://img-blog.csdnimg.cn/20191031112414892.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有三个 ：用哪个呢？有什么区别呢？看下面</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">数据源：socket </span><br><span class="line"> /**</span><br><span class="line">   * Creates an input stream from TCP source hostname:port. Data is received using</span><br><span class="line">   * a TCP socket and the receive bytes is interpreted as UTF8 encoded `\n` delimited</span><br><span class="line">   * lines.</span><br><span class="line">   * @param hostname      Hostname to connect to for receiving data</span><br><span class="line">   * @param port          Port to connect to for receiving data</span><br><span class="line">   * @param storageLevel  Storage level to use for storing the received objects</span><br><span class="line">   *                      (default: StorageLevel.MEMORY_AND_DISK_SER_2)</span><br><span class="line">   * @see [[socketStream]]</span><br><span class="line">   */</span><br><span class="line">  def socketTextStream(</span><br><span class="line">      hostname: String,</span><br><span class="line">      port: Int,</span><br><span class="line">      storageLevel: StorageLevel = StorageLevel.MEMORY_AND_DISK_SER_2</span><br><span class="line">    ): ReceiverInputDStream[String] = withNamedScope(&quot;socket text stream&quot;) &#123;</span><br><span class="line">    socketStream[String](hostname, port, SocketReceiver.bytesToLines, storageLevel)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Creates an input stream from TCP source hostname:port. Data is received using</span><br><span class="line">   * a TCP socket and the receive bytes it interpreted as object using the given</span><br><span class="line">   * converter.</span><br><span class="line">   * @param hostname      Hostname to connect to for receiving data</span><br><span class="line">   * @param port          Port to connect to for receiving data</span><br><span class="line">   * @param converter     Function to convert the byte stream to objects</span><br><span class="line">   * @param storageLevel  Storage level to use for storing the received objects</span><br><span class="line">   * @tparam T            Type of the objects received (after converting bytes to objects)</span><br><span class="line">   */</span><br><span class="line">  def socketStream[T: ClassTag](</span><br><span class="line">      hostname: String,</span><br><span class="line">      port: Int,</span><br><span class="line">      converter: (InputStream) =&gt; Iterator[T],</span><br><span class="line">      storageLevel: StorageLevel</span><br><span class="line">    ): ReceiverInputDStream[T] = &#123;</span><br><span class="line">    new SocketInputDStream[T](this, hostname, port, converter, storageLevel)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">	socketTextStream </span><br><span class="line">		底层调用的是 socketStream</span><br><span class="line">		socketStream底层调用的是 SocketInputDStream</span><br><span class="line">    socketStream</span><br><span class="line">	底层调用的是 SocketInputDStream</span><br><span class="line"></span><br><span class="line">socketTextStream 和socketStream 就是入参不一样 用起来是一样的 </span><br><span class="line">那么SocketInputDStream：</span><br><span class="line"></span><br><span class="line">class SocketInputDStream[T: ClassTag](</span><br><span class="line">    _ssc: StreamingContext,</span><br><span class="line">    host: String,</span><br><span class="line">    port: Int,</span><br><span class="line">    bytesToObjects: InputStream =&gt; Iterator[T],</span><br><span class="line">    storageLevel: StorageLevel</span><br><span class="line">  ) extends ReceiverInputDStream[T]</span><br><span class="line"></span><br><span class="line">都是ReceiverInputDStream 这个 ******</span><br><span class="line"></span><br><span class="line">StorageLevel默认的是 MEMORY_AND_DISK_SER_2  </span><br><span class="line">跟sparkcore里是不一样的  为什么是2呢 ？</span><br></pre></td></tr></table></figure></div>

<p><a href="https://spark.apache.org/docs/latest/streaming-programming-guide.html#a-quick-example" target="_blank" rel="noopener">A Quick Example</a></p>
<p>测试：</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[double_happy@hadoop101 ~]$ nc -lk 9999</span><br><span class="line">a,a,a,a</span><br><span class="line">b,b,b,b</span><br></pre></td></tr></table></figure></div>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">object StreamingWCApp01 &#123;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line"></span><br><span class="line">    val ssc = ContextUtils.getStreamingContext(this.getClass.getSimpleName, 10)</span><br><span class="line"></span><br><span class="line">    //TODO... 填写我们的业务逻辑</span><br><span class="line">    // Input DStream</span><br><span class="line">    val lines: ReceiverInputDStream[String] = ssc.socketTextStream(&quot;hadoop101&quot;,9999)</span><br><span class="line"></span><br><span class="line">   //transformation</span><br><span class="line">    val result: DStream[(String, Int)] = lines.flatMap(_.split(&quot;,&quot;))</span><br><span class="line">      .map((_, 1)).reduceByKey(_ + _)</span><br><span class="line"></span><br><span class="line">    // output</span><br><span class="line">    result.print()</span><br><span class="line">    </span><br><span class="line">    ssc.start()</span><br><span class="line">    ssc.awaitTermination()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果是：</span><br><span class="line">19/10/31 11:35:31 WARN StreamingContext: spark.master should be set as local[n], n &gt; 1 in local mode if you have receivers to get data, otherwise Spark jobs will not get resources to process the received data.</span><br><span class="line">19/10/31 11:35:40 WARN RandomBlockReplicationPolicy: Expecting 1 replicas with only 0 peer/s.</span><br><span class="line">19/10/31 11:35:40 WARN BlockManager: Block input-0-1572492940600 replicated to only 0 peer(s) instead of 1 peers</span><br><span class="line">19/10/31 11:35:44 WARN RandomBlockReplicationPolicy: Expecting 1 replicas with only 0 peer/s.</span><br><span class="line">19/10/31 11:35:44 WARN BlockManager: Block input-0-1572492944000 replicated to only 0 peer(s) instead of 1 peers</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">为什么没有数据？</span><br><span class="line">先把 master local  改成 local[2] 再测试</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">[double_happy@hadoop101 ~]$ nc -lk 9999</span><br><span class="line">a,a,a,a</span><br><span class="line">b,b,b,b        这是我第一次测试</span><br><span class="line">                  第二次测试   第一批次</span><br><span class="line">a,a,a,a         </span><br><span class="line">b,b,b,b</span><br><span class="line"></span><br><span class="line">                   第二批次 </span><br><span class="line">a,a,a,a</span><br><span class="line">b,b,b,b</span><br><span class="line">a,a,a,a</span><br><span class="line">b,b,b,b</span><br><span class="line"></span><br><span class="line">结果是 ：</span><br><span class="line">-------------------------------------------</span><br><span class="line">Time: 1572493040000 ms</span><br><span class="line">-------------------------------------------</span><br><span class="line"></span><br><span class="line">19/10/31 11:37:24 WARN RandomBlockReplicationPolicy: Expecting 1 replicas with only 0 peer/s.</span><br><span class="line">19/10/31 11:37:24 WARN BlockManager: Block input-0-1572493044200 replicated to only 0 peer(s) instead of 1 peers</span><br><span class="line">19/10/31 11:37:25 WARN RandomBlockReplicationPolicy: Expecting 1 replicas with only 0 peer/s.</span><br><span class="line">19/10/31 11:37:25 WARN BlockManager: Block input-0-1572493045000 replicated to only 0 peer(s) instead of 1 peers</span><br><span class="line">-------------------------------------------</span><br><span class="line">Time: 1572493050000 ms</span><br><span class="line">-------------------------------------------</span><br><span class="line">(b,4)</span><br><span class="line">(a,4)</span><br><span class="line"></span><br><span class="line">-------------------------------------------</span><br><span class="line">Time: 1572493060000 ms</span><br><span class="line">-------------------------------------------</span><br><span class="line"></span><br><span class="line">19/10/31 11:37:42 WARN RandomBlockReplicationPolicy: Expecting 1 replicas with only 0 peer/s.</span><br><span class="line">19/10/31 11:37:42 WARN BlockManager: Block input-0-1572493062600 replicated to only 0 peer(s) instead of 1 peers</span><br><span class="line">19/10/31 11:37:43 WARN RandomBlockReplicationPolicy: Expecting 1 replicas with only 0 peer/s.</span><br><span class="line">19/10/31 11:37:43 WARN BlockManager: Block input-0-1572493062800 replicated to only 0 peer(s) instead of 1 peers</span><br><span class="line">19/10/31 11:37:43 WARN RandomBlockReplicationPolicy: Expecting 1 replicas with only 0 peer/s.</span><br><span class="line">19/10/31 11:37:43 WARN BlockManager: Block input-0-1572493063400 replicated to only 0 peer(s) instead of 1 peers</span><br><span class="line">-------------------------------------------</span><br><span class="line">Time: 1572493070000 ms</span><br><span class="line">-------------------------------------------</span><br><span class="line">(b,8)</span><br><span class="line">(a,8)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">1.</span><br><span class="line"> 上面的代码是处理  当前批次的</span><br><span class="line"> 不是求累加批次的 累加是另外的算子</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">After a context is defined, you have to do the following.</span><br><span class="line"></span><br><span class="line">    1.Define the input sources by creating input DStreams.</span><br><span class="line">	2.Define the streaming computations by applying transformation and output operations to DStreams.</span><br><span class="line">	3.Start receiving data and processing it using streamingContext.start().</span><br><span class="line">	4.Wait for the processing to be stopped (manually or due to any error) using streamingContext.awaitTermination().</span><br><span class="line">	5.The processing can be manually stopped using streamingContext.stop().</span><br><span class="line">Points to remember:</span><br><span class="line">	1.Once a context has been started, no new streaming computations can be set up or added to it.</span><br><span class="line">		就是说：</span><br><span class="line">			 ssc.start()</span><br><span class="line">			 在这加入逻辑处理是没有用的</span><br><span class="line">            ssc.awaitTermination()</span><br><span class="line">            </span><br><span class="line">	2.Once a context has been stopped, it cannot be restarted.</span><br><span class="line">	3.Only one StreamingContext can be active in a JVM at the same time.</span><br><span class="line">	4.stop() on StreamingContext also stops the SparkContext. To stop only the StreamingContext</span><br><span class="line">		 set the optional parameter of stop() called stopSparkContext to false.</span><br><span class="line">	5.A SparkContext can be re-used to create multiple StreamingContexts,</span><br><span class="line">	 as long as the previous StreamingContext is stopped (without stopping the SparkContext)</span><br><span class="line">	  before the next StreamingContext is created.</span><br></pre></td></tr></table></figure></div>

<p><img src="https://img-blog.csdnimg.cn/20191031131615454.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">上面案例讲解：</span><br><span class="line"></span><br><span class="line">1.既然是通过上下文ssc 去拿数据去 接收数据</span><br><span class="line">会有一个  接收器   在里面 </span><br><span class="line"></span><br><span class="line">socket 起在 9999 端口  需要一个接收器 把数据接收回来 </span><br><span class="line"></span><br><span class="line">下面</span><br></pre></td></tr></table></figure></div>
<p><a href="https://spark.apache.org/docs/latest/streaming-programming-guide.html#input-dstreams-and-receivers" target="_blank" rel="noopener">Input DStreams and Receivers</a></p>
<p><strong>Input DStreams</strong> are DStreams representing <strong>the stream of input data</strong> <strong>received from streaming sources.</strong> In the quick example, lines was an input DStream as it represented the stream of data received from the netcat server. Every input DStream (<strong>except file stream</strong>, discussed later in this section) is associated with a <strong>Receiver</strong> (Scala doc, Java doc) object which receives the data from a source and stores it in Spark’s memory for processing.</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1. lines was an input DStream</span><br><span class="line">2. Receiver :receives the data from a source and stores it in Spark’s memory for processing.</span><br><span class="line"></span><br><span class="line">所以 你假如不知道 哪个算子 里有接收器   看它返回值 返回值里是带Receiver 的 </span><br><span class="line">只要有返回值里是带Receiver   必然是有接收器的</span><br><span class="line">eg：</span><br><span class="line">			 val lines: ReceiverInputDStream[String]</span><br><span class="line"> </span><br><span class="line"> 不是所有的接收数据都需要接收器的 ***</span><br><span class="line"> 为什么呢？</span><br><span class="line"> 	eg：HDFS上的数据  直接通过API读进来就可以了 不需要接收器</span><br><span class="line"></span><br><span class="line">所以：</span><br><span class="line">上面的 master 设置 local  不是local[2]</span><br><span class="line">为什么1 不行呢？1的话 你的 jobid 0  就占用一个线程  后面没有资源线程处理了呀</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191031133816240.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">where &gt; n  因为 有些业务是需要多个流处理的   </span><br><span class="line">eg：你一套代码里面 有多个 socket  就有多个reciver了 明白吗？</span><br><span class="line"></span><br><span class="line">所以你 core的数量 要大于 recivers的数量   否则 你的程序只能接收数据 不能处理数据</span><br></pre></td></tr></table></figure></div>

<p><img src="https://img-blog.csdnimg.cn/20191031132936682.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">active job   ： receiver  是接收数据用的 一直在跑</span><br><span class="line">这个是永远存在的 因为 对于 socket模式 </span><br><span class="line">返回值是 ReceiverInputDStream 所有第一个Job是一直running在那的，职责就是接收数据</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191031133418106.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这幅图 调优的时候详细讲解</span><br></pre></td></tr></table></figure></div>

<p>*<em>操作讲解 *</em><br><a href="https://spark.apache.org/docs/latest/streaming-programming-guide.html#transformations-on-dstreams" target="_blank" rel="noopener">Transformations on DStreams</a></p>
<p>只有最后两个和RDD算子不一样 其他的都一样</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[double_happy@hadoop101 ~]$ nc -lk 9999</span><br><span class="line">a,c,b,b,b</span><br><span class="line">a,a,a,a,a</span><br><span class="line">b,b,b,b,b</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">object StreamingWCApp01 &#123;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line"></span><br><span class="line">    val ssc = ContextUtils.getStreamingContext(this.getClass.getSimpleName, 10)</span><br><span class="line"></span><br><span class="line">    //TODO... 填写我们的业务逻辑</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    val lines: ReceiverInputDStream[String] = ssc.socketTextStream(&quot;hadoop101&quot;,9999)</span><br><span class="line">    val result: DStream[(String, Int)] = lines.flatMap(_.split(&quot;,&quot;))</span><br><span class="line">      .map((_, 1)).reduceByKey(_ + _)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//    result.print()</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    //1.统计一个批次出现了多少个单词</span><br><span class="line">    lines.count().print() //一个批次有多少条数据</span><br><span class="line">    lines.flatMap(_.split(&quot;,&quot;)).count().print()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ssc.start()</span><br><span class="line">    ssc.awaitTermination()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果是：</span><br><span class="line">-------------------------------------------</span><br><span class="line">Time: 1572501470000 ms</span><br><span class="line">-------------------------------------------</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">-------------------------------------------</span><br><span class="line">Time: 1572501470000 ms</span><br><span class="line">-------------------------------------------</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">19/10/31 13:57:55 WARN RandomBlockReplicationPolicy: Expecting 1 replicas with only 0 peer/s.</span><br><span class="line">19/10/31 13:57:55 WARN BlockManager: Block input-0-1572501475400 replicated to only 0 peer(s) instead of 1 peers</span><br><span class="line">19/10/31 13:57:59 WARN RandomBlockReplicationPolicy: Expecting 1 replicas with only 0 peer/s.</span><br><span class="line">19/10/31 13:57:59 WARN BlockManager: Block input-0-1572501479200 replicated to only 0 peer(s) instead of 1 peers</span><br><span class="line">-------------------------------------------</span><br><span class="line">Time: 1572501480000 ms</span><br><span class="line">-------------------------------------------</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">-------------------------------------------</span><br><span class="line">Time: 1572501480000 ms</span><br><span class="line">-------------------------------------------</span><br><span class="line">15</span><br><span class="line"></span><br><span class="line">-------------------------------------------</span><br><span class="line">Time: 1572501490000 ms</span><br><span class="line">-------------------------------------------</span><br></pre></td></tr></table></figure></div>


<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[double_happy@hadoop101 ~]$ nc -lk 9999</span><br><span class="line">b,b,b,b,b</span><br><span class="line">a,a,a,a,a</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">object StreamingWCApp01 &#123;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line"></span><br><span class="line">    val ssc = ContextUtils.getStreamingContext(this.getClass.getSimpleName, 10)</span><br><span class="line"></span><br><span class="line">    //TODO... 填写我们的业务逻辑</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    val lines: ReceiverInputDStream[String] = ssc.socketTextStream(&quot;hadoop101&quot;,9999)</span><br><span class="line">    val result: DStream[(String, Int)] = lines.flatMap(_.split(&quot;,&quot;))</span><br><span class="line">      .map((_, 1)).reduceByKey(_ + _)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//    result.print()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //1.统计一个批次出现了多少个单词</span><br><span class="line">    lines.count().print() //一个批次有多少条数据</span><br><span class="line">    lines.flatMap(_.split(&quot;,&quot;)).countByValue().print()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ssc.start()</span><br><span class="line">    ssc.awaitTermination()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果是：</span><br><span class="line">-------------------------------------------</span><br><span class="line">Time: 1572501630000 ms</span><br><span class="line">-------------------------------------------</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">-------------------------------------------</span><br><span class="line">Time: 1572501630000 ms</span><br><span class="line">-------------------------------------------</span><br><span class="line"></span><br><span class="line">19/10/31 14:00:31 WARN RandomBlockReplicationPolicy: Expecting 1 replicas with only 0 peer/s.</span><br><span class="line">19/10/31 14:00:31 WARN BlockManager: Block input-0-1572501631200 replicated to only 0 peer(s) instead of 1 peers</span><br><span class="line">19/10/31 14:00:38 WARN RandomBlockReplicationPolicy: Expecting 1 replicas with only 0 peer/s.</span><br><span class="line">19/10/31 14:00:38 WARN BlockManager: Block input-0-1572501638400 replicated to only 0 peer(s) instead of 1 peers</span><br><span class="line">-------------------------------------------</span><br><span class="line">Time: 1572501640000 ms</span><br><span class="line">-------------------------------------------</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">-------------------------------------------</span><br><span class="line">Time: 1572501640000 ms</span><br><span class="line">-------------------------------------------</span><br><span class="line">(b,5)</span><br><span class="line">(a,5)</span><br><span class="line"></span><br><span class="line">-------------------------------------------</span><br><span class="line">Time: 1572501650000 ms</span><br><span class="line">-------------------------------------------</span><br></pre></td></tr></table></figure></div>

<p><a href="https://spark.apache.org/docs/latest/streaming-programming-guide.html#output-operations-on-dstreams" target="_blank" rel="noopener">Output Operations on DStreams</a></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  /**</span><br><span class="line">   * Save each RDD in this DStream as at text file, using string representation</span><br><span class="line">   * of elements. The file name at each batch interval is generated based on</span><br><span class="line">   * `prefix` and `suffix`: &quot;prefix-TIME_IN_MS.suffix&quot;.</span><br><span class="line">   */</span><br><span class="line">  def saveAsTextFiles(prefix: String, suffix: String = &quot;&quot;): Unit = ssc.withScope &#123;</span><br><span class="line">    val saveFunc = (rdd: RDD[T], time: Time) =&gt; &#123;</span><br><span class="line">      val file = rddToFileName(prefix, suffix, time)</span><br><span class="line">      rdd.saveAsTextFile(file)</span><br><span class="line">    &#125;</span><br><span class="line">    this.foreachRDD(saveFunc, displayInnerRDDOps = false)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">这个方法生产上能用么？</span><br><span class="line">假如你1s 处理一次  1s写一次 你hdfs很容易写爆掉的 </span><br><span class="line">如果要用 把写出去的文件 使用追加的方式写   或者 定期合并生成的文件 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">output opearation  和rdd 大部分都类似 </span><br><span class="line">foreachRDD  这个算子 之后讲解</span><br></pre></td></tr></table></figure></div>
<p><a href="https://spark.apache.org/docs/latest/streaming-programming-guide.html#input-dstreams-and-receivers" target="_blank" rel="noopener">Input DStreams and Receivers</a></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Spark Streaming provides two categories of built-in streaming sources.</span><br><span class="line"></span><br><span class="line">	1.Basic sources:</span><br><span class="line">		 Sources directly available in the StreamingContext API. </span><br><span class="line">		 Examples: file systems, and socket connections.</span><br><span class="line">	2.Advanced sources: </span><br><span class="line">		Sources like Kafka, Flume, Kinesis, etc. are available through extra utility classes. </span><br><span class="line">		These require linking against extra dependencies as discussed in the linking section.</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">流处理系统 一般对接的是 kafka  读文件用的少 </span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Create an input stream that monitors a Hadoop-compatible filesystem</span><br><span class="line">   * for new files and reads them as text files (using key as LongWritable, value</span><br><span class="line">   * as Text and input format as TextInputFormat). Files must be written to the</span><br><span class="line">   * monitored directory by &quot;moving&quot; them from another location within the same</span><br><span class="line">   * file system. File names starting with . are ignored.</span><br><span class="line">   * @param directory HDFS directory to monitor for new file</span><br><span class="line">   */</span><br><span class="line">  def textFileStream(directory: String): DStream[String] = withNamedScope(&quot;text file stream&quot;) &#123;</span><br><span class="line">    fileStream[LongWritable, Text, TextInputFormat](directory).map(_._2.toString)</span><br><span class="line">  &#125;</span><br><span class="line">底层fileStream  跟一下源码有兴趣的 前面文章讲过</span><br><span class="line"></span><br><span class="line">返回值是 DStream  所以 可以local1来处理 </span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line"> Files must be written to the</span><br><span class="line">   * monitored directory by &quot;moving&quot; them from another location within the same</span><br><span class="line">   * file system.</span><br><span class="line"></span><br><span class="line">All files must be in the same data format.  看官网</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191031141750538.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>

      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-Kafka01" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/15/Kafka01/">Kafka01</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2018/02/15/Kafka01/" class="article-date">
  <time datetime="2018-02-15T12:10:01.000Z" itemprop="datePublished">2018-02-15</time>
</a>
    
    
  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <p><a href="http://kafka.apache.org/" target="_blank" rel="noopener">官网</a></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.发布和订阅</span><br><span class="line">2.process  ： kafka自身的stream processing   kafkastreams</span><br><span class="line">3.store ：  Store streams of data safely in a distributed, replicated, fault-tolerant cluster.</span><br><span class="line"></span><br><span class="line">kafka如何保证高容错 、保证数据不丢失、？</span><br><span class="line">相当于HDFS的副本机制 eg：</span><br><span class="line">一个文件 打成 多个block块 一个block块 多少个副本</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.发布和订阅</span><br><span class="line">	对应的经典架构是什么呢：</span><br><span class="line">	Flume(生产者)--&gt;Kafka--&gt;SS SSS(消费者)</span><br></pre></td></tr></table></figure></div>
<p><strong>CDK：</strong><br><a href="https://docs.cloudera.com/documentation/kafka/4-1-x/topics/kafka_packaging.html" target="_blank" rel="noopener">CDK官网</a></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CDH版本的Kafka ：Kafka是需要自定义部署的   </span><br><span class="line"></span><br><span class="line">2.1.1   |	Apache Kafka	| 0.10.0.0+kafka2.1.1+21  </span><br><span class="line">代表什么意思？</span><br><span class="line">0.10.0.0   =》 Apache Kafka的版本</span><br><span class="line">2.1.1  =》  CDH版本 使用Apache Kafka 0.10.0.0 源码编译打补丁 后的 CDH版Kafka  的版本号</span><br><span class="line">21   =》 打了几次补丁的意思</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/2019102919561753.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Kafka的版本的选择 要基于 Spark</span><br><span class="line">http://spark.apache.org/docs/latest/streaming-kafka-integration.html</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191029200928752.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">这里我下载最新版本  </span><br><span class="line">el7 和 el6 有什么区别？</span><br><span class="line">el代表 centos的 </span><br><span class="line"> 7 -》 7.x  </span><br><span class="line"> 6--》6.x  </span><br><span class="line"></span><br><span class="line">解压之后 lib里</span><br><span class="line">kafka_2.11-2.2.1-kafka-4.1.0.jar</span><br><span class="line">2.11 scala 版本</span><br><span class="line">2.2.1 apache kafka版本</span><br><span class="line">4.1.0 cdk版本</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191029201428246.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">kafka：</span><br><span class="line">metadata--&gt;zk </span><br><span class="line">log--&gt;当前机器的Linux磁盘上  (Kakfa存的数据)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">部署;</span><br><span class="line">https://blog.csdn.net/jeffleo/article/details/75736474</span><br><span class="line"></span><br><span class="line">broker.id=0</span><br><span class="line">host.name=hadoop101</span><br><span class="line">port=9092</span><br><span class="line">log.dirs=/home/double_happy/tmp/kafka-logs00</span><br><span class="line">zookeeper.connect=hadoop101:2181/kafka</span><br><span class="line"></span><br><span class="line">broker.id=1</span><br><span class="line">host.name=hadoop101</span><br><span class="line">port=9093</span><br><span class="line">log.dirs=/home/double_happy/tmp/kafka-logs01</span><br><span class="line">zookeeper.connect=hadoop101:2181/kafka</span><br><span class="line"></span><br><span class="line">broker.id=2</span><br><span class="line">host.name=hadoop101</span><br><span class="line">port=9094</span><br><span class="line">log.dirs=/home/double_happy/tmp/kafka-logs02</span><br><span class="line">zookeeper.connect=hadoop101:2181/kafka</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">启动：</span><br><span class="line">bin/kafka-server-start.sh -daemon config/server.properties</span><br><span class="line">bin/kafka-server-start.sh -daemon config/server-1.properties</span><br><span class="line">bin/kafka-server-start.sh -daemon config/server-2.properties</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191029223326116.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>启动成功 </p>
<p>查看zk：</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 4] ls /</span><br><span class="line">[zookeeper, kafka]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 5]</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[double_happy@hadoop101 kafka]$ jps</span><br><span class="line">17088 QuorumPeerMain</span><br><span class="line">20992 Kafka</span><br><span class="line">4289 NodeManager</span><br><span class="line">21810 Jps</span><br><span class="line">4019 SecondaryNameNode</span><br><span class="line">21591 Kafka</span><br><span class="line">14999 AzkabanSingleServer</span><br><span class="line">20392 Kafka</span><br><span class="line">6633 HistoryServer</span><br><span class="line">3721 NameNode</span><br><span class="line">4186 ResourceManager</span><br><span class="line">3853 DataNode</span><br></pre></td></tr></table></figure></div>


<p>Kafka概念：</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">4.几个概念 </span><br><span class="line">producer: 生产者 Flume Maxwell</span><br><span class="line">consumer：消费者 SS/SSS/Flink/Flume</span><br><span class="line">broker： 消息处理节点  kafka的启动进程</span><br><span class="line"></span><br><span class="line">topic: 主题 </span><br><span class="line">	oms订单系统mysql.oms --&gt;maxwell--&gt;kafka  topic: oms  /oms文件夹下</span><br><span class="line">	wms仓库系统mysql.wms --&gt;maxwell--&gt;kafka  topic: wms  /wms文件夹下</span><br><span class="line"></span><br><span class="line">	app log---flume--&gt;kafka topic： applog</span><br><span class="line">	systemlog---flume--&gt;kafka topic： systemlog</span><br><span class="line"></span><br><span class="line">partition：分区 topic物理上的分组 (对应的Linux文件夹)，</span><br><span class="line">           一个topic 可以分&gt;=1个p，每个p是一个有序的队列：数据落地到磁盘 是0拷贝+按顺序追加写</span><br><span class="line">	  这就是kafka高效的数据中间件的原因</span><br><span class="line">      按顺序追加写 ： 磁盘的那个指针按一个方向追加和读写的 </span><br><span class="line">           oms_0 oms_1 oms_2</span><br><span class="line"></span><br><span class="line">这个parition ：</span><br><span class="line">相当于HDFS的副本机制 eg：</span><br><span class="line">一个文件 打成 多个block块 一个block块 多少个副本 </span><br><span class="line"></span><br><span class="line">kafka里的分区就相当于 HDFS里的分块的概念 </span><br><span class="line"></span><br><span class="line">replication：副本数   和HDFS的副本数 一样的</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">常用命令：</span><br><span class="line"></span><br><span class="line">[double_happy@hadoop101 bin]$ ./kafka-topics.sh </span><br><span class="line">Create, delete, describe, or change a topic.</span><br><span class="line">Option                                   Description                            </span><br><span class="line">------                                   -----------                            </span><br><span class="line">--alter                                  Alter the number of partitions,        </span><br><span class="line">                                           replica assignment, and/or           </span><br><span class="line">                                           configuration for the topic.         </span><br><span class="line">--bootstrap-server &lt;String: server to    REQUIRED: The Kafka server to connect  </span><br><span class="line">  connect to&gt;                              to. In case of providing this, a     </span><br><span class="line">                                           direct Zookeeper connection won&apos;t be </span><br><span class="line">                                           required.                            </span><br><span class="line">--command-config &lt;String: command        Property file containing configs to be </span><br><span class="line">  config property file&gt;                    passed to Admin Client. This is used </span><br><span class="line">                                           only with --bootstrap-server option  </span><br><span class="line">                                           for describing and altering broker   </span><br><span class="line">                                           configs.                             </span><br><span class="line">--config &lt;String: name=value&gt;            A topic configuration override for the </span><br><span class="line">                                           topic being created or altered.The   </span><br><span class="line">                                           following is a list of valid         </span><br><span class="line">                                           configurations:                      </span><br><span class="line">                                                cleanup.policy                        </span><br><span class="line">                                                compression.type                      </span><br><span class="line">                                                delete.retention.ms                   </span><br><span class="line">                                                file.delete.delay.ms                  </span><br><span class="line">                                                flush.messages                        </span><br><span class="line">                                                flush.ms                              </span><br><span class="line">                                                follower.replication.throttled.       </span><br><span class="line">                                           replicas                             </span><br><span class="line">                                                index.interval.bytes                  </span><br><span class="line">                                                leader.replication.throttled.replicas </span><br><span class="line">                                                max.message.bytes                     </span><br><span class="line">                                                message.downconversion.enable         </span><br><span class="line">                                                message.format.version                </span><br><span class="line">                                                message.timestamp.difference.max.ms   </span><br><span class="line">                                                message.timestamp.type                </span><br><span class="line">                                                min.cleanable.dirty.ratio             </span><br><span class="line">                                                min.compaction.lag.ms                 </span><br><span class="line">                                                min.insync.replicas                   </span><br><span class="line">                                                preallocate                           </span><br><span class="line">                                                retention.bytes                       </span><br><span class="line">                                                retention.ms                          </span><br><span class="line">                                                segment.bytes                         </span><br><span class="line">                                                segment.index.bytes                   </span><br><span class="line">                                                segment.jitter.ms                     </span><br><span class="line">                                                segment.ms                            </span><br><span class="line">                                                unclean.leader.election.enable        </span><br><span class="line">                                         See the Kafka documentation for full   </span><br><span class="line">                                           details on the topic configs.It is   </span><br><span class="line">                                           supported only in combination with --</span><br><span class="line">                                           create if --bootstrap-server option  </span><br><span class="line">                                           is used.                             </span><br><span class="line">--create                                 Create a new topic.                    </span><br><span class="line">--delete                                 Delete a topic                         </span><br><span class="line">--delete-config &lt;String: name&gt;           A topic configuration override to be   </span><br><span class="line">                                           removed for an existing topic (see   </span><br><span class="line">                                           the list of configurations under the </span><br><span class="line">                                           --config option). Not supported with </span><br><span class="line">                                           the --bootstrap-server option.       </span><br><span class="line">--describe                               List details for the given topics.     </span><br><span class="line">--disable-rack-aware                     Disable rack aware replica assignment  </span><br><span class="line">--exclude-internal                       exclude internal topics when running   </span><br><span class="line">                                           list or describe command. The        </span><br><span class="line">                                           internal topics will be listed by    </span><br><span class="line">                                           default                              </span><br><span class="line">--force                                  Suppress console prompts               </span><br><span class="line">--help                                   Print usage information.               </span><br><span class="line">--if-exists                              if set when altering or deleting or    </span><br><span class="line">                                           describing topics, the action will   </span><br><span class="line">                                           only execute if the topic exists.    </span><br><span class="line">                                           Not supported with the --bootstrap-  </span><br><span class="line">                                           server option.                       </span><br><span class="line">--if-not-exists                          if set when creating topics, the       </span><br><span class="line">                                           action will only execute if the      </span><br><span class="line">                                           topic does not already exist. Not    </span><br><span class="line">                                           supported with the --bootstrap-      </span><br><span class="line">                                           server option.                       </span><br><span class="line">--list                                   List all available topics.             </span><br><span class="line">--partitions &lt;Integer: # of partitions&gt;  The number of partitions for the topic </span><br><span class="line">                                           being created or altered (WARNING:   </span><br><span class="line">                                           If partitions are increased for a    </span><br><span class="line">                                           topic that has a key, the partition  </span><br><span class="line">                                           logic or ordering of the messages    </span><br><span class="line">                                           will be affected                     </span><br><span class="line">--replica-assignment &lt;String:            A list of manual partition-to-broker   </span><br><span class="line">  broker_id_for_part1_replica1 :           assignments for the topic being      </span><br><span class="line">  broker_id_for_part1_replica2 ,           created or altered.                  </span><br><span class="line">  broker_id_for_part2_replica1 :                                                </span><br><span class="line">  broker_id_for_part2_replica2 , ...&gt;                                           </span><br><span class="line">--replication-factor &lt;Integer:           The replication factor for each        </span><br><span class="line">  replication factor&gt;                      partition in the topic being created.</span><br><span class="line">--topic &lt;String: topic&gt;                  The topic to create, alter, describe   </span><br><span class="line">                                           or delete. It also accepts a regular </span><br><span class="line">                                           expression, except for --create      </span><br><span class="line">                                           option. Put topic name in double     </span><br><span class="line">                                           quotes and use the &apos;\&apos; prefix to     </span><br><span class="line">                                           escape regular expression symbols; e.</span><br><span class="line">                                           g. &quot;test\.topic&quot;.                    </span><br><span class="line">--topics-with-overrides                  if set when describing topics, only    </span><br><span class="line">                                           show topics that have overridden     </span><br><span class="line">                                           configs                              </span><br><span class="line">--unavailable-partitions                 if set when describing topics, only    </span><br><span class="line">                                           show partitions whose leader is not  </span><br><span class="line">                                           available                            </span><br><span class="line">--under-replicated-partitions            if set when describing topics, only    </span><br><span class="line">                                           show under replicated partitions     </span><br><span class="line">--zookeeper &lt;String: hosts&gt;              DEPRECATED, The connection string for  </span><br><span class="line">                                           the zookeeper connection in the form </span><br><span class="line">                                           host:port. Multiple hosts can be     </span><br><span class="line">                                           given to allow fail-over.            </span><br><span class="line">[double_happy@hadoop101 bin]$</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.创建topic</span><br><span class="line"></span><br><span class="line">[double_happy@hadoop101 kafka]$ bin/kafka-topics.sh \</span><br><span class="line">&gt; --create \</span><br><span class="line">&gt; --zookeeper hadoop101:2181/kafka \</span><br><span class="line">&gt; --replication-factor 3 \</span><br><span class="line">&gt; --partitions 3 \</span><br><span class="line">&gt; --topic test</span><br><span class="line">Created topic test.</span><br><span class="line">[double_happy@hadoop101 kafka]$</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191030101603723.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>华丽的分割线—————————————————————————————————————————–<br><img src="https://img-blog.csdnimg.cn/20191030101625339.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>华丽的分割线—————————————————————————————————————————–<br><img src="https://img-blog.csdnimg.cn/2019103010164530.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>华丽的分割线—————————————————————————————————————————–<br><img src="https://img-blog.csdnimg.cn/20191030102637736.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>华丽的分割线—————————————————————————————————————————–</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">注意：</span><br><span class="line">1.会创建3个文件夹 </span><br><span class="line">test-0</span><br><span class="line">test-1</span><br><span class="line">test-2</span><br><span class="line"></span><br><span class="line">test : topic 的名字   012 是partition的 下标从0开始 </span><br><span class="line"></span><br><span class="line">--replication-factor 3   三个副本指的是  我们有三台机器 副本数要 &lt;= 3     你三台机器 不能创建多余机器数的副本数</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2.查看我们的topic  ： 查看我当前的kafka集群有多少个Topic</span><br><span class="line">[double_happy@hadoop101 kafka]$ bin/kafka-topics.sh \</span><br><span class="line">&gt; --list \</span><br><span class="line">&gt; --zookeeper hadoop101:2181/kafka </span><br><span class="line">test</span><br><span class="line">[double_happy@hadoop101 kafka]$</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">3.查看 topic 明细   ***</span><br><span class="line">[double_happy@hadoop101 kafka]$ bin/kafka-topics.sh \</span><br><span class="line">&gt; --describe \</span><br><span class="line">&gt; --zookeeper hadoop101:2181/kafka \</span><br><span class="line">&gt; --topic test</span><br><span class="line">Topic:test      PartitionCount:3        ReplicationFactor:3     Configs:</span><br><span class="line">        Topic: test     Partition: 0    Leader: 1       Replicas: 1,0,2 Isr: 1,0,2</span><br><span class="line">        Topic: test     Partition: 1    Leader: 2       Replicas: 2,1,0 Isr: 2,1,0</span><br><span class="line">        Topic: test     Partition: 2    Leader: 0       Replicas: 0,2,1 Isr: 0,2,1</span><br><span class="line">[double_happy@hadoop101 kafka]$ </span><br><span class="line"></span><br><span class="line">解释：因为我是单节点部署三台kafka 这样说不好理解 我就把他变成三台机器部署三台kfaka </span><br><span class="line"></span><br><span class="line">1.机器</span><br><span class="line">broker 0  -&gt; Hadoop101</span><br><span class="line">broker 1 -&gt; Hadoop102</span><br><span class="line">broker 2 -&gt; Hadoop103</span><br><span class="line"></span><br><span class="line">2.明细</span><br><span class="line">Topic:test      PartitionCount:3        ReplicationFactor:3     Configs:</span><br><span class="line">        Topic: test     Partition: 0    Leader: 1   Hadoop102      Replicas: 1,0,2 Isr: 1,0,2</span><br><span class="line">        Topic: test     Partition: 1    Leader: 2   Hadoop103   Replicas: 2,1,0 Isr: 2,1,0</span><br><span class="line">        Topic: test     Partition: 2    Leader: 0   Hadoop101    Replicas: 0,2,1 Isr: 0,2,1</span><br><span class="line"></span><br><span class="line">3.解释</span><br><span class="line">Leader、Replicas、Isr：里面的数字 代表  broker id</span><br><span class="line">Partition：数字 代表 paritition的下标</span><br><span class="line">Leader ：该分区 负责对外的 读写的节点 </span><br><span class="line"></span><br><span class="line">3.1    按 分区0 进行解释 </span><br><span class="line">对于test 这个主题来说，我们的数据完整性 是由三个分区 来组成的  012 partition</span><br><span class="line"></span><br><span class="line">就是说 我0分区 由分本数 三个副本 三个副本是分散在不同的机器上面的</span><br><span class="line">但是哪个机器进行对外读和写呢 ？是由Leader 的值来表现的 </span><br><span class="line"></span><br><span class="line">那么：</span><br><span class="line">0 分区的数据 是由 哪台机器 来进行对外读写 提供的(Leader 1) 说明是 broker 1 号机器 Hadoop102</span><br><span class="line"></span><br><span class="line">那么 ：</span><br><span class="line"> Replicas: 1,0,2   表示 复制分区的节点的列表 </span><br><span class="line"> 0,2 =》表示 Hadoop103、Hadoop101    这两台机器对parittion 0 进行数据的复制同步</span><br><span class="line"></span><br><span class="line">Isr：in-sync 表示正在同步的集群列表</span><br><span class="line"></span><br><span class="line">那么：</span><br><span class="line">isr: 1,0,2  </span><br><span class="line">	1表示对外的 leader</span><br><span class="line">	假设分区0 对应的leader 1 机器挂了 ，那么 0 将会作为leader 进行对外提供服务</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">关键点：</span><br><span class="line">1.分区  topic的数据完整性</span><br><span class="line">2.谁负责对外读写</span><br><span class="line">3.谁负责分区数据同步</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">测试：isr</span><br><span class="line"></span><br><span class="line">[double_happy@hadoop101 kafka]$ bin/kafka-topics.sh --describe --zookeeper hadoop101:2181/kafka --topic test</span><br><span class="line">Topic:test      PartitionCount:3        ReplicationFactor:3     Configs:</span><br><span class="line">        Topic: test     Partition: 0    Leader: 1       Replicas: 1,0,2 Isr: 1,0,2</span><br><span class="line">        Topic: test     Partition: 1    Leader: 2       Replicas: 2,1,0 Isr: 2,1,0</span><br><span class="line">        Topic: test     Partition: 2    Leader: 0       Replicas: 0,2,1 Isr: 0,2,1</span><br><span class="line">[double_happy@hadoop101 kafka]$ jps</span><br><span class="line">17088 QuorumPeerMain</span><br><span class="line">4289 NodeManager</span><br><span class="line">4019 SecondaryNameNode</span><br><span class="line">24260 Kafka</span><br><span class="line">23653 Kafka</span><br><span class="line">14999 AzkabanSingleServer</span><br><span class="line">6633 HistoryServer</span><br><span class="line">3721 NameNode</span><br><span class="line">4186 ResourceManager</span><br><span class="line">3853 DataNode</span><br><span class="line">24862 Kafka</span><br><span class="line">31278 Jps</span><br><span class="line">[double_happy@hadoop101 kafka]$ kill -9 24260</span><br><span class="line">[double_happy@hadoop101 kafka]$ </span><br><span class="line">[double_happy@hadoop101 kafka]$ bin/kafka-topics.sh --describe --zookeeper hadoop101:2181/kafka --topic test</span><br><span class="line">Topic:test      PartitionCount:3        ReplicationFactor:3     Configs:</span><br><span class="line">        Topic: test     Partition: 0    Leader: 0       Replicas: 1,0,2 Isr: 0,2</span><br><span class="line">        Topic: test     Partition: 1    Leader: 2       Replicas: 2,1,0 Isr: 2,0</span><br><span class="line">        Topic: test     Partition: 2    Leader: 0       Replicas: 0,2,1 Isr: 0,2</span><br><span class="line">[double_happy@hadoop101 kafka]$</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">很巧 瞎kill一个真的把 1 broker kill掉了 </span><br><span class="line"></span><br><span class="line">注意;</span><br><span class="line">	看paritition 0  是不是 1被干掉之后 0上位了 当成了leader</span><br><span class="line">2.你kill -9  是不是太暴力了 </span><br><span class="line">查看</span><br><span class="line"></span><br><span class="line">[double_happy@hadoop101 bin]$ cat kafka-server-stop.sh</span><br><span class="line">#!/bin/sh</span><br><span class="line"># Licensed to the Apache Software Foundation (ASF) under one or more</span><br><span class="line"># contributor license agreements.  See the NOTICE file distributed with</span><br><span class="line"># this work for additional information regarding copyright ownership.</span><br><span class="line"># The ASF licenses this file to You under the Apache License, Version 2.0</span><br><span class="line"># (the &quot;License&quot;); you may not use this file except in compliance with</span><br><span class="line"># the License.  You may obtain a copy of the License at</span><br><span class="line">#</span><br><span class="line">#    http://www.apache.org/licenses/LICENSE-2.0</span><br><span class="line">#</span><br><span class="line"># Unless required by applicable law or agreed to in writing, software</span><br><span class="line"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span><br><span class="line"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="line"># See the License for the specific language governing permissions and</span><br><span class="line"># limitations under the License.</span><br><span class="line">SIGNAL=$&#123;SIGNAL:-TERM&#125;</span><br><span class="line">PIDS=$(ps ax | grep -i &apos;kafka\.Kafka&apos; | grep java | grep -v grep | awk &apos;&#123;print $1&#125;&apos;)</span><br><span class="line"></span><br><span class="line">if [ -z &quot;$PIDS&quot; ]; then</span><br><span class="line">  echo &quot;No kafka server to stop&quot;</span><br><span class="line">  exit 1</span><br><span class="line">else</span><br><span class="line">  kill -s $SIGNAL $PIDS</span><br><span class="line">fi</span><br><span class="line">[double_happy@hadoop101 bin]$ </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">官方使用 kill -s  接受一个信号    有兴趣了解一下 但是官方也用了 kill</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">重启 broker 1 ：</span><br><span class="line">[double_happy@hadoop101 kafka]$ bin/kafka-topics.sh --describe --zookeeper hadoop101:2181/kafka --topic test</span><br><span class="line">Topic:test      PartitionCount:3        ReplicationFactor:3     Configs:</span><br><span class="line">        Topic: test     Partition: 0    Leader: 0       Replicas: 1,0,2 Isr: 0,2</span><br><span class="line">        Topic: test     Partition: 1    Leader: 2       Replicas: 2,1,0 Isr: 2,0</span><br><span class="line">        Topic: test     Partition: 2    Leader: 0       Replicas: 0,2,1 Isr: 0,2</span><br><span class="line">[double_happy@hadoop101 kafka]$ bin/kafka-server-start.sh -daemon config/server-1.properties</span><br><span class="line">[double_happy@hadoop101 kafka]$ bin/kafka-topics.sh --describe --zookeeper hadoop101:2181/kafka --topic test</span><br><span class="line"> </span><br><span class="line">Topic:test      PartitionCount:3        ReplicationFactor:3     Configs:</span><br><span class="line">        Topic: test     Partition: 0    Leader: 0       Replicas: 1,0,2 Isr: 0,2,1</span><br><span class="line">        Topic: test     Partition: 1    Leader: 2       Replicas: 2,1,0 Isr: 2,0,1</span><br><span class="line">        Topic: test     Partition: 2    Leader: 0       Replicas: 0,2,1 Isr: 0,2,1</span><br><span class="line">[double_happy@hadoop101 kafka]$</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">4.删除 Topic</span><br><span class="line">[double_happy@hadoop101 kafka]$ bin/kafka-topics.sh \</span><br><span class="line">&gt; --delete \</span><br><span class="line">&gt; --zookeeper hadoop101:2181/kafka \</span><br><span class="line">&gt; --topic test</span><br><span class="line">Topic test is marked for deletion.</span><br><span class="line">Note: This will have no impact if delete.topic.enable is not set to true.</span><br><span class="line">[double_happy@hadoop101 kafka]$ </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">Topic test is marked for deletion.   已经标识了删除  那么我们还能不能查看到呢？</span><br><span class="line"></span><br><span class="line">[double_happy@hadoop101 kafka]$ bin/kafka-topics.sh --delete --zookeeper hadoop101:2181/kafka --topic test</span><br><span class="line">Error while executing topic command : Topics in [] does not exist</span><br><span class="line">[2019-10-30 11:06:04,714] ERROR java.lang.IllegalArgumentException: Topics in [] does not exist</span><br><span class="line">        at kafka.admin.TopicCommand$.kafka$admin$TopicCommand$$ensureTopicExists(TopicCommand.scala:416)</span><br><span class="line">        at kafka.admin.TopicCommand$ZookeeperTopicService.deleteTopic(TopicCommand.scala:377)</span><br><span class="line">        at kafka.admin.TopicCommand$.main(TopicCommand.scala:68)</span><br><span class="line">        at kafka.admin.TopicCommand.main(TopicCommand.scala)</span><br><span class="line"> (kafka.admin.TopicCommand$)</span><br><span class="line">[double_happy@hadoop101 kafka]$</span><br><span class="line"></span><br><span class="line">查看不到了 说明Topic 已经不存在了 </span><br><span class="line"></span><br><span class="line">去机器上 看一下目录</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191030110911261.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">正常应该由 delete 标识的  等重启Kafak之后 会彻底删除 delete 标识的文件夹  </span><br><span class="line"></span><br><span class="line">我这里没有演示出来  </span><br><span class="line"></span><br><span class="line">Note: This will have no impact if delete.topic.enable is not set to true.</span><br><span class="line"></span><br><span class="line">这个提示是 表示;</span><br><span class="line">delete.topic.enable  参数没有设值为 true  那么 删除不会立马起作用 </span><br><span class="line">(双重否定 表示 肯定   是true 就会立马删除 )</span><br><span class="line"></span><br><span class="line">去官网看看：</span><br><span class="line">delete.topic.enable 默认 就是 true  </span><br><span class="line">所以 提示这句话 就是 放屁 </span><br><span class="line">但是也要注意 生产上别随便删除 Topic 删了可能会导致 kafka起不来 真的 别没事找事做</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191030111503573.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">我想总结的是这个 删除topic 可能会导致kafka故障？</span><br><span class="line">删除整理:</span><br><span class="line">1.⽣产上命名不要有标点符号的字符，就英⽂ 可以带数字 默认⼩写</span><br><span class="line">2.假如已经在运⾏的kafka 只有1个topic，你可以删除，0⻛险</span><br><span class="line">3.假如已经在运⾏的kafka 只有多个topic，忍，⻛险可能存在  (你把自己的topic 删完 kafka坏了 别人的topic也没法用了 )</span><br><span class="line">4.千万不要⼿贱或者强迫症，看topic名称不舒服，去删除topic，删除需谨慎！</span><br><span class="line">5.删除不可逆，细⼼操作删除命令！</span><br><span class="line"></span><br><span class="line">删除可能遇到的问题？当你真的要删除Topic的时候 </span><br><span class="line">       如果可以重启kafka 就重启kafka 不能重启看下面</span><br><span class="line">假如删除不⼲净:</span><br><span class="line">1.linux磁盘⽂件夹  手工删除 </span><br><span class="line">2.zk的/kafka的</span><br><span class="line">ls /kafka/brokers/topics</span><br><span class="line">ls /kafka/config/topics</span><br><span class="line">默认delete.topic.enable=true，执⾏删除命令后，⽆需关⼼。(因为会立马删除掉 )</span><br><span class="line"></span><br><span class="line">看一下刚刚删除完的 topic 在zk的元数据</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 0] ls /</span><br><span class="line">[zookeeper, kafka]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 1] ls /kafka/brokers/topics</span><br><span class="line">[]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 2] ls /kafka/config/topics</span><br><span class="line">[]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 3] </span><br><span class="line"></span><br><span class="line">没有 说明删的 很干净</span><br></pre></td></tr></table></figure></div>



<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">5..修改topic</span><br><span class="line"></span><br><span class="line">[double_happy@hadoop101 kafka]$ bin/kafka-topics.sh \</span><br><span class="line">&gt; --create \</span><br><span class="line">&gt; --zookeeper hadoop101:2181/kafka \</span><br><span class="line">&gt; --replication-factor 1 \</span><br><span class="line">&gt; --partitions 1 \</span><br><span class="line">&gt; --topic g7</span><br><span class="line">Created topic g7.</span><br><span class="line">[double_happy@hadoop101 kafka]$ </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">（1）修改分区数量 </span><br><span class="line">[double_happy@hadoop101 kafka]$ bin/kafka-topics.sh \</span><br><span class="line">&gt; --alter \</span><br><span class="line">&gt; --zookeeper hadoop101:2181/kafka \</span><br><span class="line">&gt; --topic g7 --partitions 3</span><br><span class="line">WARNING: If partitions are increased for a topic that has a key, the partition logic or ordering of the messages will be affected</span><br><span class="line">Adding partitions succeeded!</span><br><span class="line">[double_happy@hadoop101 kafka]$</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/2019103011415749.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>华丽的分割线————————————————————————————————————</p>
<p>添加分区之后：<br><img src="https://img-blog.csdnimg.cn/20191030114325796.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">没有 g7-1 g7-2</span><br><span class="line">说明分区的副本只有一份   其他分区落不进来</span><br><span class="line"></span><br><span class="line">副本数 一般3分 </span><br><span class="line">broker 8台机器 qbs很高的 生产上 是这么用的   3，4万的qbs</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">查看明细：</span><br><span class="line">[double_happy@hadoop101 kafka]$ bin/kafka-topics.sh \</span><br><span class="line">&gt; --describe \</span><br><span class="line">&gt; --zookeeper hadoop101:2181/kafka \</span><br><span class="line">&gt; --topic g7 </span><br><span class="line">Topic:g7        PartitionCount:3     ReplicationFactor:1      Configs:</span><br><span class="line">        Topic: g7       Partition: 0 Leader: 2        Replicas: 2     Isr: 2</span><br><span class="line">        Topic: g7       Partition: 1 Leader: 0        Replicas: 0     Isr: 0</span><br><span class="line">        Topic: g7       Partition: 2 Leader: 1        Replicas: 1     Isr: 1</span><br><span class="line">[double_happy@hadoop101 kafka]$ </span><br><span class="line"></span><br><span class="line">说明副本只有一个  isr 只有一个 挂了 就丢数据了</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">6.自动迁移数据到 新的节点 ：</span><br><span class="line"></span><br><span class="line">假如有一天 你的kafka需要添加机器 那么你之前的kafka数据 要进行迁移</span><br></pre></td></tr></table></figure></div>
<p><a href="http://kafka.apache.org/22/documentation.html#basic_ops_automigrate" target="_blank" rel="noopener">迁移官网</a></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1.  kafka-reassign-partitions.sh    使用这个脚本 </span><br><span class="line">重新分配我们的partition  这种情况下主要是针对 </span><br><span class="line">kafka的集群规模 数据量 扛不住了</span><br><span class="line">需要新加机器来平衡我的数据量 </span><br><span class="line"></span><br><span class="line">就三步：</span><br><span class="line">1.生成一个json的文件 </span><br><span class="line">bin/kafka-reassign-partitions.sh --zookeeper localhost:2181 --topics-to-move-json-file topics-to-move.json --broker-list &quot;5,6&quot; --generate</span><br><span class="line"></span><br><span class="line">就这个命令 会生成 json文件 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--broker-list &quot;5,6&quot;     表示 1234 下架 只用56   如果你用1356  那么这个参数这么写呢 ？</span><br><span class="line">                    --broker-list &quot;1,3,5,6&quot;   明白了吗？</span><br><span class="line"></span><br><span class="line">2.json文件就是一个标准 后面根据它 进行重新分配    (就是根据json 去执行)</span><br><span class="line">bin/kafka-reassign-partitions.sh --zookeeper localhost:2181 --reassignment-json-file expand-cluster-reassignment.json --execute</span><br><span class="line"></span><br><span class="line">3. 验证第二步  (进行校验)</span><br><span class="line">bin/kafka-reassign-partitions.sh --zookeeper localhost:2181 --reassignment-json-file expand-cluster-reassignment.json --verify</span><br></pre></td></tr></table></figure></div>

<p><img src="https://img-blog.csdnimg.cn/20191030115720114.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">工作时候 用的很少 一般都是事先规划好的 机器</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">7.console案例   很简单 </span><br><span class="line"></span><br><span class="line">生产者：</span><br><span class="line">[double_happy@hadoop101 kafka]$ bin/kafka-console-producer.sh \</span><br><span class="line">&gt; --broker-list hadoop101:9092,hadoop101:9093,hadoop101:9094 \</span><br><span class="line">&gt; --topic g7</span><br><span class="line">&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">消费者：</span><br><span class="line">[double_happy@hadoop101 kafka]$ bin/kafka-console-consumer.sh \</span><br><span class="line">&gt; --bootstrap-server hadoop101:9092,hadoop101:9093,hadoop101:9094 \</span><br><span class="line">&gt; --topic g7 \</span><br><span class="line">&gt; --from-beginning</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">这就模拟了 生产者 发送数据到 broker  然后消费者进行消费</span><br></pre></td></tr></table></figure></div>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">生产者：</span><br><span class="line">[double_happy@hadoop101 kafka]$ bin/kafka-console-producer.sh \</span><br><span class="line">&gt; --broker-list hadoop101:9092,hadoop101:9093,hadoop101:9094 \</span><br><span class="line">&gt; --topic g7</span><br><span class="line">&gt;doubleHappy</span><br><span class="line">&gt;1</span><br><span class="line">&gt;2</span><br><span class="line">&gt;3</span><br><span class="line">&gt;4</span><br><span class="line">&gt;5</span><br><span class="line">&gt;6</span><br><span class="line">&gt;7</span><br><span class="line">&gt;8</span><br><span class="line">&gt;9</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">消费者：</span><br><span class="line">[double_happy@hadoop101 kafka]$ bin/kafka-console-consumer.sh \</span><br><span class="line">&gt; --bootstrap-server hadoop101:9092,hadoop101:9093,hadoop101:9094 \</span><br><span class="line">&gt; --topic g7 \</span><br><span class="line">&gt; --from-beginning</span><br><span class="line">doubleHappy</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">那么我把消费者 打断 重新 起来 ：</span><br><span class="line"></span><br><span class="line">--from-beginning  表示 从头开始消费    表示消息从最初始的位置开始消费 </span><br><span class="line"></span><br><span class="line">[double_happy@hadoop101 kafka]$ bin/kafka-console-consumer.sh --bootstrap-server hadoop101:9092,hadoop101:9093,hadoop101:9094 --topic g7 --from-beginning</span><br><span class="line">1</span><br><span class="line">4</span><br><span class="line">7</span><br><span class="line">2</span><br><span class="line">5</span><br><span class="line">8</span><br><span class="line">doubleHappy</span><br><span class="line">3</span><br><span class="line">6</span><br><span class="line">9</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">问题：</span><br><span class="line">是不是乱序了   指的是全局乱序的   因为kafka 单分区 数据是有序的 (就是 每个分区内的数据 在各自当前分区是有序的 )</span><br><span class="line"></span><br><span class="line">数据在生产的时候 发送到kafka的时候</span><br><span class="line"> 数据是发往不同的分区里 </span><br><span class="line"></span><br><span class="line">不同分区里的数据应该是这样的：</span><br><span class="line">1 4 7     |    2 5 8  |  doubleHappy  3 6 9</span><br><span class="line"></span><br><span class="line">**数据在每个 分区内部是有序的    </span><br><span class="line"></span><br><span class="line">那么 如何保证数据 全局有序？</span><br><span class="line">    自己思考思考 我下篇文章写</span><br></pre></td></tr></table></figure></div>

<p>故障案例：</p>
<p>异构平台Kafka对接使⽤<br><a href="http://blog.itpub.net/30089851/viewspace-2152671/" target="_blank" rel="noopener">http://blog.itpub.net/30089851/viewspace-2152671/</a></p>

      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-Redis" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/10/Redis/">Redis</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2018/02/10/Redis/" class="article-date">
  <time datetime="2018-02-10T12:09:12.000Z" itemprop="datePublished">2018-02-10</time>
</a>
    
    
  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <p>是NoSQL的<br><a href="https://redis.io/" target="_blank" rel="noopener">官网</a></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Redis:</span><br><span class="line">	1.NoSQL的数据库</span><br><span class="line">	2.key-value方式存储的  内存数据库</span><br><span class="line">	    key ：通常是String类型</span><br><span class="line">	    value：strings, hashes, lists, sets, sorted sets  等 选择哪一个根据业务来定的 </span><br><span class="line">redis 数据存在内存里的 万一挂掉了怎么办？</span><br><span class="line">虽然内部有机制  ： 定时的把内存数据 刷到磁盘上面 重启之后 可以把磁盘上的数据加载进来的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">特性：</span><br><span class="line">	1.速度快 1s 十万次  读写非常好的 </span><br><span class="line">	2. 持久化   两种 RBD(快照的方式 ) 和 AOF(记录所有操作的 写到日志文件里去的)的  </span><br><span class="line">	    重启之后优先AOF  因为 数据更加完整  RBD是定时的快照 </span><br><span class="line">	    	eg：10s 做一次快照 8s的时候挂掉了  这8s的数据就丢了 </span><br><span class="line">	3.数据类型 </span><br><span class="line">	4.多语言的  java scala 都可以</span><br><span class="line">	5.其他功能 ： 发布订阅 事务 pipeline(指的是 多条指令 可以放在一起 最后 发一条指令    代替 而不是一条数据一个指令  网络传输少很多  工作当中批量的 一定要采用pipeline的方式 发送请求)</span><br><span class="line">	6.单线程的 </span><br><span class="line">	7.有集群 有主从复制    来保证分布式和高可用</span><br><span class="line"></span><br><span class="line">国内 微博 使用redis的多</span><br></pre></td></tr></table></figure></div>
<p><strong>操作：</strong></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">[double_happy@hadoop101 src]$ ls redis-server </span><br><span class="line">redis-server                服务端的 </span><br><span class="line">[double_happy@hadoop101 src]$ ls redis-cli</span><br><span class="line">redis-cli                         客户端的</span><br><span class="line">[double_happy@hadoop101 src]$</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[double_happy@hadoop101 redis-5.0.5]$ make  install</span><br><span class="line">cd src &amp;&amp; make install</span><br><span class="line">make[1]: Entering directory `/home/double_happy/app/redis-5.0.5/src&apos;</span><br><span class="line">    CC Makefile.dep</span><br><span class="line">make[1]: Leaving directory `/home/double_happy/app/redis-5.0.5/src&apos;</span><br><span class="line">make[1]: Entering directory `/home/double_happy/app/redis-5.0.5/src&apos;</span><br><span class="line"></span><br><span class="line">Hint: It&apos;s a good idea to run &apos;make test&apos; ;)</span><br><span class="line"></span><br><span class="line">    INSTALL install</span><br><span class="line">install: cannot create regular file ‘/usr/local/bin/redis-server’: Permission denied</span><br><span class="line">make[1]: *** [install] Error 1</span><br><span class="line">make[1]: Leaving directory `/home/double_happy/app/redis-5.0.5/src&apos;</span><br><span class="line">make: *** [install] Error 2</span><br><span class="line">[double_happy@hadoop101 redis-5.0.5]$ sudo make install</span><br><span class="line">cd src &amp;&amp; make install</span><br><span class="line">make[1]: Entering directory `/home/double_happy/app/redis-5.0.5/src&apos;</span><br><span class="line"></span><br><span class="line">Hint: It&apos;s a good idea to run &apos;make test&apos; ;)</span><br><span class="line"></span><br><span class="line">    INSTALL install</span><br><span class="line">    INSTALL install</span><br><span class="line">    INSTALL install</span><br><span class="line">    INSTALL install</span><br><span class="line">    INSTALL install</span><br><span class="line">make[1]: Leaving directory `/home/double_happy/app/redis-5.0.5/src&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">你把redis编译好了 </span><br><span class="line">‘/usr/local/bin/redis-server 这个目录下也是有 redis-server的</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">启动：</span><br><span class="line">[double_happy@hadoop101 ~]$ redis-server </span><br><span class="line">27132:C 29 Oct 2019 13:41:11.883 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span><br><span class="line">27132:C 29 Oct 2019 13:41:11.883 # Redis version=5.0.5, bits=64, commit=00000000, modified=0, pid=27132, just started</span><br><span class="line">27132:C 29 Oct 2019 13:41:11.883 # Warning: no config file specified, using the default config. In order to specify a config file use redis-server /path/to/redis.conf</span><br><span class="line">                _._                                                  </span><br><span class="line">           _.-``__ &apos;&apos;-._                                             </span><br><span class="line">      _.-``    `.  `_.  &apos;&apos;-._           Redis 5.0.5 (00000000/0) 64 bit</span><br><span class="line">  .-`` .-```.  ```\/    _.,_ &apos;&apos;-._                                   </span><br><span class="line"> (    &apos;      ,       .-`  | `,    )     Running in standalone mode</span><br><span class="line"> |`-._`-...-` __...-.``-._|&apos;` _.-&apos;|     Port: 6379</span><br><span class="line"> |    `-._   `._    /     _.-&apos;    |     PID: 27132</span><br><span class="line">  `-._    `-._  `-./  _.-&apos;    _.-&apos;                                   </span><br><span class="line"> |`-._`-._    `-.__.-&apos;    _.-&apos;_.-&apos;|                                  </span><br><span class="line"> |    `-._`-._        _.-&apos;_.-&apos;    |           http://redis.io        </span><br><span class="line">  `-._    `-._`-.__.-&apos;_.-&apos;    _.-&apos;                                   </span><br><span class="line"> |`-._`-._    `-.__.-&apos;    _.-&apos;_.-&apos;|                                  </span><br><span class="line"> |    `-._`-._        _.-&apos;_.-&apos;    |                                  </span><br><span class="line">  `-._    `-._`-.__.-&apos;_.-&apos;    _.-&apos;                                   </span><br><span class="line">      `-._    `-.__.-&apos;    _.-&apos;                                       </span><br><span class="line">          `-._        _.-&apos;                                           </span><br><span class="line">              `-.__.-&apos;                                               </span><br><span class="line"></span><br><span class="line">27132:M 29 Oct 2019 13:41:11.884 # WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.</span><br><span class="line">27132:M 29 Oct 2019 13:41:11.884 # Server initialized</span><br><span class="line">27132:M 29 Oct 2019 13:41:11.884 # WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add &apos;vm.overcommit_memory = 1&apos; to /etc/sysctl.conf and then reboot or run the command &apos;sysctl vm.overcommit_memory=1&apos; for this to take effect.</span><br><span class="line">27132:M 29 Oct 2019 13:41:11.884 # WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command &apos;echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled&apos; as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled.</span><br><span class="line">27132:M 29 Oct 2019 13:41:11.884 * Ready to accept connections</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">6379  redis经典端口  </span><br><span class="line"></span><br><span class="line">[double_happy@hadoop101 redis-5.0.5]$ ps -ef | grep redis</span><br><span class="line">double_+ 27132 16513  0 13:41 pts/1    00:00:00 redis-server *:6379</span><br><span class="line">double_+ 27148 15274  0 13:42 pts/0    00:00:00 grep --color=auto redis</span><br><span class="line">[double_happy@hadoop101 redis-5.0.5]$ </span><br><span class="line"></span><br><span class="line">说明redis  服务端启动了 </span><br><span class="line">再启动客户端 ：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[double_happy@hadoop101 ~]$ redis-cli </span><br><span class="line">127.0.0.1:6379&gt; keys*</span><br><span class="line">(error) ERR unknown command `keys*`, with args beginning with: </span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty list or set)</span><br><span class="line">127.0.0.1:6379&gt; set name double_happy</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) &quot;name&quot;</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">&quot;double_happy&quot;</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">后台运行：需要对redis.conf 文件进行简单的配置 配置一下 logfile位置 </span><br><span class="line"></span><br><span class="line">[double_happy@hadoop101 redis-5.0.5]$ src/redis-server redis.conf              </span><br><span class="line">[double_happy@hadoop101 redis-5.0.5]$ tail -200f ~/tmp/redislogs/redis.log </span><br><span class="line">27337:C 29 Oct 2019 13:53:20.629 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span><br><span class="line">27337:C 29 Oct 2019 13:53:20.629 # Redis version=5.0.5, bits=64, commit=00000000, modified=0, pid=27337, just started</span><br><span class="line">27337:C 29 Oct 2019 13:53:20.629 # Configuration loaded</span><br><span class="line">                _._                                                  </span><br><span class="line">           _.-``__ &apos;&apos;-._                                             </span><br><span class="line">      _.-``    `.  `_.  &apos;&apos;-._           Redis 5.0.5 (00000000/0) 64 bit</span><br><span class="line">  .-`` .-```.  ```\/    _.,_ &apos;&apos;-._                                   </span><br><span class="line"> (    &apos;      ,       .-`  | `,    )     Running in standalone mode</span><br><span class="line"> |`-._`-...-` __...-.``-._|&apos;` _.-&apos;|     Port: 6379</span><br><span class="line"> |    `-._   `._    /     _.-&apos;    |     PID: 27338</span><br><span class="line">  `-._    `-._  `-./  _.-&apos;    _.-&apos;                                   </span><br><span class="line"> |`-._`-._    `-.__.-&apos;    _.-&apos;_.-&apos;|                                  </span><br><span class="line"> |    `-._`-._        _.-&apos;_.-&apos;    |           http://redis.io        </span><br><span class="line">  `-._    `-._`-.__.-&apos;_.-&apos;    _.-&apos;                                   </span><br><span class="line"> |`-._`-._    `-.__.-&apos;    _.-&apos;_.-&apos;|                                  </span><br><span class="line"> |    `-._`-._        _.-&apos;_.-&apos;    |                                  </span><br><span class="line">  `-._    `-._`-.__.-&apos;_.-&apos;    _.-&apos;                                   </span><br><span class="line">      `-._    `-.__.-&apos;    _.-&apos;                                       </span><br><span class="line">          `-._        _.-&apos;                                           </span><br><span class="line">              `-.__.-&apos;                                               </span><br><span class="line"></span><br><span class="line">27338:M 29 Oct 2019 13:53:20.632 # WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.</span><br><span class="line">27338:M 29 Oct 2019 13:53:20.632 # Server initialized</span><br><span class="line">27338:M 29 Oct 2019 13:53:20.632 # WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add &apos;vm.overcommit_memory = 1&apos; to /etc/sysctl.conf and then reboot or run the command &apos;sysctl vm.overcommit_memory=1&apos; for this to take effect.</span><br><span class="line">27338:M 29 Oct 2019 13:53:20.632 # WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command &apos;echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled&apos; as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled.</span><br><span class="line">27338:M 29 Oct 2019 13:53:20.632 * Ready to accept connections</span><br><span class="line">^C</span><br><span class="line">[double_happy@hadoop101 redis-5.0.5]$ ^C</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">客户端操作：  需要把redis.conf  里的 bind 去掉 或者 配置成 0.0.0.0</span><br><span class="line">[double_happy@hadoop101 redis-5.0.5]$ src/redis-cli -h hadoop101 -p 6379</span><br><span class="line">hadoop101:6379&gt; </span><br><span class="line"></span><br><span class="line">再黑窗口查看 redis还是比较麻烦的 </span><br><span class="line">https://www.jianshu.com/p/6895384d2b9e 安装一下</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191029140404559.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Redis多数据库特性：</span><br><span class="line">	1.默认有16个数据库   可以改的   redis.conf       </span><br><span class="line">		通常情况下 数据库之间是 隔离的</span><br><span class="line">	2.</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191029140735994.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Redis 切换库 黑窗口：</span><br><span class="line"></span><br><span class="line">hadoop101:6379&gt; select 1</span><br><span class="line">OK</span><br><span class="line">hadoop101:6379[1]&gt; select 0</span><br><span class="line">OK</span><br><span class="line">hadoop101:6379&gt; select 16</span><br><span class="line">(error) ERR DB index is out of range</span><br><span class="line">hadoop101:6379&gt;</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191029140944482.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">1.	通常情况下 数据库之间是 隔离的</span><br><span class="line"></span><br><span class="line">hadoop101:6379&gt; select 1</span><br><span class="line">OK</span><br><span class="line">hadoop101:6379[1]&gt; set  bigdata spark</span><br><span class="line">OK</span><br><span class="line">hadoop101:6379[1]&gt; get  bigdata</span><br><span class="line">&quot;spark&quot;</span><br><span class="line">hadoop101:6379[1]&gt; select 0</span><br><span class="line">OK</span><br><span class="line">hadoop101:6379&gt; get bigdata</span><br><span class="line">(nil)</span><br><span class="line">hadoop101:6379&gt; </span><br><span class="line"></span><br><span class="line">注意:</span><br><span class="line">flushall   这个操作没有做隔离的 会把所有的库里的东西 全部干掉 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">hadoop101:6379&gt; FLUSHALL</span><br><span class="line">OK</span><br><span class="line">hadoop101:6379&gt; select 1</span><br><span class="line">OK</span><br><span class="line">hadoop101:6379[1]&gt; get bigdata</span><br><span class="line">(nil)</span><br><span class="line">hadoop101:6379[1]&gt;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">redis里的基础命令：</span><br><span class="line">	1. keys  *    查你当前库里的所有的key</span><br><span class="line">	   这个keys 是能进行匹配的 </span><br><span class="line">eg：</span><br><span class="line">hadoop101:6379&gt; set name 1</span><br><span class="line">OK</span><br><span class="line">hadoop101:6379&gt; set name2 xx</span><br><span class="line">OK</span><br><span class="line">hadoop101:6379&gt; set name3 ll</span><br><span class="line">OK</span><br><span class="line">hadoop101:6379&gt; keys *</span><br><span class="line">1) &quot;name3&quot;</span><br><span class="line">2) &quot;name2&quot;</span><br><span class="line">3) &quot;name&quot;</span><br><span class="line">hadoop101:6379&gt; keys name*</span><br><span class="line">1) &quot;name3&quot;</span><br><span class="line">2) &quot;name2&quot;</span><br><span class="line">3) &quot;name&quot;</span><br><span class="line">hadoop101:6379&gt; keys name?</span><br><span class="line">1) &quot;name3&quot;</span><br><span class="line">2) &quot;name2&quot;</span><br><span class="line">hadoop101:6379&gt; keys name[0-9]</span><br><span class="line">1) &quot;name3&quot;</span><br><span class="line">2) &quot;name2&quot;</span><br><span class="line">hadoop101:6379&gt;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">2.判断某一个key 存不存在 </span><br><span class="line">exists  对应的key      返回1 表示存在 </span><br><span class="line">eg：</span><br><span class="line">hadoop101:6379&gt; EXISTS name</span><br><span class="line">(integer) 1</span><br><span class="line">hadoop101:6379&gt; EXISTS name10</span><br><span class="line">(integer) 0</span><br><span class="line">hadoop101:6379&gt;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">3.删除  </span><br><span class="line">del  key </span><br><span class="line">del key1 key2</span><br><span class="line"></span><br><span class="line">hadoop101:6379&gt; DEL name </span><br><span class="line">(integer) 1</span><br><span class="line">hadoop101:6379&gt; del name1 name2</span><br><span class="line">(integer) 1</span><br><span class="line">hadoop101:6379&gt; </span><br><span class="line"></span><br><span class="line">或者 会到外面删除 </span><br><span class="line">[double_happy@hadoop101 redis-5.0.5]$ src/redis-cli keys &quot;*&quot;</span><br><span class="line">1) &quot;name1&quot;</span><br><span class="line">2) &quot;name3&quot;</span><br><span class="line">3) &quot;name2&quot;</span><br><span class="line">[double_happy@hadoop101 redis-5.0.5]$ src/redis-cli del `redis-cli keys &quot;name*&quot;`</span><br><span class="line">(integer) 3</span><br><span class="line">[double_happy@hadoop101 redis-5.0.5]$ src/redis-cli keys &quot;*&quot;</span><br><span class="line">(empty list or set)</span><br><span class="line">[double_happy@hadoop101 redis-5.0.5]$</span><br></pre></td></tr></table></figure></div>

<p>命令太多了 看官网<br><a href="https://redis.io/commands#generic" target="_blank" rel="noopener">Commands</a></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">查看 key的类型：</span><br><span class="line">hadoop101:6379&gt; type name</span><br><span class="line">string</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">但是真的记不住怎么办？</span><br><span class="line">help</span><br><span class="line"></span><br><span class="line">hadoop101:6379&gt; help</span><br><span class="line">redis-cli 5.0.5</span><br><span class="line">To get help about Redis commands type:</span><br><span class="line">      &quot;help @&lt;group&gt;&quot; to get a list of commands in &lt;group&gt;</span><br><span class="line">      &quot;help &lt;command&gt;&quot; for help on &lt;command&gt;</span><br><span class="line">      &quot;help &lt;tab&gt;&quot; to get a list of possible help topics</span><br><span class="line">      &quot;quit&quot; to exit</span><br><span class="line"></span><br><span class="line">To set redis-cli preferences:</span><br><span class="line">      &quot;:set hints&quot; enable online hints</span><br><span class="line">      &quot;:set nohints&quot; disable online hints</span><br><span class="line">Set your preferences in ~/.redisclirc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">help  @&lt;group&gt;  用的最多</span><br></pre></td></tr></table></figure></div>

<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">eg：</span><br><span class="line">hadoop101:6379&gt; help @string</span><br><span class="line"></span><br><span class="line">  APPEND key value</span><br><span class="line">  summary: Append a value to a key</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  BITCOUNT key [start end]</span><br><span class="line">  summary: Count set bits in a string</span><br><span class="line">  since: 2.6.0</span><br><span class="line"></span><br><span class="line">  BITFIELD key [GET type offset] [SET type offset value] [INCRBY type offset increment] [OVERFLOW WRAP|SAT|FAIL]</span><br><span class="line">  summary: Perform arbitrary bitfield integer operations on strings</span><br><span class="line">  since: 3.2.0</span><br><span class="line"></span><br><span class="line">  BITOP operation destkey key [key ...]</span><br><span class="line">  summary: Perform bitwise operations between strings</span><br><span class="line">  since: 2.6.0</span><br><span class="line"></span><br><span class="line">  BITPOS key bit [start] [end]</span><br><span class="line">  summary: Find first bit set or clear in a string</span><br><span class="line">  since: 2.8.7</span><br><span class="line"></span><br><span class="line">  DECR key</span><br><span class="line">  summary: Decrement the integer value of a key by one</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  DECRBY key decrement</span><br><span class="line">  summary: Decrement the integer value of a key by the given number</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  GET key</span><br><span class="line">  summary: Get the value of a key</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  GETBIT key offset</span><br><span class="line">  summary: Returns the bit value at offset in the string value stored at key</span><br><span class="line">  since: 2.2.0</span><br><span class="line"></span><br><span class="line">  GETRANGE key start end</span><br><span class="line">  summary: Get a substring of the string stored at a key</span><br><span class="line">  since: 2.4.0</span><br><span class="line"></span><br><span class="line">  GETSET key value</span><br><span class="line">  summary: Set the string value of a key and return its old value</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  INCR key</span><br><span class="line">  summary: Increment the integer value of a key by one</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  INCRBY key increment</span><br><span class="line">  summary: Increment the integer value of a key by the given amount</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  INCRBYFLOAT key increment</span><br><span class="line">  summary: Increment the float value of a key by the given amount</span><br><span class="line">  since: 2.6.0</span><br><span class="line"></span><br><span class="line">  MGET key [key ...]</span><br><span class="line">  summary: Get the values of all the given keys</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  MSET key value [key value ...]</span><br><span class="line">  summary: Set multiple keys to multiple values</span><br><span class="line">  since: 1.0.1</span><br><span class="line"></span><br><span class="line">  MSETNX key value [key value ...]</span><br><span class="line">  summary: Set multiple keys to multiple values, only if none of the keys exist</span><br><span class="line">  since: 1.0.1</span><br><span class="line"></span><br><span class="line">  PSETEX key milliseconds value</span><br><span class="line">  summary: Set the value and expiration in milliseconds of a key</span><br><span class="line">  since: 2.6.0</span><br><span class="line"></span><br><span class="line">  SET key value [expiration EX seconds|PX milliseconds] [NX|XX]</span><br><span class="line">  summary: Set the string value of a key</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  SETBIT key offset value</span><br><span class="line">  summary: Sets or clears the bit at offset in the string value stored at key</span><br><span class="line">  since: 2.2.0</span><br><span class="line"></span><br><span class="line">  SETEX key seconds value</span><br><span class="line">  summary: Set the value and expiration of a key</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  SETNX key value</span><br><span class="line">  summary: Set the value of a key, only if the key does not exist</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  SETRANGE key offset value</span><br><span class="line">  summary: Overwrite part of a string at key starting at the specified offset</span><br><span class="line">  since: 2.2.0</span><br><span class="line"></span><br><span class="line">  STRLEN key</span><br><span class="line">  summary: Get the length of the value stored in a key</span><br><span class="line">  since: 2.2.0</span><br><span class="line"></span><br><span class="line">hadoop101:6379&gt;</span><br></pre></td></tr></table></figure></div>

<p><strong>数据类型：</strong><br>这个需要掌握的 </p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String类型：</span><br><span class="line">setnx ：</span><br><span class="line">SETNX key value</span><br><span class="line">  summary: Set the value of a key, only if the key does not exist</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">很多 incr可以用来统计在线人数</span><br><span class="line"></span><br><span class="line">Hash类型： ***</span><br><span class="line">场景 多了一个字段  假如 100行数据只有一条记录  多了这个字段</span><br><span class="line">大数据里 偏移量使用它 来存储的 </span><br><span class="line"></span><br><span class="line">hmset:</span><br><span class="line">对已有的会修改 对没有的会加上去</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/2019102914564719.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>idea开发</strong></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class RedisApp &#123;</span><br><span class="line"></span><br><span class="line">    String host = &quot;hadoop101&quot;;</span><br><span class="line">    int port = 6379;</span><br><span class="line"></span><br><span class="line">    Jedis jedis ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test01() &#123;</span><br><span class="line">        jedis.set(&quot;info&quot;, &quot;double_happy&quot;);</span><br><span class="line"></span><br><span class="line">        Assert.assertEquals(&quot;double_happy&quot;,jedis.get(&quot;info&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Before</span><br><span class="line">    public void setUp() &#123;</span><br><span class="line">        jedis = new Jedis(host,port);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void tearDown() &#123;</span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">查看结果： 绿了哈    注意命令和api 一一对应的 </span><br><span class="line"></span><br><span class="line">突然想到一个梗 ：</span><br><span class="line">	异地恋最重要的是什么？</span><br><span class="line">	最重要的是 相互信任  这样对四个人都好</span><br></pre></td></tr></table></figure></div>
<p><img src="https://img-blog.csdnimg.cn/20191029151736313.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kb3VibGVoYXBweS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>

      
    </div>
    
  </div>
  
  
</article>

  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>


</section>
        <aside id="sidebar">
  
    <div class="widget-box">
  <div class="avatar-box">
    <img class="avatar" src="/images/default-avatar.jpg" title="图片来自网络"></img>
    <h3 class="avatar-name">
      
        DoubleHappy
      
    </h3>
    <p class="avatar-slogan">
      特别耐撕的大数据，资深的打酱油攻城狮。
    </p>
  </div>
</div>


  
    

  
    

  
    
  
    
  <div class="widget-box">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li></ul>
    </div>
  </div>

  
    
  <div class="widget-box">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/01/05/Azkaban%E8%B0%83%E5%BA%A6-double-happy/">Azkaban调度--double_happy</a>
          </li>
        
          <li>
            <a href="/2019/01/04/Zookeeper%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%9B%91%E6%8E%A7-Curator/">Zookeeper基本使用与监控(Curator)</a>
          </li>
        
          <li>
            <a href="/2018/04/17/SparkSQL-TextFile%E8%BE%93%E5%87%BA%E5%A4%9A%E5%88%97/">SparkSQL--TextFile输出多列</a>
          </li>
        
          <li>
            <a href="/2018/03/17/%E9%9B%85%E6%81%A9%E8%B5%84%E6%BA%90%E8%B0%83%E4%BC%98-double-happy/">雅恩资源调优---double_happy</a>
          </li>
        
          <li>
            <a href="/2018/02/22/SS04/">SS04</a>
          </li>
        
      </ul>
    </div>
  </div>

  
      <div class="widget-box">
    <h3 class="widget-title">友链</h3>
    <div class="widget">
      
        <a style="display: block;" href="https://sxwanggit126.github.io/" title target='_blank'
        >一路眼瞎</a>
      
    </div>
  </div>

  
</aside>
      </div>
      <footer id="footer">
  <div class="foot-box global-width">
    &copy; 2019 DoubleHappy &nbsp;&nbsp;
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    &nbsp;|&nbsp;主题 <a href="https://github.com/yiluyanxia/hexo-theme-antiquity" target="_blank" rel="noopener">antiquity</a>
    <br>
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span id="busuanzi_container_site_pv">不蒜子告之   阁下是第<span id="busuanzi_value_site_pv"></span>个访客</span>
  </div>
</footer>
      <script src="https://code.jquery.com/jquery-2.0.3.min.js"></script>
<script>
if (!window.jQuery) {
var script = document.createElement('script');
script.src = "/js/jquery-2.0.3.min.js";
document.body.write(script);
}
</script>


<script src="/js/script.js"></script>



    </div>
    <nav id="mobile-nav" class="mobile-nav-box">
  <div class="mobile-nav-img mobile-nav-top"></div>
  
    <a href="/archives" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
  <div class="mobile-nav-img  mobile-nav-bottom"></div>
</nav>    
  </div>
</body>
</html>